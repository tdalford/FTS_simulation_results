
#+BEGIN_SRC jupyter-python :session py :kernel python3
import numpy as np
import matplotlib.pyplot as plt
import itertools
import RayTraceFunctionsv2

import importlib
importlib.reload(RayTraceFunctionsv2)
#assert RayTraceFunctionsv2.test_dims()
from RayTraceFunctionsv2 import * 

from random import uniform
import random
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio; pio.renderers.default='browser'
import pickle
import yaml

import time

%load_ext autoreload
%autoreload 2

import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
#mpl.rcParams['figure.dpi'] = 200
#mpl.rcParams['figure.facecolor'] = '1'

import coupling_optics_sims as csims
import notebook_utils
import fts_coupling_optics_geo as fts
from fts_coupling_optics_geo import *

# Calculated from Mathematica, see FTSImagesAndChecks.nb
LAST_LENS_EDGE = [-231.24377979, -266.21940725, 0.] 
COUPLING_OPTICS_ORIGIN = [-233.28894593160666, -276.84436350628596, 0.]
#+END_SRC

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload


#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_aspect(config, aspect, element, number):
    '''Obtain the config for a given aspect, element, and number
    
    Parameters:
        config (yaml file)  -- yaml configuration file loaded
        aspect (str)        -- aspect of the FTS (origins, angles, coefficients, etc)
        element (str)       -- element of the FTS for which this aspect is defined 
                              (ellipses, mirror, polarizers)
        number (int)        -- number of the element that we're specifically interested
                            in (1-10 for ellipses, 1-4 for polarizers)'''
    
    def get_item(dic, key, num):
        if type(dic[key]) is dict:
            return dic[key][num]
        else:
            return dic[key]
        
    if element is None:
        return get_item(config, aspect, number)
    else:
        return get_item(config[aspect], element, number)
    
#with open("lab_fts_dims_dicts.yml", "r") as stream:
#    config_v2 = yaml.safe_load(stream)
    
#with open("lab_fts_dims_dicts_old.yml", "r") as stream:
#    config_old = yaml.safe_load(stream)
    
with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)
    
#with open("lab_fts_dims_mcmahon_real.yml", "r") as stream:
#    config_real = yaml.safe_load(stream)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
# For creating regions for the central polarizers and central mirror
def get_ranges_and_global_coords(n, angle, ellipse_coeffs, length, direc,
                                 origin, theta, rad):
    assert direc in ['pos', 'neg']
    x1, y1, z1, x2, y2, z2 = FTSEC(n, angle, ellipse_coeffs, length, direc)

    def get_half_ranges(rad, xvals, yvals, zvals):
        x_global, y_global, z_global = transformLG(xvals, yvals, zvals, origin,
                                                   theta)
        xset, yset, zset = SR2(rad, x_global, y_global, z_global, origin)
        return xset, yset, zset

    xg1, yg1, zg1 = get_half_ranges(rad, x1, y1, z1)
    xg2, yg2, zg2 = get_half_ranges(rad, x2, y2, z2)
    center, range_vals = xrangeGL7(xg1, yg1, zg1, xg2, yg2, zg2, origin, theta)
    xg1.extend(xg2)
    yg1.extend(yg2)
    zg1.extend(zg2)
    return center, range_vals, [xg1, yg1, zg1]

n_val = 100
angle = np.pi / 8
length = 90
rad_val = 42.278
num_ellipse = [1, 2, 3, 4, 5, 6, 8, 9]

total_ellipse_centers = []
total_ellipse_ranges = []
total_ellipse_points = []

for i, num in enumerate(num_ellipse): 
    origin = get_aspect(config, 'origins', 'ellipses', num)
    direc = ['pos', 'neg'][origin[1] > 0]
    theta = get_aspect(config, 'angles', 'ellipses', num)
    coeffs = get_aspect(config, 'coefficients', 'ellipses', num)

    center, range_vals, points = get_ranges_and_global_coords(
        n_val, angle, coeffs, length, direc, origin, theta, rad_val)

    total_ellipse_centers.append(center)
    total_ellipse_ranges.append(range_vals)
    total_ellipse_points.append(points)
    
    # Make sure these match the file!
    print('ellipse %s: ' %num)
    print('center: %s range: %s \n' %(list(np.round(center, 4)), list(np.round(range_vals, 4))))
    assert (np.abs(np.array(center) - np.array(get_aspect(config, 'centers', None, num))) < .0001).all()
    assert (np.abs(np.array(range_vals) - np.array(get_aspect(config, 'ranges', None, num))) < .0001).all()

#+END_SRC

#+RESULTS:
#+begin_example
ellipse 1: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 

ellipse 2: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 

ellipse 3: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 4: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 5: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 6: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 8: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 9: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_2d_ellipse(coeffs, center, n_points=1000):
    # assume no rotation here for simplicity
    # equation is (x - h)^2 / a^2 + (y - k)^2 / b^2 = 1
    assert len(center) == 2
    x_coeff, y_coeff = coeffs
    
    # First give a range of x values
    x_vals = np.linspace(-x_coeff, x_coeff, n_points) + center[0]
    # have to plot two y function to combine to the circle
    y1 = (np.sqrt(1 - ((x_vals - center[0]) / x_coeff)  ** 2)) * y_coeff + center[1]
    y2 = -(np.sqrt(1 - ((x_vals - center[0]) / x_coeff)  ** 2)) * y_coeff + center[1]
    
    return x_vals, y1, y2

def plot_mirrors(total_points, colors, fig):
    for i, points in enumerate(total_points):
        half_index = len(points[0]) // 2
        x1, y1, z1 = [points[j][:half_index] for j in range(len(points))]
        x2, y2, z2 = [points[j][half_index:] for j in range(len(points))]

        mesh1 = go.Mesh3d(x=x1, y=y1, z=z1, color=colors[i], opacity=0.50)
        mesh2 = go.Mesh3d(x=x2, y=y2, z=z2, color=colors[i], opacity=0.50)

        fig.add_trace(mesh1)
        fig.add_trace(mesh2)
        
def plot_rays(total_ray_points, total_ray_vectors, total_ray_distances, colors, fig, ray_alpha=None):
    for i in range(len(total_ray_points)):
        for j, point in enumerate(total_ray_points[i]):
            vector = total_ray_vectors[i][j]
            distance = total_ray_distances[i][j + 1]
            x, y, z = [[point[k], point[k] + distance * vector[k]] for k in range(3)]
            #print(colors)
            if ray_alpha is None:
                ray_alpha = .5
            line_data = go.Scatter3d(x=x, y=y, z=z, mode='lines', showlegend=False, 
                                     line=dict(color=colors[j]), opacity=ray_alpha)
            fig.add_trace(line_data)
            
def plot_center_items(fig, centers, coeffs, thicknesses, colors, opacities, n_points=1000):
    for i in range(len(centers)):
        # We want to find this ellipse over x and y here..
        x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
        x, z1, z2 = get_2d_ellipse(coeffs[i], (centers[i][0], centers[i][2]), n_points=n_points)
        for y in np.linspace(centers[i][1] - thicknesses[i], centers[i][1] + thicknesses[i], 10):
            x_vals.extend(x)
            z1_vals.extend(z1)
            z2_vals.extend(z2)
            y_vals.extend(n_points * [y])

        side1 = go.Mesh3d(x=x_vals, y=y_vals, z=z1_vals, color=colors[i], opacity=opacities[i]) 
        side2 = go.Mesh3d(x=x_vals, y=y_vals, z=z2_vals, color=colors[i], opacity=opacities[i])
        fig.add_trace(side1)
        fig.add_trace(side2)
        
def plot_det(fig, det_center, det_range, det_angle, thickness):
    x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
    x, z1, z2 = get_2d_ellipse([det_range, det_range], (0, 0), n_points=100)
    for y in np.linspace(-thickness, thickness, 10):
        x_vals.extend(x)
        z1_vals.extend(z1)
        z2_vals.extend(z2)
        y_vals.extend(100 * [y])
        
    x1, y1, z1 = transformLG(x_vals, y_vals, z1_vals, det_center, det_angle)
    x2, y2, z2 = transformLG(x_vals, y_vals, z2_vals, det_center, det_angle)

    side1 = go.Mesh3d(x=x1, y=np.array(y1), z=z1, color='gray', opacity=.2, alphahull=0) 
    side2 = go.Mesh3d(x=x2, y=np.array(y2), z=z2, color='gray', opacity=.2, alphahull=0)
    fig.add_trace(side1)
    fig.add_trace(side2)
    
def plot_rotated_ellipse(fig, ellipse_center, ellipse_range, ellipse_normal_vec, thickness, 
                         n_points=100, color='gray'):
    x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
    x, z1, z2 = get_2d_ellipse([ellipse_range, ellipse_range], (0, 0), n_points=n_points)
    for y in np.linspace(-thickness, thickness, 10):
        x_vals.extend(x)
        z1_vals.extend(z1)
        z2_vals.extend(z2)
        y_vals.extend(n_points * [y])
        
    rotation_matrix = get_rotation_matrix(ellipse_normal_vec, [0, 1, 0]) # the reference vector we have chosen.
    # now rotate these 
    x1, y1, z1 = transform_points(x_vals, y_vals, z1_vals, ellipse_center, rotation_matrix)
    x2, y2, z2 = transform_points(x_vals, y_vals, z2_vals, ellipse_center, rotation_matrix)

    side1 = go.Mesh3d(x=x1, y=np.array(y1), z=z1, color=color, opacity=.2, alphahull=0) 
    side2 = go.Mesh3d(x=x2, y=np.array(y2), z=z2, color=color, opacity=.2, alphahull=0)
    fig.add_trace(side1)
    fig.add_trace(side2)
    
def plot_rotated_plane(fig, plane_center, plane_range, plane_normal_vec, thickness, 
                       n_points=100):
    x_vals, y_vals, z_vals = [], [], []
    x = np.linspace(-plane_range, plane_range, int(np.sqrt(n_points)))
    z = np.linspace(-plane_range, plane_range, int(np.sqrt(n_points)))
    xx, zz = np.meshgrid(x, z)
    xx = xx.flatten()
    zz = zz.flatten()
    
    #x, z1, z2 = get_2d_ellipse([ellipse_range, ellipse_range], (0, 0), n_points=n_points)
    for y in np.linspace(-thickness, thickness, 3):
        x_vals.extend(xx)
        z_vals.extend(zz)
        y_vals.extend(len(xx) * [y])
        
    rotation_matrix = get_rotation_matrix(plane_normal_vec, [0, 1, 0]) # the reference vector we have chosen.
    # now rotate these 
    x1, y1, z1 = transform_points(x_vals, y_vals, z_vals, plane_center, rotation_matrix)
    #x2, y2, z2 = transform_points(x_vals, y_vals, z2_vals, ellipse_center, rotation_matrix)

    side1 = go.Mesh3d(x=x1, y=np.array(y1), z=z1, color='gray', opacity=.2, alphahull=0) 
    #side2 = go.Mesh3d(x=x2, y=np.array(y2), z=z2, color='gray', opacity=.2, alphahull=0)
    fig.add_trace(side1)
    #fig.add_trace(side2)
    
def get_rotation_matrix(a, b):
    v = np.cross(a, b)
    s = np.sqrt(np.sum(np.square(v)))
    c = np.dot(a, b)
    vx = np.array([[0, -v[2], v[1]], 
                  [v[2], 0, -v[0]], 
                  [-v[1], v[0], 0]])
    return np.identity(3) + vx + np.linalg.matrix_power(vx, 2) * (1 - c) / (s ** 2)
    
    
def transform_points(x_vals, y_vals, z_vals, new_origin, rotation_matrix):
    XTR = []
    YTR = []
    ZTR = []
    for i in range(0, len(x_vals)):
        v = [x_vals[i], y_vals[i], z_vals[i]]
        #v2R = rotate(v, thetaxyz)
        v2R = np.dot(v, rotation_matrix)
        v2RS = v2R + new_origin
        XTR.append(v2RS[0])
        YTR.append(v2RS[1])
        ZTR.append(v2RS[2])
    return XTR, YTR, ZTR
    
        
def rotate_ellipse(xvals, yvals, z1_vals, z2_vals, theta):
    points_new = []
    for zvals in [z1_vals, z2_vals]:
        points = transformLG(xvals, yvals, zvals, [0, 0, 0], theta)
        points_new.append(points)
    return points_new

def plot_dihedral(fig, center, coeff, thickness):
    # We want to find this ellipse over x and z here
    x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
    x, z1, z2 = get_2d_ellipse(coeff, (center[0], center[2]), n_points=1000)
    for y in np.linspace(-1 * thickness, thickness, 10):
        x_vals.extend(x)
        z1_vals.extend(z1)
        z2_vals.extend(z2)
        y_vals.extend(1000 * [y]) 

    # Rotate both parts around the x axis
    for theta in [[np.pi / 4, 0, 0], [-np.pi / 4, 0, 0]]:
        p1s, p2s = rotate_ellipse(x_vals, y_vals, z1_vals, z2_vals, theta)
        x1, y1, z1 = p1s
        x2, y2, z2 = p2s

        side1 = go.Mesh3d(x=x1, y=np.array(y1) + center[1], z=z1, color='blue', opacity=.25) 
        side2 = go.Mesh3d(x=x2, y=np.array(y2) + center[1], z=z2, color='blue', opacity=.25)
        fig.add_trace(side1)
        fig.add_trace(side2)

def plot_segment(point, vector, distance, fig, color):
    xval, yval, zval = [[point[k], point[k] + distance * vector[k]] for k in range(3)]
    line_data = go.Scatter3d(x=xval, y=yval, z=zval, mode='lines', showlegend=False, 
                         line=dict(color=color), opacity=.3 / 4)
    fig.add_trace(line_data)
    
def plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=None, 
                   ray_alpha=None):
    if (fig is None):
        fig = go.Figure()

    # Plot the elliptical mirrors
    colors = 9 * ['silver']
    plot_mirrors(total_ellipse_points, colors, fig)

    # Plot the rays
    colors = ['black', 'black', 'red', 'red', 'orange', 'black', 'orange', 'yellow',
              'yellow', 'green', 'green', 'blue', 'blue', 'purple']
    colors = 14 * ['black']
    for points, vectors, distances in zip(all_points, all_vectors, all_distances):
        plot_rays(points, vectors, distances, colors, fig, ray_alpha=ray_alpha)

    # Plot the polarizers and 'detector'
    centers = [get_aspect(config, 'origins', 'polarizers', i + 1) for i in range(4)]# + [
        #config['detector']['center']]# + np.array([0, -1, 0])]
    coeffs = [get_aspect(config, 'coefficients', 'polarizers', i + 1)[:2] for i in range(4)]# + [
        #[config['detector']['range'], config['detector']['range']]]

    #coeffs = 4 * [coeffpolar[:2]]
    thicknesses = 4 * [.4]
    colors = 4 * ['teal']# + ['black']
    opacities = 4 * [.2]# + [.4]
    n_points = 100
    plot_center_items(fig, centers, coeffs, thicknesses, colors, opacities, n_points=n_points)

    # Plot the dihedral mirror
    coeff = coeffs[0]
    thickness = 1
    plot_dihedral(fig, mirror_position, coeff, thickness)
    
    # Plot the detector
    # plot_rotated_ellipse(fig, config['detector']['center'], config['detector']['range'], 
    #                     config['detector']['normal_vec'], thicknesses[0], n_points=100)

    # # plot the final mirrors
    # plot_rotated_plane(fig, config['other_mirrors'][1]['origin'], 60,  
    #                    config['other_mirrors'][1]['normal_vec'], thicknesses[0], n_points=100)

    # plot_rotated_ellipse(fig, config['other_mirrors'][2]['origin'], 60, 
    #                      config['other_mirrors'][2]['normal_vec'], thicknesses[0], 
    #                      n_points=100)
    
    # # plot the aperture
    # plot_rotated_ellipse(fig, config['apertures'][1]['origin'], config['apertures'][1]['range'], 
    #                      config['apertures'][1]['normal_vec'], thicknesses[0], 
    #                      n_points=100, color='black')


    # Update the figure settings
    fig.update_layout(scene = dict(xaxis_title='Z (mm)', yaxis_title='Y (mm)',
                                   zaxis_title='X (mm)',
                        yaxis=dict(range=[-1000, 500]),
                        zaxis=dict(range=[-300, 300]),
                        xaxis=dict(range=[-1000, 500])),
                      width=700)#,
                      #margin=dict(r=20, b=10, l=10, t=10))


    #fig.show()
    
def transform_rays_perfect(rays, config, plot=False, plot_mirror_position=35, fig=None):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE #[-231.24377979, -266.21940725, 0.]
    angle = .19016
    for ray in rays:
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        #ray[2] = np.add(ray[2], source_point_origin)
        ray[3] = new_vec
        #ray[4] = 0
        
    possible_paths = get_possible_paths()
        
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    if (plot):
        all_points, all_vectors, all_distances= [], [], []
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238)
        
        if (plot):
            all_points.append(total_ray_points)
            all_vectors.append(total_vectors)
            all_distances.append(total_distances)
    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig)
    return rays


def step_rays(starting_rays, config, ray_func, *ray_func_args, final_dist=50, 
              debug=1):
    # Data structure which contains starting point, vector, length for each ray
    # through the sim
    total_ray_points = []
    total_ray_vectors = []
    total_ray_distances = []
    counts = []
    max_count = None

    for starting_ray in starting_rays:
        current_rays = ray_func(
            starting_ray, *ray_func_args, return_all_rays=True)
        # We want to save the point, vector, and distance travelled for each of
        # these rays!
        points = []
        vectors = []
        distances = [starting_ray[4]]
        count = 0
        max_count = len(current_rays) + 1
        for i, ray in enumerate(current_rays):
            if ray is not None:
                count += 1
                points.append(ray[2])
                vectors.append(ray[3])

                # If we're not at the final ray and the next ray hit,
                # calculated the distance!
                if (i < len(current_rays) - 1):
                    if current_rays[i + 1] is not None:
                        distances.append(
                            current_rays[i + 1][4] - current_rays[i][4])
                else:
                    # The ray made it to the last detector; give it some
                    # smaller distance to visualize.
                    final_ray = get_final_rays_tilt(
                        [ray], config['detector']['center'], config['detector']['range'],
                        config['detector']['normal_vec'])
                    if (final_ray) != []:
                        distances.append(dist(ray[2], final_ray[0][2]))
                        count += 1

                    else:
                        distances.append(final_dist)

                    # distances.append(final_dist)
            else:
                # The ray did not make it to the end.
                # Append a final distance for the last ray so we can see where
                # it went.
                distances.append(final_dist)

        total_ray_points.append(points)
        total_ray_vectors.append(vectors)
        total_ray_distances.append(distances)
        counts.append(count)

    assert debug in [0, 1, 2]
    if (debug == 2):
        print('final ray counts = %s' % counts)
    if (debug == 1):
        print('initial number of rays = %s' % len(starting_rays))
        print('total number of rays making past the first ellipse = %s' % np.sum(
            np.array(counts) != 1))
        print('total number of rays making it all the way through = %s' % np.sum(
            np.array(counts) == max_count))
    return total_ray_points, total_ray_vectors, total_ray_distances
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_plane(coeffs, center, n_points=100 * 100, point_range=10, z_set_value=None):
    # equation is given by A x + B y + C z = D
    assert len(coeffs) == 4
    assert len(center) == 2
    x_points = np.linspace(center[0] - point_range, center[0] + point_range, int(np.sqrt(n_points)))
    y_points = np.linspace(center[1] - point_range, center[1] + point_range, int(np.sqrt(n_points)))
    x, y = np.meshgrid(x_points, y_points)
    a, b, c, d = coeffs
    z = (a * x + b * y  - d) / c
    # set a highest value for z- kinda hacky
    if z_set_value is not None:
        z[z > z_set_value] = z_set_value#z_set_value
        z[z < -1 * z_set_value] = 0#-1 * z_set_value
    return x, y, z

def plot_surface(x, y, z, fig, color, alpha=.1):
    shape = go.Mesh3d(x=x, y=y, z=z, color=color,
                      opacity=alpha, alphahull=0)
    fig.add_trace(shape)
    
def plot_surface(x, y, z, fig, color, alpha=.1):

    x_tot1, y_tot1, z_tot1 = ([], [], [])

    for l in range(len(x[0])):
        x_new_1, y_new_1, z_new_1 = x[:, l], y[:, l], z[:, l]

        x_tot1.extend(x_new_1)
        y_tot1.extend(y_new_1)
        z_tot1.extend(z_new_1)

    # Change x and z directions to match FTS defined
    shape = go.Mesh3d(z=z_tot1, y=y_tot1, x=x_tot1, color=color,
                      opacity=alpha, alphahull=-1)
    fig.add_trace(shape)

def plot_plane(fig, origin, point_range=10, n_points=50,  tilt_angle=None, normal_vec=None, 
               z_set_value=None):
    # first we need to get the coefficients
    # we find these by applying the tilt to the original normal vector,
    # which is (0, 1, 0)
    if (normal_vec) is None:
        assert tilt_angle is not None
        normal_vec = transformLG(1e-10, 1, 1e-10, [0, 0, 0], tilt_angle)
    # add some jitter so we don't div by zero
    normal_vec = np.add(normal_vec, [1e-5, 1e-5, 1e-5])
    print(normal_vec)
    # our origin is still the same.. e.g. we just need to get the new d coeff
    d = np.dot(origin, np.array(normal_vec))
    # now just plot these
    a, b, c = normal_vec
    x, y, z = get_plane([a, b, c, d], origin[:2], n_points=n_points, point_range=point_range, 
                        z_set_value=z_set_value)
    plot_surface(x, y, z, fig, 'blue')
    #fig.show()

def transform_rays_end_tilt(rays, config, plot=False, plot_mirror_position=35, fig=None, 
                            ray_alpha=None):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE#[-231.24370418, -266.21901446, 0.] # should get rid of these magic numbers.
    angle = .190161
    for ray in rays:
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        #ray[2] = np.add(ray[2], source_point_origin)
        ray[3] = new_vec
        #ray[4] = 0
        
    #possible_paths = [path + ['OM1', 'A1', 'OM2'] for path in get_possible_paths()]
    possible_paths = get_possible_paths()
        
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    all_points, all_vectors, all_distances= [], [], []
    path_diffs = []
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238)
        path_diffs.append(total_distances)
        
        all_points.append(total_ray_points)
        all_vectors.append(total_vectors)
        all_distances.append(total_distances)

    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig, 
                       ray_alpha=ray_alpha)
    return all_points, all_vectors, all_distances

def transform_rays_to_fts_frame(rays):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE#[-231.24370418, -266.21901446, 0.] # should get rid of these magic numbers.
    angle = .190161
    new_rays = []
    for ray in rays:
        new_ray = [ray[0], ray[1], None, None, ray[4]]
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        new_ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        new_ray[3] = new_vec
        new_rays.append(new_ray)

    return new_rays
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
mm_to_in = 1 / 25.4
shift = [0, 0, 0]
start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.3, plot=True, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_, path_diffs = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 80
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 80
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, .4, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.3, plot=True, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_, path_diffs = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 72
: total number of rays making past the first ellipse = 72
: total number of rays making it all the way through = 72
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 72
: total number of rays making past the first ellipse = 72
: total number of rays making it all the way through = 72

#+BEGIN_SRC jupyter-python :session py :kernel python3
[['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
#+END_SRC

#+RESULTS:
: [['OM2', 'A1', 'OM1', 'R4', 'E5', 'T3', 'E4', 'DM0', 'E3', 'T2', 'E8', 'T1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'R3', 'E4', 'DM0', 'E3', 'R2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'R3', 'E4', 'DM0', 'E3', 'T2', 'E8', 'T1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'T3', 'E2', 'DM0', 'E1', 'T2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'R4', 'E5', 'R3', 'E2', 'DM0', 'E1', 'T2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'R4', 'E5', 'R3', 'E2', 'DM0', 'E1', 'R2', 'E8', 'T1'],
:  ['OM2', 'A1', 'OM1', 'R4', 'E5', 'T3', 'E4', 'DM0', 'E3', 'R2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'T3', 'E2', 'DM0', 'E1', 'R2', 'E8', 'T1']]

#+BEGIN_SRC jupyter-python :session py :kernel python3
# now try and plot these and see what happens!
def fts_forward_raytrace(rays, config, plot=False, plot_mirror_position=35, fig=None):
    possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
    
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    if (plot):
        all_points, all_vectors, all_distances = [], [], []

    total_made = 0
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238, debug=False)
        for distances in total_distances:
            if distances[-1] != 238:
                total_made += 1
                
        if (plot):
            all_points.append(total_ray_points)
            all_vectors.append(total_vectors)
            all_distances.append(total_distances)
    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig)
    return total_made


def create_source_rays(source_origin, source_range, source_normal_vec, n_points, config,
                       check_rays=True, theta_bound=.2, timeout=10):
    # first create rays distributed in the upwards cone
    # and then rotate them to center them around the normal
    # also create them around a variety of starting points
    # assume radially symmetric source
    rotation_matrix = get_rotation_matrix(source_normal_vec, [0, 0, 1])
    rays = []
    
    # now we really have n^4 computations... for n^2 for the circle, n^2 for the angle
    # really we should just create like 20 points distributed uniformly on the circle
    # and then for each of those get like 5 * 5 vectors worth
    # for 20 * 25 total points
    
    iters = 0
    starting_time = time.time()
    while len(rays) < n_points and time.time() - starting_time < timeout:
        # generate a random starting point
        point_origin = [source_range * (2 * np.random.random() - 1), 
                        source_range * (2 * np.random.random() - 1), 0]
        # point_origin = [0, 0, 0]
        
        # create the points/vectors first and then rotate both
        # just use the old transformLG method?
        
        # generate a random starting angle and then rotate to the frame of the source
        z_val = np.random.uniform(np.cos(theta_bound), 1)
        # theta = np.arccos(np.random.uniform(-1, 1))
        phi_val = np.random.uniform(0, 2 * np.pi)

        # Direction of ray away from the starting point
        sinthet = np.sqrt(1 - z_val ** 2)
        r_hat = [sinthet * np.cos(phi_val), sinthet * np.sin(phi_val), z_val]

        transformed_starting_vector = -1 * np.array(transform_points(
            [r_hat[0]], [r_hat[1]], [r_hat[2]], [0, 0, 0], rotation_matrix)).flatten()
        
        transformed_starting_point = np.array(transform_points([point_origin[0]], [point_origin[1]], [point_origin[2]], 
                                                               source_origin, rotation_matrix)).flatten()

        # strategically choose our starting rays such that they make it through the
        # to the first ellipse that we hit
        polarization_angle = .123
        intensity = 1.0
        ray = [polarization_angle, intensity, transformed_starting_point.tolist(), 
               transformed_starting_vector.tolist(), 0]
        # paths = ['OM2', 'A1', 'OM1', 'T4', 'E6']
        if (check_rays):
            paths = ['T4', 'E6']
            final_ray = run_ray_through_sim(ray, config, None, paths)
            if (final_ray is not None):
                rays.append(ray)
        else:
            rays.append(ray)

        iters += 1
        
    return rays


def create_source_rays_uniform(
        source_origin, source_range, source_normal_vec, n_linear_radius, 
        n_linear_z, n_linear_phi, config, check_rays=True, theta_bound=.2, 
        timeout=10):
    # first create rays distributed in the upwards cone
    # and then rotate them to center them around the normal
    # also create them around a variety of starting points
    # assume radially symmetric source
    rotation_matrix = get_rotation_matrix(source_normal_vec, [0, 0, 1])
    rays = []
    
    # now we really have n^4 computations... for n^2 for the circle, n^2 for the angle
    # really we should just create like 20 points distributed uniformly on the circle
    # and then for each of those get like 5 * 5 vectors worth
    # for 20 * 25 total points
    
    starting_time = time.time()
    for x in np.linspace(-1 * source_range, source_range, n_linear_radius):
        for y in np.linspace(-1 * source_range, source_range, n_linear_radius):
            for z_val in np.linspace(np.cos(theta_bound), 1, n_linear_z):
                for phi_val in np.linspace(0, 2 * np.pi, n_linear_phi):
                    if time.time() - starting_time > timeout:
                        print('timing out..')
                        return rays

                    point_origin = [x, y, 0]
                    
                    # Direction of ray away from the starting point
                    sinthet = np.sqrt(1 - z_val ** 2)
                    r_hat = [sinthet * np.cos(phi_val), sinthet * np.sin(phi_val), z_val]

                    transformed_starting_vector = -1 * np.array(transform_points(
                        [r_hat[0]], [r_hat[1]], [r_hat[2]], [0, 0, 0], rotation_matrix)).flatten()

                    transformed_starting_point = np.array(transform_points([point_origin[0]], [point_origin[1]], [point_origin[2]], 
                                                                           source_origin, rotation_matrix)).flatten()

                    # strategically choose our starting rays such that they make it through the
                    # to the first ellipse that we hit
                    polarization_angle = .123
                    intensity = 1.0
                    ray = [polarization_angle, intensity, transformed_starting_point.tolist(), 
                        transformed_starting_vector.tolist(), 0]
                    # paths = ['OM2', 'A1', 'OM1', 'T4', 'E6']
                    if (check_rays):
                        paths = ['T4', 'E6']
                        final_ray = run_ray_through_sim(ray, config, None, paths)
                        if (final_ray is not None):
                            rays.append(ray)
                    else:
                        rays.append(ray)
        
    return rays

def transform_rays_to_coupling_optics_frame(rays):
    # we want the rays essentially directly after they hit the last polarizer
    # in the FTS and then we need to calculate the distance between this
    # polarizer and the first lens of the coupling optics
    
    # first we need to transform the rays' points and normal vectors to the
    # frame of the coupling optics
    
    # Here we really need to make sure we're properly rotating this ray really
    # the ray should stop at the plane which makes the same beam angle as the
    # coupling optics actually things should be fine I think, but just in case
    # do it this way I guess
    # don't stop at (0, 0, 0), stop at (0, -.426, 0) equivilently
    coupling_optics_origin = COUPLING_OPTICS_ORIGIN
    angle = -0.190161
    factor = csims.mm_to_in
    new_rays = []
    for ray in rays:
        new_ray = [ray[0], ray[1], None, None, ray[4]]
        # switch the x and z coordinate of these!
        new_vec = rotate(ray[3], [0, 0, angle])
        new_ray[2] = factor * np.flip(rotate(np.subtract(ray[2], coupling_optics_origin), 
                                             [0, 0, angle]) * [1, -1, 1])
        new_ray[3] = np.flip(csims.normalize(factor * new_vec * [1, -1, 1]))
        new_rays.append(new_ray)

    return new_rays

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3 :results None
with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)
fig = go.Figure()
starting_rays = create_source_rays(config['detector']['center'], config['detector']['range'], 
                                   config['detector']['normal_vec'], 2000, config, theta_bound=.2)

# now raytrace fromt these rays onwards!
total_made = fts_forward_raytrace(starting_rays, config, plot=False, plot_mirror_position=0, fig=fig)
# print(np.sum([total_made[i][-1] != 238 for i in range(len(total_made))]))
print(total_made // 2)

# this is insane, 10000 rays???
# oh mannn
fig.show()
#+END_SRC

#+RESULTS:
: 267
#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)
fig = go.Figure()
starting_rays = create_source_rays(config['detector']['center'], 1, 
                                   config['detector']['normal_vec'], 50, config, theta_bound=.2)

# now raytrace fromt these rays onwards!
total_made = fts_forward_raytrace(starting_rays, config, plot=True, plot_mirror_position=0, fig=fig)
# print(np.sum([total_made[i][-1] != 238 for i in range(len(total_made))]))
print(total_made // 2)

# this is insane, 10000 rays???
# oh mannn
fig.show()
#+END_SRC

#+RESULTS:
: 197


# might be easier to just not plot the rays that don't make it

I'll come back to this another day. but really I should probably not debug here
and just step through as normal then maybe just have a part of the function
that immediately returns if a ray is None.

* Run rays forwards through the coupling optics

#+BEGIN_SRC jupyter-python :session py :kernel python3
#with open("lab_fts_dims_mcmahon.yml", "r") as stream:
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 50, config, 
                                   theta_bound=0.2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=-20.9, plot=True,
                                         fig=fig, color='red')
fig.show()

#+END_SRC

#+RESULTS:

* Run Rays Backwards through the Coupling Optics

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'red', fig, n_linear=7,
                                                      theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_, path_diffs = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 49
: total number of rays making past the first ellipse = 49
: total number of rays making it all the way through = 49
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 49
: total number of rays making past the first ellipse = 49
: total number of rays making it all the way through = 49

* Test that running backwards and forwards returns the same rays


#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'red', fig, n_linear=1,
                                                      theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

points, vecs, dists = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1

#+BEGIN_SRC jupyter-python :session py :kernel python3
final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
np.around(final_point, decimals=10)
#+END_SRC

#+RESULTS:
: array([225.43080754, 233.69907525,  -0.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays
#+END_SRC

#+RESULTS:
: [[0.123,
:   1.0,
:   array([ 2.25430808e+02,  2.33699075e+02, -5.60952232e-14]),
:   array([-1.56062792e-01, -9.87747136e-01, -1.48645310e-18]),
:   0]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(csims.normalize(final_vec), decimals=6)
#+END_SRC

#+RESULTS:
: array([-0.156063, -0.987747, -0.      ])


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
starting_rays = [[.123, 1.0, final_point, final_vec, 0]]

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=-20.9, plot=True,
                                         fig=fig, color='red')
fig.show()
#+END_SRC

Ok, first test to see whether raytracing through the FTS itself is the same
forwards and backwards. Then we test to see if raytracing through the coupling
optics is the same.. then if those are both the same I guess we have to make
sure the combination is the same too... currently it's slightly off.

definitely test the coupling optics first


#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .2, 0])
fig = go.Figure()
out = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                               theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)
fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
intersect at lens flat from reversed = [-0.      13.91335 -0.56929]
intersect at lens 22 from reversed = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vector going from flat to 22 reversed = [ 0.      -0.16141 -0.98689]
vector from 22 to 21 reversed in global frame = [ 0.      -0.99419  0.10766]
--------------------------------------------------------------------------------
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
initial normal vec = [ 0.      -0.99419  0.10766]
P21 intersect = [0.      8.25801 0.23296]
vec at 21 in 21 surface frame = [ 0.      -0.23296 -0.00971]
vec at 22 in 21 surface frame = [-0.       0.00753  2.21099]
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 12: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_22_21 = [ 0.      -0.10766 -0.99419]
normal vec spit out from snells = [ 0.      -0.20757 -0.97822]
--------------------------------------------------------------------------------
vector going from 22 to 21 reversed = [ 0.      -0.10766 -0.99419]
intersect at lens 12 from reversed = [0.      0.09573 1.9649 ]
vector going from 21 to 12 reversed = [ 0.      -0.20757 -0.97822]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
fig = go.Figure()
out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=-20.9, plot=True,
                                                   fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 22: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_12_21 = [-0.       0.20757  0.97822]
normal vec spit out from snells=[-0.       0.10766  0.99419]
normal vector from 21 to 22 forwards in global frame = [-0.       0.99419 -0.10766]
P21 intersect = [0.      8.25801 0.23296]
initial normal vec = [-0.       0.99419 -0.10766]
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
--------------------------------------------------------------------------------
intersect at lens 22 going forwards = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vec at 21 in 22 surface frame = [ 0.      -0.23296 -2.22071]
vec at 22 in 22 surface frame = [-0.00e+00  7.53e-03 -1.00e-05]
normal vector from 21 to 22 forwards = [-0.       0.10766  0.99419]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(out_backwards[0][[0, 1, 2]], decimals=5)
#+END_SRC

#+RESULTS:
: array([[  0.     ],
:        [ 13.54406],
:        [-20.9    ]])

#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position
#+END_SRC

#+RESULTS:
: array([  0.        ,  13.54406336, -20.9       ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.array(out_backwards[1]).T, decimals=5)
#+END_SRC

#+RESULTS:
: array([[ 0.000000e+00, -4.260000e-01,  1.934990e+00],
:        [ 0.000000e+00, -1.959800e-01,  1.964450e+00],
:        [ 0.000000e+00,  9.573000e-02,  1.964900e+00],
:        [ 0.000000e+00,  8.258010e+00,  2.329600e-01],
:        [-0.000000e+00,  1.047870e+01, -7.530000e-03],
:        [-0.000000e+00,  1.391335e+01, -5.692900e-01],
:        [-0.000000e+00,  1.556334e+01, -1.065744e+01],
:        [-0.000000e+00,  1.553863e+01, -1.106052e+01],
:        [ 0.000000e+00,  1.354406e+01, -2.090000e+01]])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.array(points1).T, decimals=5)[::-1]
#+END_SRC

#+RESULTS:
: array([[ 0.000000e+00, -4.260000e-01,  1.934990e+00],
:        [ 0.000000e+00, -1.959800e-01,  1.964450e+00],
:        [ 0.000000e+00,  9.573000e-02,  1.964900e+00],
:        [ 0.000000e+00,  8.258010e+00,  2.329600e-01],
:        [-0.000000e+00,  1.047870e+01, -7.530000e-03],
:        [-0.000000e+00,  1.391335e+01, -5.692900e-01],
:        [-0.000000e+00,  1.556334e+01, -1.065744e+01],
:        [-0.000000e+00,  1.553863e+01, -1.106052e+01],
:        [ 0.000000e+00,  1.354406e+01, -2.090000e+01]])


So it is indeed slightly off.... we see that the culprit begins at the fourth
point from the end!!


first should check and see if the vectors are the same...

#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .4, 0])
# fig = go.Figure()
out, points1 = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                               theta_bound=.2, plot=False, y_ap=-.426, alpha=.2)

starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]

out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=-20.9, plot=False,
                                                   fig=fig, color='red')
# fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
intersect at lens flat from reversed = [-0.      13.67928 -0.33521]
intersect at lens 22 from reversed = [-0.      10.4553   0.30896]
vector going from flat to 22 reversed = [ 0.      -0.19593 -0.98062]
intersect at lens 21 from reversed = [0.      8.2266  0.47814]
vector going from 22 to 21 reversed = [ 0.      -0.07569 -0.99713]
intersect at lens 12 from reversed = [0.      0.48285 0.40472]
vector going from 21 to 12 reversed = [ 0.       0.00948 -0.99996]
intersection at point 21 going forwards= [0.      8.2266  0.47814]
normal vector going from 12 to 21 forwards = [-0.      -0.00948  0.99996]
intersect at lens 22 going forwards = [-0.      10.38319  0.61849]
normal vector from 21 to 22 forwards = [-0.      -0.06495  0.99789]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.array(out_backwards[1]).T, decimals=10)
#+END_SRC

#+RESULTS:
: array([[  0.        ,  -0.426     ,   0.37100744],
:        [  0.        ,  -0.41787461,   0.37164615],
:        [  0.        ,   0.48284728,   0.40471509],
:        [  0.        ,   8.22659585,   0.47813597],
:        [ -0.        ,  10.38319078,   0.61849444],
:        [ -0.        ,  12.88805014,   0.45601322],
:        [ -0.        ,  13.57392188, -10.11759151],
:        [ -0.        ,  13.60278475, -11.2755673 ],
:        [ -0.        ,  13.84920871, -20.9       ]])

The problem is at p_21 the normal vectors are different, causing a different intersect point at P_22


#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .2, 0])
# fig = go.Figure()
out, points1 = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                               theta_bound=.2, plot=False, y_ap=-.426, alpha=.2)

starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]

out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=-20.9, plot=False,
                                                   fig=fig, color='red')
# fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
intersect at lens flat from reversed = [-0.      13.91335 -0.56929]
intersect at lens 22 from reversed = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vector going from flat to 22 reversed = [ 0.      -0.16141 -0.98689]
vector from 22 to 21 reversed in global frame = [ 0.      -0.99419  0.10766]
--------------------------------------------------------------------------------
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
initial normal vec = [ 0.      -0.99419  0.10766]
P21 intersect = [0.      8.25801 0.23296]
vec at 21 in 21 surface frame = [ 0.      -0.23296 -0.00971]
vec at 22 in 21 surface frame = [-0.       0.00753  2.21099]
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 12: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_22_21 = [ 0.      -0.10766 -0.99419]
normal vec spit out from snells = [ 0.      -0.20757 -0.97822]
--------------------------------------------------------------------------------
vector going from 22 to 21 reversed = [ 0.      -0.10766 -0.99419]
intersect at lens 12 from reversed = [0.      0.09573 1.9649 ]
vector going from 21 to 12 reversed = [ 0.      -0.20757 -0.97822]
--------------------------------------------------------------------------------
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 22: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_12_21 = [-0.       0.20757  0.97822]
normal vec spit out from snells=[-0.       0.10766  0.99419]
normal vector from 21 to 22 forwards in global frame = [-0.       0.99419 -0.10766]
P21 intersect = [0.      8.25801 0.23296]
initial normal vec = [-0.       0.99419 -0.10766]
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
--------------------------------------------------------------------------------
intersect at lens 22 going forwards = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vec at 21 in 22 surface frame = [ 0.      -0.23296 -2.22071]
vec at 22 in 22 surface frame = [-0.00e+00  7.53e-03 -1.00e-05]
normal vector from 21 to 22 forwards = [-0.       0.10766  0.99419]
#+end_example



#+begin_src jupyter-python :session py :kernel python3
N_hat = [ 0.,      -0.17074,  0.98532]
tan_22_21 = [ 0.,      -0.07569, -0.99713]
csims.snell_vec(1, 1.517, np.array(N_hat), np.array(tan_22_21))
#+end_src

#+RESULTS:
: array([ 0.        ,  0.00948078, -0.99995888])

#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [ 0.,      -0.17074,  0.98532]
tan_12_21 = [-0.,      -0.00948078,  0.99995888]
csims.snell_vec(1, 1.517, -1 * np.array(N_hat), np.array(tan_12_21))
#+END_SRC

#+RESULTS:
: array([ 0.        , -0.06494426,  0.99789273])

#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [ 0.,      -0.17074,  0.98532]
tan_12_21 = [-0.,      -0.00948078,  0.99995888]
print(csims.snell_vec(1.517, 1, -1 * np.array(N_hat), np.array(tan_12_21)))
print(tan_22_21)
#+END_SRC

#+RESULTS:
: [0.         0.07569293 0.99713501]
: [0.0, -0.07569, -0.99713]

THIS IS IT!!!!!!!


#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [0, 1, 0]
tan_12_21 = csims.normalize([.3, .7, 0])
csims.normalize(csims.snell_vec(1, 2, np.array(N_hat), np.array(tan_12_21)))
#+END_SRC

#+RESULTS:
: array([ 0.19695965, -0.9804116 ,  0.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [0, 1, 0]
tan_12_21 = [-.19696, .9804, 0]
print(csims.normalize(csims.snell_vec(2, 1, np.array(N_hat), np.array(tan_12_21))))
print(csims.normalize(csims.snell_vec(1, 2, np.array(N_hat), np.array(tan_12_21))))
print(tan_12_21)
#+END_SRC

#+RESULTS:
: [-0.39392    -0.91914473  0.        ]
: [-0.09848    -0.99513903  0.        ]
: [-0.19696, 0.9804, 0]


Ok at this point I should test this in Mathematica:


Maybe make sure the n vac and n lens usages are correct

Ok the problem is that I forgot to switch the n_vac and n_lens for these surfaces
yeah I thin

IT'S FIXED!!!!!!!!

Ok now I should just test to make sure that in total the forwards and backwards raytraces are the same!

* Test Backwards and Forwards Total

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'red', fig, n_linear=1,
                                                      theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

points, vecs, dists = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig)
fig.show()
#+END_SRC

#+RESULTS:
:RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
np.around(final_point, decimals=10)
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: 
: IndexErrorTraceback (most recent call last)
: <ipython-input-17-5cdcd3c9a546> in <module>
: ----> 1 final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
:       2 final_vec = -1 * csims.normalize(vecs[0][0][-1])
:       3 np.around(final_point, decimals=10)
: 
: IndexError: invalid index to scalar variable.
:END:

#+begin_src jupyter-python :session py :kernel python3
final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
np.around(final_point, decimals=10)
#+end_src

#+RESULTS:
: array([223.34284917, 234.10097961,   0.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays
#+END_SRC

#+RESULTS:
: [[0.123,
:   1,
:   array([ 1.02817913e-16, -4.26000000e-01,  1.93499098e+00]),
:   array([5.49278019e-18, 9.91898230e-01, 1.27035040e-01]),
:   0]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(csims.normalize(final_vec), decimals=6)
#+END_SRC

#+RESULTS:
: array([-0.1045  , -0.994525,  0.      ])


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
starting_rays = [[.123, 1.0, final_point, final_vec, 0]]

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=-20.9, plot=True,
                                         fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

* Now run some rays in reverse and see how they line up

#+BEGIN_SRC jupyter-python :session py :kernel python3
mm_to_in = 1 / 25.4
shift = [0, 0, 0]
start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

# fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.25, plot=False, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

rays, path_diffs
 = transform_rays_end_tilt_path_diffs(
    start_rays_mcmahon, config, plot=False, plot_mirror_position=5, fig=fig, ray_alpha=.05)
# fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 88
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 88
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80

#+BEGIN_SRC jupyter-python :session py :kernel python3
path_diffs
#+END_SRC

#+RESULTS:
#+begin_example
[[[935.6216455277413,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   246.26768649331734,
   0.0,
   247.82387484882474,
   241.54336137644714,
   240.22808473828127,
   233.8678023778366,
   235.89427916329117],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   245.1799988301318,
   0.0,
   245.95973392534142,
   240.6375808343173,
   239.99405954860413,
   235.38274383981798,
   236.1436799783266],
  [936.906393858963,
   272.9466401116455,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   244.3624512422191,
   0.0,
   244.64001259794668,
   239.4793969609159,
   239.2726457013814,
   236.63463128490457,
   236.87202221613174],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   243.58618616951412,
   0.0,
   243.6155143981373,
   238.28198429987606,
   238.2714101138754,
   237.64025227671846,
   237.8755373453394],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   242.70058829260142,
   0.0,
   242.7241385317684,
   237.1812373836283,
   237.1338653884095,
   238.4590703384997,
   239.0224249077148],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   241.60410307508891,
   0.0,
   241.87132475713588,
   236.26576044890453,
   235.94443018435413,
   239.1876224313246,
   240.22645616380262],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   240.23811465258154,
   0.0,
   241.01630003738728,
   235.5832462012354,
   234.73268814242056,
   239.96520418203772,
   241.44471213491815],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   238.5903354059344,
   0.0,
   240.15355534174023,
   235.13489530285278,
   233.48247342246714,
   241.0026409952061,
   242.68977745797318],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   239.57944089455123,
   12.570095283695537,
   241.4915786814786,
   241.35689717938249,
   240.0312580121008,
   234.07629180357344,
   236.09312625455073],
  [936.4332783600396,
   274.04272948648554,
   236.1447822578973,
   235.94194917096615,
   235.17975505584627,
   240.0642350689236,
   9.763416556840639,
   241.02144290309798,
   240.4879709288125,
   239.83807792268726,
   235.51809699978912,
   236.30053868193724],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   241.16630414391147,
   6.16619156734032,
   241.50628125346566,
   239.38334595318747,
   239.17308284740238,
   236.71070741831045,
   236.97212692441548],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   242.50293212115184,
   2.106531188841018,
   242.53900320199136,
   238.24887905496007,
   238.2371882827747,
   237.66484708890448,
   237.9100059619104],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   241.67076945164763,
   2.1064346521538937,
   241.7014548701577,
   237.21451589792196,
   237.16824647966178,
   238.43428366380977,
   238.98772717310467],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   238.57404580543812,
   6.165645260490692,
   238.9054109572685,
   236.36353152900165,
   236.04559865245392,
   239.10971633291774,
   240.12424899060443],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   235.41823590398553,
   9.76345531278821,
   236.37840472169182,
   235.73852391110495,
   234.89407400721575,
   239.82412745639658,
   241.28181830237992],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   232.35881094371803,
   12.573454449061956,
   234.28710444453282,
   235.33510778700474,
   233.69262828206593,
   240.7806677360545,
   242.4786825880354],
  [938.0643732746073, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   232.9231142033202,
   23.674498495983244,
   235.74231741369113,
   240.81770532592782,
   239.4622880977813,
   234.6788662382587,
   236.66774885549825],
  [936.4332780210191,
   273.57365694793657,
   236.55859139660538,
   236.41055303424105,
   235.64489139897955,
   235.11792893243978,
   18.365312086416907,
   236.5264618112542,
   240.05623858782474,
   239.38804180717807,
   235.9087884220421,
   236.75321295337002],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   238.1381779340186,
   11.591755311418183,
   238.63650631321616,
   239.10648737639576,
   238.88613183451298,
   236.93006875186302,
   237.2607246976096],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   241.49144227121656,
   3.9590811399607446,
   241.5445413097823,
   238.15352651110925,
   238.13862308178886,
   237.73569798805056,
   238.0092938903048],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   240.81304740806468,
   3.958934404574393,
   240.8618465842328,
   237.3103071731016,
   237.26721493960122,
   238.36294695395918,
   238.88785909873647],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   236.02400007117853,
   11.591009760346424,
   236.51758970883975,
   236.6447453182659,
   236.33661507819534,
   238.88572152824872,
   239.8303276793652],
  [936.4332750298576,
   269.36269484321554,
   240.27344035461806,
   240.62656972661398,
   239.829295561251,
   231.32572569770173,
   18.366026281529685,
   232.74582388891758,
   236.1846065187642,
   235.3577931815562,
   239.41894446581773,
   240.8138630161272],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.52560475656333,
   239.9261427976728,
   227.0249154393582,
   23.681844738090604,
   229.87717349459172,
   235.90910813571782,
   234.29534366814505,
   240.14395354848102,
   241.8730475719058],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0643805775521, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.4702940954569,
   227.24774807106223,
   31.975574008392414,
   231.11096537557432,
   239.9849724772057,
   238.58411105082178,
   235.6085970458803,
   237.5541010068037],
  [936.4332775016093,
   272.8517986847595,
   237.19540442592688,
   237.13209370330242,
   236.3610748763747,
   231.010809939228,
   24.768539625624726,
   232.936997643812,
   239.39203839085667,
   238.69592348696415,
   236.51013835835374,
   237.44969625032095],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   235.6692564035759,
   15.622285525746975,
   236.34828783402054,
   238.68147416780312,
   238.4457125073609,
   237.2670437484153,
   237.70391610697294],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   240.67659747225252,
   5.334196659875488,
   240.7488982095506,
   238.00735200354256,
   237.9875334835765,
   237.84434295618894,
   238.1615257151282],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   240.23379030930505,
   5.334068790470155,
   240.30335174627453,
   237.45698058380503,
   237.41876310365342,
   238.25374954612244,
   238.73496755845977],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   234.28854589610592,
   15.621721437275028,
   234.9661809149511,
   237.07471080663845,
   236.78165716997592,
   238.54347782659397,
   239.38108272271216],
  [936.4332755492673,
   270.1033841306013,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   228.53192415191643,
   24.769824793565476,
   230.4724913326154,
   236.86512328974277,
   236.0654696396159,
   238.80111708334607,
   240.10000360619537],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   223.38881658611513,
   31.984252909924635,
   227.2885689470495,
   236.78141784020136,
   235.21189021323107,
   239.17540482333925,
   240.95142949318998],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   223.43623004521714,
   36.42261276200952,
   227.99491604354807,
   238.95236634467346,
   237.49607155464946,
   236.75999534741004,
   238.65133769950734],
  [936.433276864459,
   271.96098291889666,
   237.98126919595757,
   238.02319244782484,
   237.24552732565257,
   228.3316479765831,
   28.184852900239548,
   230.60108551313942,
   238.57268659184547,
   237.84253522990548,
   237.25243929721682,
   238.30896901879615],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   234.08882751231295,
   17.768481239913854,
   234.88630526932275,
   238.15871732654068,
   237.90415092267858,
   237.68189409585466,
   238.2492895104939],
  [937.1253739307541,
   271.22120400517963,
   238.0072055539565,
   237.989396791824,
   237.9592926155624,
   240.1600203724031,
   6.065907652091482,
   240.24446247631977,
   237.82790000087516,
   237.80206378551657,
   237.9777733785386,
   238.34845430563365],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051877,
   240.00623060550015,
   6.065857453505487,
   240.08973660388438,
   237.6367582202315,
   237.6045321074007,
   238.11995854657835,
   238.54760837054025],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   233.60912776941495,
   17.76828208238112,
   234.40650573547964,
   237.60069985532618,
   237.3262359051755,
   238.12518873904492,
   238.83175823683115],
  [936.4332761864177,
   271.00649026687665,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   227.46987448145933,
   28.185530361695328,
   229.74586202055661,
   237.69512385862527,
   236.92901179579985,
   238.04806226393112,
   239.22938985406023],
  [935.621642146249,
   271.4048152058127,
   239.53528663123097,
   239.39414406227706,
   237.82043034027447,
   222.09388690727792,
   36.4266166031116,
   226.66869304421925,
   237.839852542299,
   236.3249710745672,
   237.99867243844346,
   239.8311746556291],
  [935.6216421462492,
   271.4048152058125,
   239.5352866312312,
   239.39414406227706,
   237.82043034027424,
   222.09388690727747,
   36.42661660311205,
   226.66869304421925,
   237.83985254229947,
   236.32497107456766,
   237.99867243844346,
   239.83117465562904],
  [936.4332761864177,
   271.0064902668769,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   227.46987448145956,
   28.185530361694873,
   229.74586202055661,
   237.69512385862572,
   236.92901179579985,
   238.04806226393112,
   239.22938985406023],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   233.60912776941495,
   17.76828208238112,
   234.40650573547964,
   237.60069985532618,
   237.3262359051755,
   238.12518873904492,
   238.83175823683115],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051877,
   240.00623060550015,
   6.065857453505487,
   240.08973660388438,
   237.6367582202315,
   237.6045321074007,
   238.11995854657835,
   238.54760837054025],
  [937.1253739307541,
   271.22120400517963,
   238.0072055539565,
   237.989396791824,
   237.9592926155624,
   240.1600203724031,
   6.065907652091482,
   240.24446247631977,
   237.82790000087516,
   237.80206378551657,
   237.9777733785386,
   238.34845430563365],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   234.08882751231295,
   17.768481239913854,
   234.8863052693232,
   238.15871732654068,
   237.90415092267858,
   237.68189409585466,
   238.2492895104939],
  [936.4332768644591,
   271.96098291889655,
   237.9812691959578,
   238.02319244782484,
   237.24552732565257,
   228.33164797658287,
   28.184852900239548,
   230.60108551313942,
   238.57268659184547,
   237.84253522990548,
   237.25243929721682,
   238.30896901879615],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   223.43623004521714,
   36.42261276200952,
   227.99491604354807,
   238.95236634467346,
   237.49607155464946,
   236.75999534741004,
   238.65133769950734],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   223.38881658611513,
   31.984252909924635,
   227.28856894704904,
   236.7814178402009,
   235.21189021323107,
   239.17540482333925,
   240.95142949319],
  [936.4332755492674,
   270.10338413060117,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   228.53192415191643,
   24.769824793565476,
   230.4724913326154,
   236.86512328974277,
   236.0654696396159,
   238.80111708334607,
   240.10000360619537],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   234.28854589610592,
   15.621721437275028,
   234.9661809149511,
   237.07471080663845,
   236.78165716997592,
   238.54347782659397,
   239.38108272271216],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   240.23379030930505,
   5.334068790470155,
   240.30335174627453,
   237.45698058380503,
   237.41876310365342,
   238.25374954612244,
   238.73496755845977],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   240.67659747225252,
   5.334196659875488,
   240.7488982095506,
   238.00735200354256,
   237.9875334835765,
   237.84434295618894,
   238.1615257151282],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   235.6692564035759,
   15.622285525746975,
   236.34828783402054,
   238.68147416780312,
   238.4457125073609,
   237.2670437484153,
   237.70391610697294],
  [936.4332775016095,
   272.8517986847595,
   237.1954044259271,
   237.13209370330242,
   236.36107487637446,
   231.01080993922778,
   24.768539625624726,
   232.936997643812,
   239.39203839085667,
   238.69592348696415,
   236.51013835835374,
   237.44969625032095],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.47029409545667,
   227.247748071062,
   31.975574008392414,
   231.11096537557432,
   239.9849724772057,
   238.58411105082178,
   235.60859704587983,
   237.5541010068037],
  [938.0643805775524, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.5256047565631,
   239.9261427976728,
   227.02491543935844,
   23.68184473809015,
   229.87717349459172,
   235.90910813571782,
   234.29534366814505,
   240.14395354848102,
   241.87304757190577],
  [936.4332750298578,
   269.36269484321554,
   240.27344035461806,
   240.6265697266142,
   239.829295561251,
   231.32572569770173,
   18.366026281529685,
   232.74582388891758,
   236.1846065187642,
   235.3577931815562,
   239.41894446581773,
   240.81386301612716],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   236.02400007117853,
   11.591009760346424,
   236.51758970883975,
   236.6447453182659,
   236.33661507819534,
   238.88572152824872,
   239.83032767936515],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   240.81304740806468,
   3.958934404574393,
   240.8618465842328,
   237.3103071731016,
   237.26721493960122,
   238.36294695395918,
   238.88785909873647],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   241.49144227121656,
   3.9590811399607446,
   241.5445413097823,
   238.15352651110925,
   238.13862308178886,
   237.73569798805056,
   238.0092938903048],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   238.1381779340186,
   11.591755311417728,
   238.63650631321616,
   239.10648737639576,
   238.88613183451298,
   236.93006875186302,
   237.26072469760962],
  [936.4332780210193,
   273.57365694793657,
   236.55859139660538,
   236.41055303424082,
   235.64489139897955,
   235.11792893243978,
   18.365312086416907,
   236.5264618112542,
   240.05623858782474,
   239.38804180717807,
   235.9087884220421,
   236.75321295337002],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   232.9231142033202,
   23.674498495983244,
   235.74231741369113,
   240.81770532592827,
   239.4622880977813,
   234.6788662382587,
   236.6677488554982],
  [938.0643732746074, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   232.35881094371803,
   12.573454449061956,
   234.28710444453282,
   235.33510778700474,
   233.69262828206593,
   240.7806677360545,
   242.4786825880354],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   235.41823590398553,
   9.76345531278821,
   236.37840472169182,
   235.73852391110495,
   234.89407400721575,
   239.82412745639658,
   241.28181830237992],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   238.57404580543812,
   6.165645260490692,
   238.9054109572685,
   236.36353152900165,
   236.04559865245392,
   239.10971633291774,
   240.12424899060446],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   241.67076945164763,
   2.1064346521538937,
   241.7014548701577,
   237.21451589792196,
   237.16824647966178,
   238.43428366380977,
   238.98772717310467],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   242.50293212115184,
   2.106531188841018,
   242.53900320199136,
   238.24887905496007,
   238.2371882827747,
   237.66484708890448,
   237.9100059619104],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   241.16630414391147,
   6.16619156734032,
   241.50628125346566,
   239.38334595318747,
   239.17308284740238,
   236.71070741831045,
   236.97212692441548],
  [936.4332783600397,
   274.0427294864854,
   236.14478225789753,
   235.94194917096615,
   235.17975505584627,
   240.06423506892384,
   9.763416556840639,
   241.02144290309798,
   240.4879709288125,
   239.83807792268726,
   235.51809699978912,
   236.30053868193724],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   239.57944089455123,
   12.570095283695537,
   241.4915786814786,
   241.35689717938249,
   240.0312580121008,
   234.07629180357344,
   236.09312625455073],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   238.5903354059344,
   0.0,
   240.15355534174023,
   235.13489530285278,
   233.48247342246714,
   241.0026409952061,
   242.68977745797318],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   240.23811465258154,
   0.0,
   241.01630003738728,
   235.5832462012354,
   234.73268814242056,
   239.96520418203772,
   241.44471213491818],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   241.60410307508891,
   0.0,
   241.87132475713588,
   236.26576044890453,
   235.94443018435413,
   239.1876224313246,
   240.22645616380262],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   242.70058829260142,
   0.0,
   242.7241385317684,
   237.1812373836283,
   237.1338653884095,
   238.4590703384997,
   239.0224249077148],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   243.58618616951412,
   0.0,
   243.6155143981373,
   238.28198429987606,
   238.2714101138754,
   237.64025227671846,
   237.8755373453394],
  [936.9063938589629,
   272.9466401116456,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   244.3624512422191,
   0.0,
   244.64001259794668,
   239.4793969609159,
   239.2726457013814,
   236.63463128490457,
   236.87202221613174],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   245.1799988301318,
   0.0,
   245.95973392534142,
   240.6375808343173,
   239.99405954860413,
   235.38274383981798,
   236.1436799783266],
  [935.6216455277415,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   246.26768649331711,
   0.0,
   247.82387484882474,
   241.54336137644714,
   240.22808473828127,
   233.8678023778366,
   235.89427916329117]],
 [[935.6216455277413,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   235.88823782263762,
   0.0,
   237.45966274818556,
   243.07168291653943,
   241.25590613050917,
   233.3791431011482,
   234.8727964703897],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   234.87933581183233,
   0.0,
   235.6404963467594,
   241.87302325770543,
   240.94748551916746,
   235.0684536924573,
   235.2253643842697],
  [936.906393858963,
   272.9466401116455,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   234.11707811557858,
   0.0,
   234.3752333031798,
   240.48380947090754,
   240.13814469560748,
   236.46349891602586,
   236.0362026998687],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   233.38365809236325,
   0.0,
   233.40582580081445,
   239.09516181355139,
   239.04507961724403,
   237.58839666662107,
   237.11245137544418],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   232.53514267341507,
   0.0,
   232.56503935018145,
   237.82842390738597,
   237.815805406648,
   238.50574901684377,
   238.3308390901435],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   231.4741171334308,
   0.0,
   231.7546953071178,
   236.76293724289053,
   236.53561123234067,
   239.31180789943164,
   239.6127889605859],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   230.14410194511424,
   0.0,
   230.93175016845498,
   235.94138188446595,
   235.23184433834604,
   240.1420626308195,
   240.92284645669193],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   228.5328532350561,
   0.0,
   230.09085727780848,
   235.36367014656753,
   233.88082524302354,
   241.19881162988713,
   242.28189858238184],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   228.90747650972844,
   13.15740746820211,
   230.85081775221124,
   242.84612323986676,
   241.04061931013803,
   233.60805039296747,
   235.08925871776046],
  [936.4332783600396,
   274.04272948648554,
   236.1447822578973,
   235.94194917096615,
   235.17975505584627,
   229.57899161619025,
   10.137917680373448,
   230.5253161510891,
   241.69693791234977,
   240.77812253167167,
   235.21866649721096,
   235.39366348930756],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   230.81906594295515,
   6.3746344394739936,
   231.14277187167,
   240.37244328074712,
   240.0304342441127,
   236.54853786199556,
   236.14280570502964],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   232.26789773242444,
   2.1735453861278984,
   232.2974393505756,
   239.0570485059584,
   239.0081060961138,
   237.61597134934163,
   237.14905273229775],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   231.4704812676964,
   2.1736465385542942,
   231.50733167927365,
   237.86670482370846,
   237.8529667876478,
   238.4779999484308,
   238.29396183300184],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   228.33448787026987,
   6.375530440637704,
   228.68042129141986,
   236.87598233775634,
   236.64517609446057,
   239.225056725973,
   239.50367510345563],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   225.1260315457621,
   10.140038787270896,
   226.10187218811598,
   236.12308457577774,
   235.40724905859634,
   239.98623218526882,
   240.74744844283092],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   221.99017834898655,
   13.158803098869157,
   223.93084018530453,
   235.6031237446673,
   234.11049930143827,
   240.95595936193968,
   242.05131460664646],
  [938.0643732746073, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   221.99805297951275,
   24.780271811091097,
   224.8889212780491,
   242.19431788901966,
   240.41832041933503,
   234.26949760838852,
   235.71488037782424],
  [936.4332780210191,
   273.57365694793657,
   236.55859139660538,
   236.41055303424105,
   235.64489139897955,
   224.47641122922346,
   19.070122017440553,
   225.89391721579295,
   241.18897763610266,
   240.28944779145831,
   235.65212938119112,
   235.87944656684328],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   227.70627502497973,
   11.983857867960523,
   228.19663239916554,
   240.0514931265934,
   239.71998024954019,
   236.79368710968492,
   236.4501817933906],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   231.2298453319861,
   4.08506456389614,
   231.27815494375136,
   238.9472767950424,
   238.9016127605837,
   237.69539944899452,
   237.2544896281808],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   230.57970275762614,
   4.085220751967427,
   230.63406538962,
   237.9769009330289,
   237.9599357990387,
   238.39813029064135,
   238.18782633624014],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   225.6793041515641,
   11.985325792469666,
   226.1901720522742,
   237.2011834923851,
   236.96032546841752,
   238.9755721094307,
   239.18994156264455],
  [936.4332750298576,
   269.36269484321554,
   240.27344035461806,
   240.62656972661398,
   239.829295561251,
   220.84059188961191,
   19.074054603740024,
   222.2917430683865,
   236.6452675930459,
   235.91122099074573,
   239.5385458520973,
   240.2436920402105],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.52560475656333,
   239.9261427976728,
   216.3473728179183,
   24.784705335608123,
   219.25674170076127,
   236.29010750800762,
   234.7692250903956,
   240.2592049431355,
   241.3899407700527],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0643805775521, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.4702940954569,
   216.1469549786193,
   33.4683042571105,
   220.1276723844653,
   241.18893726072702,
   239.45792956666628,
   235.28966147317578,
   236.68019143601134],
  [936.4332775016093,
   272.8517986847595,
   237.19540442592688,
   237.13209370330242,
   236.3610748763747,
   220.26313027204856,
   25.71983374936326,
   222.22203515715546,
   240.4080058800073,
   239.5378180387993,
   236.31896362625776,
   236.62714631453093],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   225.1810047931092,
   16.15124770369721,
   225.86267274464763,
   239.5589472964407,
   239.24342855996338,
   237.1701148979605,
   236.92233868131555],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   230.3976790569459,
   5.504010069802007,
   230.46763390285423,
   238.77901365262005,
   238.73836227313404,
   237.81717680652218,
   237.41616528622157],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   229.97327628055632,
   5.504148632982833,
   230.04725235824208,
   238.14564668037883,
   238.12372720158828,
   238.2758508150996,
   238.02535626412214],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   223.85692029883512,
   16.152633848092137,
   224.5537529350736,
   237.69856314590606,
   237.44221627961497,
   238.59421457131566,
   238.71055567841748],
  [936.4332755492673,
   270.1033841306013,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   217.88577197470977,
   25.72397726017789,
   219.87379013313193,
   237.44241132353454,
   236.68024430456717,
   238.85553889415905,
   239.47555681727692],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   212.44954862897453,
   33.47451820838023,
   216.45790441677536,
   237.33548766356625,
   235.7710340882095,
   239.19889593792732,
   240.38398305614908],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   212.26804604988547,
   38.12187874512847,
   216.97314858856043,
   239.94438142843,
   238.26818713848888,
   236.55237770544954,
   237.87570674955293],
  [936.433276864459,
   271.96098291889666,
   237.98126919595757,
   238.02319244782484,
   237.24552732565257,
   217.54463721996262,
   29.26840075464179,
   219.86468461861705,
   239.4454444977414,
   238.61090699406486,
   237.14151371613661,
   237.55007880896787],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   223.5805405251872,
   18.37084273290202,
   224.39014043576753,
   238.95338235316376,
   238.65733923391463,
   237.63326645051575,
   237.50357135972328],
  [937.1253739307541,
   271.22120400517963,
   238.00720555395674,
   237.98939679182422,
   237.95929261556216,
   229.87523314824784,
   6.25911533055114,
   229.95995786732828,
   238.5724705842963,
   238.53795142156105,
   237.9667021491955,
   237.61471676167946],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051855,
   229.72782843685104,
   6.259170366313356,
   229.81396567674892,
   238.35250474490113,
   238.32449110839207,
   238.12599774010414,
   237.82628627487517],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   223.12045042663794,
   18.371414746108712,
   223.9357204947869,
   238.3072830078545,
   238.03179031667014,
   238.127845496399,
   238.1246048556388],
  [936.4332761864177,
   271.00649026687665,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   216.71801434917438,
   29.27021433794016,
   219.0498020922846,
   238.41552733437265,
   237.61850717788002,
   238.0224337320078,
   238.5392877556587],
  [935.621642146249,
   271.4048152058127,
   239.53528663123097,
   239.39414406227706,
   237.82043034027447,
   210.9817743144481,
   38.12493415995232,
   215.70004568947024,
   238.60614910206868,
   236.9878074240146,
   237.90997954005707,
   239.16194281035163],
  [935.6216421462492,
   271.4048152058125,
   239.5352866312312,
   239.39414406227706,
   237.82043034027424,
   210.9817743144481,
   38.12493415995232,
   215.70004568947024,
   238.60614910206868,
   236.9878074240146,
   237.90997954005707,
   239.16194281035166],
  [936.4332761864177,
   271.0064902668769,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   216.71801434917415,
   29.270214337939706,
   219.0498020922846,
   238.41552733437265,
   237.61850717788047,
   238.0224337320078,
   238.5392877556587],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   223.12045042663794,
   18.371414746108712,
   223.9357204947869,
   238.3072830078545,
   238.03179031667014,
   238.127845496399,
   238.1246048556388],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051855,
   229.72782843685104,
   6.259170366313356,
   229.81396567674892,
   238.35250474490113,
   238.32449110839207,
   238.12599774010414,
   237.82628627487517],
  [937.1253739307541,
   271.22120400517963,
   238.00720555395674,
   237.98939679182422,
   237.95929261556216,
   229.87523314824784,
   6.25911533055114,
   229.95995786732828,
   238.5724705842963,
   238.53795142156105,
   237.9667021491955,
   237.61471676167946],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   223.5805405251872,
   18.37084273290202,
   224.39014043576753,
   238.95338235316376,
   238.65733923391463,
   237.63326645051575,
   237.50357135972328],
  [936.4332768644591,
   271.96098291889655,
   237.9812691959578,
   238.02319244782484,
   237.24552732565257,
   217.5446372199624,
   29.26840075464179,
   219.86468461861705,
   239.4454444977414,
   238.61090699406486,
   237.14151371613616,
   237.55007880896787],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   212.26804604988547,
   38.12187874512847,
   216.97314858856043,
   239.94438142843046,
   238.26818713848888,
   236.55237770544954,
   237.87570674955296],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   212.44954862897453,
   33.47451820838023,
   216.45790441677536,
   237.33548766356625,
   235.7710340882095,
   239.19889593792732,
   240.38398305614908],
  [936.4332755492674,
   270.10338413060117,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   217.88577197470977,
   25.72397726017789,
   219.87379013313193,
   237.4424113235341,
   236.68024430456717,
   238.85553889415905,
   239.47555681727692],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   223.85692029883512,
   16.152633848092137,
   224.5537529350736,
   237.69856314590606,
   237.44221627961497,
   238.59421457131566,
   238.71055567841748],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   229.97327628055632,
   5.504148632982833,
   230.04725235824208,
   238.14564668037883,
   238.12372720158828,
   238.2758508150996,
   238.02535626412214],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   230.3976790569459,
   5.504010069802007,
   230.46763390285423,
   238.77901365262005,
   238.73836227313404,
   237.81717680652218,
   237.41616528622157],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   225.1810047931092,
   16.15124770369721,
   225.86267274464763,
   239.5589472964407,
   239.24342855996338,
   237.1701148979605,
   236.92233868131555],
  [936.4332775016095,
   272.8517986847595,
   237.1954044259271,
   237.13209370330242,
   236.36107487637446,
   220.26313027204878,
   25.71983374936326,
   222.22203515715591,
   240.4080058800073,
   239.5378180387993,
   236.31896362625776,
   236.6271463145309],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.47029409545667,
   216.14695497861908,
   33.46830425711096,
   220.12767238446486,
   241.18893726072702,
   239.45792956666628,
   235.28966147317578,
   236.68019143601137],
  [938.0643805775524, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.5256047565631,
   239.9261427976728,
   216.34737281791809,
   24.78470533560767,
   219.25674170076127,
   236.29010750800762,
   234.7692250903956,
   240.2592049431355,
   241.38994077005276],
  [936.4332750298578,
   269.36269484321554,
   240.27344035461806,
   240.6265697266142,
   239.829295561251,
   220.84059188961191,
   19.074054603740024,
   222.29174306838604,
   236.6452675930459,
   235.91122099074573,
   239.5385458520973,
   240.2436920402105],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   225.6793041515641,
   11.985325792469666,
   226.1901720522742,
   237.2011834923851,
   236.96032546841752,
   238.9755721094307,
   239.18994156264455],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   230.57970275762614,
   4.085220751967427,
   230.63406538962,
   237.9769009330289,
   237.9599357990387,
   238.39813029064135,
   238.18782633624014],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   231.2298453319861,
   4.08506456389614,
   231.27815494375136,
   238.9472767950424,
   238.9016127605837,
   237.69539944899452,
   237.2544896281808],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   227.70627502497973,
   11.983857867960523,
   228.19663239916554,
   240.0514931265934,
   239.71998024954019,
   236.79368710968492,
   236.4501817933906],
  [936.4332780210193,
   273.57365694793657,
   236.55859139660538,
   236.41055303424082,
   235.64489139897955,
   224.47641122922346,
   19.070122017440553,
   225.89391721579295,
   241.18897763610266,
   240.28944779145831,
   235.65212938119112,
   235.87944656684328],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   221.99805297951275,
   24.780271811091097,
   224.8889212780491,
   242.19431788901966,
   240.41832041933503,
   234.26949760838852,
   235.71488037782424],
  [938.0643732746074, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   221.99017834898655,
   13.158803098869157,
   223.93084018530453,
   235.6031237446673,
   234.11049930143827,
   240.95595936193968,
   242.05131460664646],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   225.1260315457621,
   10.140038787270896,
   226.10187218811598,
   236.12308457577774,
   235.40724905859588,
   239.98623218526882,
   240.74744844283092],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   228.33448787026987,
   6.375530440637704,
   228.68042129141986,
   236.87598233775634,
   236.64517609446057,
   239.225056725973,
   239.5036751034556],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   231.4704812676964,
   2.1736465385542942,
   231.50733167927365,
   237.86670482370846,
   237.8529667876478,
   238.4779999484308,
   238.29396183300184],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   232.26789773242444,
   2.1735453861278984,
   232.2974393505756,
   239.0570485059584,
   239.0081060961138,
   237.61597134934163,
   237.14905273229775],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   230.81906594295515,
   6.3746344394739936,
   231.14277187167,
   240.37244328074712,
   240.0304342441127,
   236.54853786199556,
   236.14280570502964],
  [936.4332783600397,
   274.0427294864854,
   236.14478225789753,
   235.94194917096615,
   235.17975505584627,
   229.57899161619002,
   10.137917680373448,
   230.5253161510891,
   241.69693791234977,
   240.77812253167167,
   235.21866649721096,
   235.39366348930756],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   228.90747650972844,
   13.15740746820211,
   230.85081775221124,
   242.84612323986676,
   241.04061931013803,
   233.60805039296747,
   235.08925871776046],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   228.5328532350561,
   0.0,
   230.09085727780848,
   235.36367014656753,
   233.88082524302354,
   241.19881162988713,
   242.28189858238184],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   230.14410194511424,
   0.0,
   230.93175016845498,
   235.94138188446595,
   235.2318443383465,
   240.1420626308195,
   240.92284645669196],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   231.4741171334308,
   0.0,
   231.7546953071178,
   236.76293724289053,
   236.53561123234067,
   239.31180789943164,
   239.6127889605859],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   232.53514267341507,
   0.0,
   232.56503935018145,
   237.82842390738597,
   237.815805406648,
   238.50574901684377,
   238.3308390901435],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   233.38365809236325,
   0.0,
   233.40582580081445,
   239.09516181355139,
   239.04507961724403,
   237.58839666662107,
   237.11245137544418],
  [936.9063938589629,
   272.9466401116456,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   234.11707811557858,
   0.0,
   234.3752333031798,
   240.48380947090754,
   240.13814469560748,
   236.46349891602586,
   236.0362026998687],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   234.87933581183233,
   0.0,
   235.6404963467594,
   241.87302325770543,
   240.94748551916746,
   235.0684536924573,
   235.2253643842697],
  [935.6216455277415,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   235.88823782263785,
   0.0,
   237.45966274818602,
   243.07168291653988,
   241.25590613050917,
   233.3791431011482,
   234.87279647038974]]]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / ((np.array([np.sum(i) for i in path_diffs[0]]) - np.array([np.sum(i) for i in path_diffs[1]])) / (4 * 5))
#+END_SRC

#+RESULTS:
:RESULTS:
: <ipython-input-40-83392a12912a>:1: RuntimeWarning:
: 
: divide by zero encountered in true_divide
: 
#+begin_example
array([1.01534904, 1.01710579, 1.01795713, 1.0183138 , 1.01831307,
       1.01792882, 1.01696925, 1.01498309, 1.01528333, 1.01707862,
       1.01794915, 1.01831305, 1.01831235, 1.01792217, 1.01694832,
       1.01493283,        inf, 1.01511113, 1.01700779, 1.01792854,
       1.01831113, 1.01831053, 1.01790575, 1.01689743, 1.01481176,
              inf,        inf, 1.0148978 , 1.01692102, 1.01790383,
       1.01830892, 1.0183085 , 1.01788837, 1.01684592, 1.0146923 ,
              inf, 1.01472347, 1.01685178, 1.01788512, 1.0183074 ,
       1.01830725, 1.01787962, 1.016825  , 1.01464981, 1.01464981,
       1.016825  , 1.01787962, 1.01830725, 1.0183074 , 1.01788512,
       1.01685178, 1.01472347,        inf, 1.0146923 , 1.01684592,
       1.01788837, 1.0183085 , 1.01830892, 1.01790383, 1.01692102,
       1.0148978 ,        inf,        inf, 1.01481176, 1.01689743,
       1.01790575, 1.01831053, 1.01831113, 1.01792854, 1.01700779,
       1.01511113,        inf, 1.01493283, 1.01694832, 1.01792217,
       1.01831235, 1.01831305, 1.01794915, 1.01707862, 1.01528333,
       1.01498309, 1.01696925, 1.01792882, 1.01831307, 1.0183138 ,
       1.01795713, 1.01710579, 1.01534904])
#+end_example
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
(((np.array([np.sum(i) for i in path_diffs[0]])) - (np.array([np.sum(i) for i in path_diffs[1]]))))
#+END_SRC

#+RESULTS:
#+begin_example
array([19.69765981, 19.66363794, 19.6471928 , 19.64031124, 19.6403254 ,
       19.64773928, 19.66627793, 19.70476181, 19.69893472, 19.66416318,
       19.64734676, 19.64032575, 19.64033931, 19.64786766, 19.66668283,
       19.70573758,  0.        , 19.70227627, 19.66553276, 19.64774465,
       19.64036272, 19.6403743 , 19.64818452, 19.66766701, 19.70808843,
        0.        ,  0.        , 19.70641768, 19.66721066, 19.64822162,
       19.64040545, 19.64041341, 19.64852002, 19.66866319, 19.71040881,
        0.        , 19.70980339, 19.66854992, 19.64858279, 19.64043471,
       19.64043756, 19.64868898, 19.66906786, 19.71123423, 19.71123423,
       19.66906786, 19.64868898, 19.64043756, 19.64043471, 19.64858279,
       19.66854992, 19.70980339,  0.        , 19.71040881, 19.66866319,
       19.64852002, 19.64041341, 19.64040545, 19.64822162, 19.66721066,
       19.70641768,  0.        ,  0.        , 19.70808843, 19.66766701,
       19.64818452, 19.6403743 , 19.64036272, 19.64774465, 19.66553276,
       19.70227627,  0.        , 19.70573758, 19.66668283, 19.64786766,
       19.64033931, 19.64032575, 19.64734676, 19.66416318, 19.69893472,
       19.70476181, 19.66627793, 19.64773928, 19.6403254 , 19.64031124,
       19.6471928 , 19.66363794, 19.69765981])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
(np.array([np.sum(i) for i in path_diffs[1]]))
#+END_SRC

#+RESULTS:
#+begin_example
array([3341.25588431, 3341.07237414, 3341.06442366, 3341.08866977,
       3341.08869232, 3341.06422006, 3341.07110059, 3341.25222366,
       3341.25523385, 3341.07211021, 3341.06434829, 3341.08866339,
       3341.08868445, 3341.06415334, 3341.07089419, 3341.25172922,
       3318.06437327, 3341.25352895, 3341.07142264, 3341.06415418,
       3341.08864744, 3341.08866435, 3341.06398777, 3341.07039155,
       3341.25053838, 3318.06441533, 3318.06438058, 3341.25141549,
       3341.07058223, 3341.06392362, 3341.08862998, 3341.08864082,
       3341.06380946, 3341.06987973, 3341.24936451, 3318.06440803,
       3341.24968615, 3341.06991536, 3341.0637536 , 3341.08862016,
       3341.08862388, 3341.06371269, 3341.0696647 , 3341.24895143,
       3341.24895143, 3341.0696647 , 3341.06371269, 3341.08862388,
       3341.08862016, 3341.0637536 , 3341.06991536, 3341.24968615,
       3318.06440803, 3341.24936451, 3341.06987973, 3341.06380946,
       3341.08864082, 3341.08862998, 3341.06392362, 3341.07058223,
       3341.25141549, 3318.06438058, 3318.06441533, 3341.25053838,
       3341.07039155, 3341.06398777, 3341.08866435, 3341.08864744,
       3341.06415418, 3341.07142264, 3341.25352895, 3318.06437327,
       3341.25172922, 3341.07089419, 3341.06415334, 3341.08868445,
       3341.08866339, 3341.06434829, 3341.07211021, 3341.25523385,
       3341.25222366, 3341.07110059, 3341.06422006, 3341.08869232,
       3341.08866977, 3341.06442366, 3341.07237414, 3341.25588431])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
mm_to_in = 1 / 25.4
shift = [4, 4, -10]
start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=20,
                                                      theta_bound=1.5, plot=True, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_ = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [1, 1, 2, 4, 2, 4, 1]
: initial number of rays = 7
: total number of rays making past the first ellipse = 4
: total number of rays making it all the way through = 0
: final ray counts = [1, 1, 2, 4, 2, 4, 1]
: initial number of rays = 7
: total number of rays making past the first ellipse = 4
: total number of rays making it all the way through = 0

#+BEGIN_SRC jupyter-python :session py :kernel python3
def transform_rays_end_tilt_path_diffs(rays, config, plot=False, plot_mirror_position=35, fig=None, 
                                       ray_alpha=None, debug=True):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE#[-231.24377979, -266.21940725, 0.]
    angle = .190161
    for ray in rays:
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        #ray[2] = np.add(ray[2], source_point_origin)
        ray[3] = new_vec
        #ray[4] = 0
        
    possible_paths = [path for path in get_possible_paths()]
        
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    if (plot):
        all_points, all_vectors, all_distances= [], [], []
    path_diffs = []
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238, debug=debug)
        path_diffs.append(total_distances)
        
        if (plot):
            all_points.append(total_ray_points)
            all_vectors.append(total_vectors)
            all_distances.append(total_distances)
    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig, 
                       ray_alpha=ray_alpha)
    return rays, path_diffs

def calculate_position_snr(shift_position):
    start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
    new_start = np.add(start_position, shift_position)

    # fig = go.Figure()

    out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=30,
                                                          theta_bound=.3, plot=False, y_ap=-.426, alpha=.15)
    # fig.show()
    start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

    rays, path_diffs = transform_rays_end_tilt_path_diffs(
        start_rays_mcmahon, config, plot=False, plot_mirror_position=0, fig=fig, ray_alpha=.05, 
        debug=False)
    snr_1 = np.sum([238 not in path_diffs[0][i] for i in range(len(path_diffs[0]))])
    snr_2 = np.sum([238 not in path_diffs[1][i] for i in range(len(path_diffs[1]))])
    return np.mean([snr_1, snr_2])

shift_snr_data = []
for x_shift in np.linspace(-4, 4, 20):
    print(x_shift)
    for y_shift in np.linspace(-4, 4, 20):
        for z_shift in np.linspace(-10, 10, 11):
            snr = calculate_position_snr([x_shift, y_shift, z_shift])
            shift_snr_data.append([x_shift, y_shift, z_shift, snr])
    
#fig.show()
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_src jupyter-python :session py :kernel python3
import matplotlib
shift_snr_data = np.array(shift_snr_data)
for z in np.linspace(-10, 10, 11):
    shift_z_data = shift_snr_data[np.where(shift_snr_data[:, 2] == z)]
    plt.scatter(shift_z_data[:, 0], shift_z_data[:, 1], c=shift_z_data[:, 3], 
                norm=matplotlib.colors.LogNorm())
    plt.title('z shift = %s' %z)
    plt.colorbar(label='# of rays making it through the FTS')
    plt.show()
#+end_src
: -4.0
# [goto error]
#+begin_example

KeyboardInterruptTraceback (most recent call last)
<ipython-input-369-e705e8679ed3> in <module>
     57     for y_shift in np.linspace(-4, 4, 20):
     58         for z_shift in np.linspace(-10, 10, 11):
---> 59             snr = calculate_position_snr([x_shift, y_shift, z_shift])
     60             shift_snr_data.append([x_shift, y_shift, z_shift, snr])
     61 

<ipython-input-369-e705e8679ed3> in calculate_position_snr(shift_position)
     40     # fig = go.Figure()
     41 
---> 42     out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=30,
     43                                                           theta_bound=.3, plot=False, y_ap=-.426, alpha=.15)
     44     # fig.show()

~/FTS_simulation_results/coupling_optics_sims.py in run_rays_through_coupling_optics_reversed(P_rx, tele_geo, col, fig, starting_rays, n_linear, alpha, theta_bound, plot, y_ap)
    562 
    563         try:
--> 564             t_21 = optimize.brentq(root_21, .01, 30)
    565         except ValueError:
    566             # print(ii)

~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/zeros.py in brentq(f, a, b, args, xtol, rtol, maxiter, full_output, disp)
    774     if rtol < _rtol:
    775         raise ValueError("rtol too small (%g < %g)" % (rtol, _rtol))
--> 776     r = _zeros._brentq(f, a, b, xtol, rtol, maxiter, args, full_output, disp)
    777     return results_c(full_output, r)
    778 

~/FTS_simulation_results/coupling_optics_sims.py in root_21(t)
    552             z = P_22[2] + gamma * t
    553 
--> 554             x21, y21, z21 = ref_tele_to_21(
    555                 x, y, z, 1
    556             )  # take ray end coordinates and convert to M1 coordinates

~/FTS_simulation_results/fts_coupling_optics_geo.py in ref_tele_to_21(x, y, z, shift)
    140     x_temp = x
    141     y_temp = y * np.cos(np.pi/2) - z * np.sin(np.pi/2)
--> 142     z_temp = y * np.sin(np.pi/2) + z * np.cos(np.pi/2)
    143     return x_temp, y_temp, z_temp
    144 

KeyboardInterrupt: 
#+end_example
:END:
#+RESULTS:
:RESULTS:

[[file:./.ob-jupyter/8a698384fd6e66d650e178cc9e3707b1fdcf35ac.png]]
[[file:./.ob-jupyter/7cb1ebeaf883d8152546495438fa28807d9be55a.png]]
[[file:./.ob-jupyter/024b1edcb288a6eb3abf00206d3a361564a7b295.png]]
[[file:./.ob-jupyter/e7e6dc6ad01e824230c1dad99909a79c231072ba.png]]
[[file:./.ob-jupyter/3737b10df4fa1a863bdf69858d7d69b6b656347c.png]]
[[file:./.ob-jupyter/9a7bd99b6c7df2622b674005ad352cf505fb2c95.png]]
[[file:./.ob-jupyter/690c7294131b273499c537f18b768cc12d05be3e.png]]
[[file:./.ob-jupyter/fa3ce8376f38f7024d8e710866c1040d17ad22fa.png]]
[[file:./.ob-jupyter/eb7b4ddf72f6e201f4dd0cd0f11c8c60e37fa27d.png]]
[[file:./.ob-jupyter/c3e288b595bcbca707d552c52054e4ccf307e762.png]]

:END:

Try running rays in the forwards direction and stopping them at z = -30.9 and
see what they look like. Then run these in reverse and see if we return to sender.

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 50, config, 
                                   theta_bound=0.2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=True,
                                                  fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards[3]
#+END_SRC

#+RESULTS:
#+begin_example
array([3350.88621513, 3351.05446006, 3350.97362151, 3351.26634068,
       3351.01161703, 3350.88605922, 3350.88067284, 3350.98284309,
       3350.89894517, 3350.94162246, 3350.88975193, 3351.09993202,
       3351.0131515 , 3350.8903652 , 3350.90237406, 3350.91138386,
       3351.03113842, 3351.08187428, 3351.13863101, 3350.88379026,
       3350.88893254, 3351.19624332, 3350.8806478 , 3351.01894469,
       3350.88626997, 3350.91033656, 3350.98422149, 3350.88005533,
       3350.92666505, 3350.90910216, 3351.00164824, 3350.91071593,
       3350.89520041, 3350.91831428, 3350.89784605, 3351.17099418,
       3351.02858975, 3351.07293268, 3350.91035547, 3350.92404692,
       3350.88015675, 3350.88018248, 3350.92549659, 3350.88876375,
       3350.89741497, 3350.88918037, 3351.01984984, 3350.94714306,
       3351.09384886, 3351.19703479])
#+end_example


#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays_reversed = []
for ray_out in out_forwards.T:
    assert ray_out[2] == csims.FOCUS[2]
    starting_rays_reversed.append([.123, 1, ray_out[[0, 1, 2]].flatten(), -1 * ray_out[[8, 9, 10]].flatten(), 0])
    
#+END_SRC

#+RESULTS:

We should really check and make sure that the distances match up too!

#+BEGIN_SRC jupyter-python :session py :kernel python3
fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=True, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_ = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 50
: total number of rays making past the first ellipse = 50
: total number of rays making it all the way through = 50
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 50
: total number of rays making past the first ellipse = 50
: total number of rays making it all the way through = 50


Ok, great. Now we just need to check that the distances are the same and also
check starting vectors out in a cone around some of the far points at x=-10 to
see why none of them are hitting. Then we'll pretty much be good to go here.

* Check that distances are the same

- ray by ray comparison here I guess.

#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .2, 0])
out = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                      theta_bound=.2, plot=False, alpha=.2)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=csims.FOCUS[2], plot=False,
                                                   fig=fig, color='red')
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
out[3]
#+END_SRC

#+RESULTS:
: array([36.76161766])

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_backwards[3] * csims.mm_to_in
#+END_SRC

#+RESULTS:
: array([36.76161766])

** Check that the distances are the same when inputting many rays

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 2, 
                                  config['detector']['normal_vec'], 100, config, 
                                  theta_bound=0.4)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)
transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)
out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=False,
                                                  fig=fig, color='red')

starting_rays_reversed = []
for ray_out in out_forwards.T:
    assert ray_out[2] == csims.FOCUS[2]
    starting_rays_reversed.append([.123, 1, ray_out[[0, 1, 2]].flatten(), -1 * ray_out[[8, 9, 10]].flatten(), 0])

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=False, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]
transformed_start_rays = transform_rays_to_fts_frame(start_rays_mcmahon)

possible_paths = get_possible_paths()
# only do the 1st of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    transformed_start_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean(out_forwards[3]), np.std(out_forwards[3])
#+END_SRC

#+RESULTS:
: (3451.1463706505997, 0.2148808840259485)

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(remove_outliers(out_forwards)[3])
#+END_SRC

#+RESULTS:
: 0.3142997636046779

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.hist(remove_outliers(out_forwards)[3])
#+END_SRC

#+RESULTS:
:RESULTS:
: (array([ 9.,  5., 13., 14., 10., 13., 10.,  5.,  5.,  2.]),
:  array([3450.97898779, 3451.33707396, 3451.69516013, 3452.0532463 ,
:         3452.41133247, 3452.76941864, 3453.12750481, 3453.48559098,
:         3453.84367715, 3454.20176332, 3454.55984949]),
:  <BarContainer object of 10 artists>)
[[file:./.ob-jupyter/d08f9d3e825d5d8f074a01e5e223f199f5ddbe41.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean([ray[4] for ray in final_rays]), np.std([ray[4] for ray in final_rays])
#+END_SRC

#+RESULTS:
: (3451.4954203750067, 0.27196604868351704)

Alright I'll call this one close enough, 3 decimal places is our original precision


It really should be perfect here.

** Check points, vectors distances

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st of these paths
possible_paths = [possible_paths[1]]

all_points_forwards, all_vectors_forwards, all_distances_forwards = [], [], []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238)

    all_points_forwards.append(total_ray_points)
    all_vectors_forwards.append(total_vectors)
    all_distances_forwards.append(total_distances)
#+END_SRC

#+RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=False, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]
transformed_start_rays = transform_rays_to_fts_frame(start_rays_mcmahon)

all_points_backwards, all_vectors_backwards, all_distances_backwards = [], [], []

possible_paths = get_possible_paths()
# only do the 1st of these paths
possible_paths = [possible_paths[1]]

for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        transformed_start_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238)

    all_points_backwards.append(total_ray_points)
    all_vectors_backwards.append(total_vectors)
    all_distances_backwards.append(total_distances)
#+END_SRC

#+RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1


#+BEGIN_SRC jupyter-python :session py :kernel python3
all_points_forwards
#+END_SRC

#+RESULTS:
#+begin_example
[[[[225.0, 233.782, 0.0],
   (186.31835975360082, 0, 7.690811949339315),
   [147.7062496221141, -233.36177766141975, 15.367799690728779],
   (96.39931162244588, 0, 7.690811949339319),
   [45.00020336787598, -233.7809999999562, 3.2897367154838264e-05],
   [-4.762063146681292, -7.445831180479388, -7.44583118047941],
   [-8.147531761173607, -7.952394504638895, 7.952394504638895],
   [-57.70625410879198, -233.36177745033817, 15.367802529997935],
   (-96.31856069872687, 0, 7.690845911661434),
   [-135.00023233117759, -233.78099999993404, 9.803169743261009e-05],
   (-173.68167433371553, 0, -7.69074676639979)]]]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_points_backwards[0][0][-1] + np.multiply(all_distances_backwards[0][0][-1], all_vectors_backwards[0][0][-1])
#+END_SRC

#+RESULTS:
: array([ 2.24999992e+02,  2.33782002e+02, -1.29758747e-05])

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_distances_forwards
#+END_SRC

#+RESULTS:
#+begin_example
[[[0,
   237.08530406710565,
   236.65914405085937,
   239.05869007626802,
   239.48814662268933,
   231.86058894316784,
   15.774135741489317,
   230.91220226932955,
   236.65917488636728,
   237.0843210425419,
   237.08428672114314,
   263.34972794871527]]]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_distances_backwards[0][0][::-1]
#+END_SRC

#+RESULTS:
#+begin_example
[237.0853056368177,
 236.65914471013411,
 239.05868847842066,
 239.48814435786971,
 231.8606018344558,
 15.774109185362704,
 230.91221667607442,
 236.65917643607918,
 237.0843219512867,
 237.08428672113632,
 272.53752532949954,
 936.6772800352911]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.sum(all_distances_backwards)
#+END_SRC

#+RESULTS:
: 3350.880801352428

* Check the points in a cone around some of the far points at x=-10


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 50, config, 
                                   theta_bound=0.2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2] - 10, plot=True,
                                                  fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards[3]
#+END_SRC

#+RESULTS:
#+begin_example
array([3607.70106121, 3605.40667966, 3610.20924308, 3605.55331105,
       3610.85753749, 3608.80492269, 3606.79800455, 3609.81658383,
       3610.8069358 , 3610.27988296, 3606.4719263 , 3605.57094641,
       3606.26587301, 3608.44131357, 3605.10981244, 3605.81735729,
       3606.86279446, 3609.78232773, 3606.73713764, 3604.99772641,
       3610.68994737, 3605.23932515, 3610.67446586, 3606.72985448,
       3610.42365132, 3604.94092979, 3607.75317465, 3608.26690982,
       3605.84355965, 3610.94357686, 3606.15730598, 3607.82747988,
       3606.7419801 , 3609.87705443, 3608.18029018, 3606.3446854 ,
       3608.87239889, 3607.21420318, 3607.4170345 , 3608.94452071,
       3611.07264068, 3610.25101006, 3607.71346774, 3608.26854137,
       3610.40232955, 3607.3611857 , 3607.7159255 , 3608.87397072,
       3607.75282742, 3606.91795736])
#+end_example

# Now take just one of these rays and roll with it

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_out[[0, 1, 2]].flatten()
#+END_SRC

#+RESULTS:
: array([ -0.93046588,  14.47165823, -30.9       ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_out[[0, 1, 2]].flatten() - csims.FOCUS
#+END_SRC

#+RESULTS:
: array([ -0.93046588,   1.12759487, -10.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays_reversed = []
for ray_out in out_forwards.T[0:1]:
    assert ray_out[2] == csims.FOCUS[2] - 10
    starting_rays_reversed.append([.123, 1, ray_out[[0, 1, 2]].flatten(), -1 * ray_out[[8, 9, 10]].flatten(), 0])
    

other_rays = create_source_rays(starting_rays_reversed[0][2], .5, 
                                [0.00001, 0.00001, -.99999], 50, None, theta_bound=.15, check_rays=False)
starting_rays_reversed.extend(other_rays)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=True, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_ = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 2, 2, 12, 2, 2, 12, 2, 12, 1, 2, 12, 12, 2, 12]
: initial number of rays = 15
: total number of rays making past the first ellipse = 14
: total number of rays making it all the way through = 7
: final ray counts = [12, 2, 2, 12, 2, 2, 12, 2, 12, 1, 2, 12, 12, 2, 12]
: initial number of rays = 15
: total number of rays making past the first ellipse = 14
: total number of rays making it all the way through = 7

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays_reversed[0:4]
#+END_SRC

#+RESULTS:
#+begin_example
[[0.123,
  1,
  array([ -0.93046588,  14.47165823, -30.9       ]),
  array([ 0.09342564, -0.11321891,  0.9891679 ]),
  0],
 [0.123,
  1.0,
  [-0.9008078187458298, 14.482708625968241, -30.899999592911417],
  [-0.03020276451124469, 0.13200934464911512, 0.9907782745725334],
  0],
 [0.123,
  1.0,
  [-0.92565216004613, 14.053251811615457, -30.900004135968402],
  [0.06389958659010128, -0.002209642171074717, 0.9979438883618337],
  0],
 [0.123,
  1.0,
  [-1.224937592781247, 14.379036263563627, -30.90000387097556],
  [-0.031661294387972154, 0.10063166135512415, 0.9944098785119858],
  0]]
#+end_example

* Try a gigantic forwards raytrace and see how the path lengths look now.. 
** maybe try plotting too
Then I think we will possibly be ready for action over here.

- later tonight should maybe re-do the previous focus computation thing but with more rays
- instead of doing it backwards we can do it forwards and see how many rays go
  to each position- just have to run the rays once now!

#+BEGIN_SRC jupyter-python :session py :kernel python3

#with open("lab_fts_dims_mcmahon.yml", "r") as stream:
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 50, 
                                   config['detector']['normal_vec'], 50000, config, 
                                   theta_bound=0.4, timeout=2000)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
# for now do the 1st to reduce plotting
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=True)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

#plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2] - 10, 
                                         plot=False, fig=fig, color='red')
#fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
initial number of rays = 50000
total number of rays making past the first ellipse = 50000
total number of rays making it all the way through = 37527
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
#+end_example

It'd be cool to make some density plots of the rays actually lie here.... think
I'll be done for now though
- should redo this but with a systematic creation of spread rays instead of random
  
should also make sure that when we intersect with the -233 plane that the x
coordinate is left of 225
- trust the dims otherwise


#+BEGIN_SRC jupyter-python :session py :kernel python3
def remove_outliers(points, threshold=10, debug=False):
    new_points = []
    mean_x = csims.FOCUS[0]
    mean_y = csims.FOCUS[1]
    if (debug):
        print(f'focus is at {np.array(csims.FOCUS)[[0, 1]]}')
    for point in points:
        if np.abs(point[0] - mean_x) > threshold or np.abs(
                point[1] - mean_y) > threshold:
            if (debug):
                print(f'Taking away outlier point {point}')
            continue
        new_points.append(point)
    return np.array(new_points).T

def remove_outliers(out, threshold=5, debug=False):
    new_out = []
    mean_x = csims.FOCUS[0]
    mean_y = csims.FOCUS[1]
    if (debug):
        print(f'focus is at {np.array(csims.FOCUS)[[0, 1]]}')
        
    for i in range(out.shape[1]):
        point = out[[0, 1, 2], i]
        if np.abs(point[0] - mean_x) > threshold or np.abs(
                point[1] - mean_y) > threshold:
            if (debug):
                print(f'Taking away outlier point {point}')
            continue
        new_out.append(out[:, i])
    return np.array(new_out).T
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
points = remove_outliers(out[[0, 1, 2]].T)
points.shape
#points = out[[0, 1, 2]]
plt.figure(figsize=(3, 3))
import seaborn as sns
sns.set()
sns.kdeplot(x=points[0], y=points[1], fill=True, cmap='viridis', levels=100, thresh=0)
plt.axis('equal')
plt.scatter(csims.FOCUS[0], csims.FOCUS[1], s=1, color='black')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/f575696fb36c9e9111bd98c8bf27b408fadb535a.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
# just subtract our z coordinate until we hit -20.9
def get_rays_at_z(out, z_coordinate):
   iters = (out[2] - z_coordinate) / out[10]
   points = out[[0, 1, 2]]
   vectors = out[[8, 9, 10]]
   new_points = out[[0, 1, 2]] - out[[8, 9, 10]] * iters
   
   new_out = out.copy()
   new_out[[0, 1, 2]] = new_points
   new_out[3] = get_distances_at_z(out, z_coordinate)
   return new_out
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.linspace(-10.9, -30.9, 5):
    points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], shade=True, cbar=True, cmap='viridis', thresh=0.01, 
                levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    plt.xlim(-4, 4)
    plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
   
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/8ca8b1a071499a572147a51a90d36037c5173577.png]]
[[file:./.ob-jupyter/9bdd9878693406dec32ffe8e3d62649208b047cf.png]]
[[file:./.ob-jupyter/795c08c2869f507a30270ad483c28699d4b5b72e.png]]
[[file:./.ob-jupyter/eb8bb16d14afc823b137340892b3946afe0acd53.png]]
[[file:./.ob-jupyter/51b7d5b2be325b2fdcdfe367b7e7c2d812c63dc1.png]]
:END:


#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(2, 2))
points = remove_outliers(get_rays_at_z(out, z), threshold=4)
sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1])
#+END_SRC

#+RESULTS:
:RESULTS:
: <AxesSubplot:>
[[file:./.ob-jupyter/0e1221bbdb34d79e58e051d7c6b291c207e7cfd3.png]]
:END:

* Uniform Rays

#+BEGIN_SRC jupyter-python :session py :kernel python3

#with open("lab_fts_dims_mcmahon.yml", "r") as stream:
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays_uniform(
    config['detector']['center'], 50, config['detector']['normal_vec'], 
    30, 30, 20, config, theta_bound=0.4, timeout=600, check_rays=True)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
# for now do the 1st to reduce plotting
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=True)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

#plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2] - 10, 
                                         plot=False, fig=fig, color='red')
#fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
initial number of rays = 21131
total number of rays making past the first ellipse = 21131
total number of rays making it all the way through = 16636
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.linspace(-10.9, -30.9, 11):
    points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    plt.xlim(-4, 4)
    plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/36da2b3ae151df19d6c521f15f8ec39a6b2448ce.png]]
[[file:./.ob-jupyter/9f192834b65a7941bab8afcc8de4677f52f6c54d.png]]
[[file:./.ob-jupyter/d9bd58fd21faf4f710e33dae48fde3ca07bc0762.png]]
[[file:./.ob-jupyter/257cb2264ce64481ac423cfb2b34f02ea6ba4f19.png]]
[[file:./.ob-jupyter/90e71b6b77526887081ee893988205985c790f25.png]]
[[file:./.ob-jupyter/7c8ac0f8d0bf5007d9cbad1999c9e1c0317a5457.png]]
[[file:./.ob-jupyter/e8f52a3b77be9611c30113a06ae4ce8178c5d317.png]]
[[file:./.ob-jupyter/ea3cde2061d471ee433642733f37872aa1737a9a.png]]
[[file:./.ob-jupyter/8d8cf111de55492804990655bea91200cf9e47f1.png]]
[[file:./.ob-jupyter/6338c861a7c0edb004f3c32e757ed7d24358f422.png]]
[[file:./.ob-jupyter/eccdb195b57aa17d57560517ac3e1376ef7dd0ed.png]]
:END:

I guess we just have to run things now...

Can do the standard deviation of rays vs z position graph here too I guess.

#+BEGIN_SRC jupyter-python :session py :kernel python3
# just subtract our z coordinate until we hit -20.9
def get_distances_at_z(out, z_coordinate):
   iters = (out[2] - z_coordinate) / out[10]
   return out[3] - iters / csims.mm_to_in
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
get_distances_at_z(out, -20.9)
#+END_SRC

#+RESULTS:
: array([3454.75532249, 3454.38312125, 3454.30880079, ..., 3454.14774156,
:        3454.38729444, 3454.47851741])

:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(remove_outliers(out)[3])
#+END_SRC

#+RESULTS:
: 2.443162030395897

#+BEGIN_SRC jupyter-python :session py :kernel python3
[np.std(get_distances_at_z(remove_outliers(out), d)) for d in np.linspace(-10.9, -30.9, 11)]
#+END_SRC

#+RESULTS:
#+begin_example
[2.1729681770305826,
 1.7841711683673258,
 1.4192792866449444,
 1.1022937470502547,
 0.8862055020667199,
 0.8516335801394439,
 1.0172562084202066,
 1.3091797081143297,
 1.6621382910358982,
 2.04476569922759,
 2.443162030395897]
#+end_example

Maybe see why this std is so high here...

try on a smaller number of rays?

and try the older amount and see if that keeps it the same..

try picking a spot and get all the rays within distance .05 of that spot.

if we illuminate ~10 detectors

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_rays_within_spot(out, spot, radius=.05):
    out_z = get_rays_at_z(out, spot[2])
    assert out_z[2][0] == spot[2]
    points = out_z[[0, 1, 2]]
    assert points[2][0] == spot[2]
    x_vals = points[0]
    y_vals = points[1]
    distances = np.sqrt((x_vals - spot[0]) ** 2 + (y_vals - spot[1]) ** 2)
    return out_z[:, np.where(distances <= radius)]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out[:, [0, 1, 2, 3]][:, 3]
#+END_SRC

#+RESULTS:
: array([ 1.96425464e-02, -4.26000000e-01,  3.76671069e-01,  3.68920647e+01,
:         0.00000000e+00,  2.31293364e-03, -9.99014969e-01,  4.43141337e-02,
:        -3.01481671e-03, -9.99835582e-01, -1.78807112e-02])

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_cleaned = remove_outliers(out)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
smaller_points = get_rays_within_spot(out_cleaned, [csims.FOCUS[0], csims.FOCUS[1], -30.9], radius=.1)
smaller_points.shape
#+END_SRC

#+RESULTS:
: (11, 1, 24)

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(smaller_points[3])
#+END_SRC

#+RESULTS:
: 0.9236131644054153
#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
remove_outliers(out).shape
#+END_SRC

#+RESULTS:
: (11, 14950)

#+BEGIN_SRC jupyter-python :session py :kernel python3
ps.T[0]
#+END_SRC

#+RESULTS:
: array([-0.36993651, -0.36391476, -0.36320876, ...,  0.35932308,
:         0.38789004,  0.32628853])

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_cleaned.shape
#+END_SRC

#+RESULTS:
: (11, 14950)

#+BEGIN_SRC jupyter-python :session py :kernel python3
spot_rays = get_rays_within_spot(out_cleaned, [csims.FOCUS[0], csims.FOCUS[1], -20.9], 
                                 radius=1)
print(spot_rays.shape)
print(np.std(spot_rays[3]))
ps = spot_rays[[0, 1, 2]]
plt.scatter(ps[0], ps[1] - csims.FOCUS[1], c=spot_rays[3], s=10)
plt.colorbar()
#+END_SRC

#+RESULTS:
:RESULTS:
: (11, 1, 14950)
: 0.8516335801394439
: <matplotlib.colorbar.Colorbar at 0x7f9ca2e47670>
[[file:./.ob-jupyter/c55a384f5bdbc149f2add93455b6b58753810a00.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
ps[0][0]
#+END_SRC

#+RESULTS:
: array([-0.36993651, -0.36391476, -0.36320876, ...,  0.35932308,
:         0.38789004,  0.32628853])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(spot_rays[3])
#+END_SRC

#+RESULTS:
: 0.17610861024831181

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(get_rays_at_z(out_cleaned, -20.9)[3])
#+END_SRC

#+RESULTS:
: 0.8516335801394439

#+BEGIN_SRC jupyter-python :session py :kernel python3
ps = get_rays_at_z(out_cleaned, -20.9)[[0, 1, 2]]
plt.scatter(ps[0], ps[1])
#+END_SRC

#+RESULTS:
:RESULTS:
: <matplotlib.collections.PathCollection at 0x7f9cb39e5ac0>
[[file:./.ob-jupyter/dc9be1e7c414a47e1e555e0eddaf6abc1388f6e2.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in [-20.9]:
    points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    # plt.xlim(-4, 4)
    # plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/84d8077851f1194541664cb808e28cd72081bf50.png]]

* Test the Reverse Raytracing one more time
#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, -.4]
start = np.add(csims.FOCUS, shift)

# fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(start, fts_geo, 'black', fig, n_linear=20,
                                                      theta_bound=.25, plot=False, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

rays, path_diffs = transform_rays_end_tilt_path_diffs(
    start_rays_mcmahon, config, plot=False, plot_mirror_position=5, fig=fig, ray_alpha=.05)
# fig.show()
#+END_SRC

#+RESULTS:
: initial number of rays = 356
: total number of rays making past the first ellipse = 356
: total number of rays making it all the way through = 308
: initial number of rays = 356
: total number of rays making past the first ellipse = 356
: total number of rays making it all the way through = 294

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / ((np.array([np.sum(i) for i in path_diffs[0]]) - np.array([np.sum(i) for i in path_diffs[1]])) / (4 * 5))
#+END_SRC

#+RESULTS:
:RESULTS:
: <ipython-input-1052-83392a12912a>:1: RuntimeWarning:
: 
: divide by zero encountered in true_divide
: 
#+begin_example
array([ 5.66509620e-02,  1.01560683e+00,  1.01657502e+00,  1.01725315e+00,
        1.01772565e+00,  1.01804594e+00,  1.01824636e+00,  1.01834402e+00,
        1.01834394e+00,  1.01824047e+00,  1.01801721e+00,  1.01764578e+00,
        1.01708339e+00,  1.01626877e+00,  1.01511598e+00, -6.19230957e-02,
                   inf,  5.66407046e-02,  1.01558650e+00,  1.01656128e+00,
        1.01724447e+00,  1.01772070e+00,  1.01804355e+00,  1.01824554e+00,
        1.01834393e+00,  1.01834385e+00,  1.01823972e+00,  1.01801513e+00,
        1.01764168e+00,  1.01707650e+00,  1.01625815e+00,  1.01510048e+00,
       -6.19349752e-02,             inf,             inf,  5.66102141e-02,
        1.01552731e+00,  1.01652128e+00,  1.01721926e+00,  1.01770633e+00,
        1.01803662e+00,  1.01824317e+00,  1.01834368e+00,  1.01834361e+00,
        1.01823753e+00,  1.01800913e+00,  1.01762989e+00,  1.01705670e+00,
        1.01622771e+00,  1.01505609e+00, -6.19702820e-02,             inf,
                   inf,  5.65603276e-02,  1.01543448e+00,  1.01645864e+00,
        1.01717985e+00,  1.01768390e+00,  1.01802583e+00,  1.01823949e+00,
        1.01834329e+00,  1.01834322e+00,  1.01823418e+00,  1.01799993e+00,
        1.01761188e+00,  1.01702655e+00,  1.01618150e+00,  1.01498890e+00,
       -6.20280313e-02,             inf,             inf,  5.64924147e-02,
        1.01531623e+00,  1.01637902e+00,  1.01712989e+00,  1.01765558e+00,
        1.01801224e+00,  1.01823488e+00,  1.01834281e+00,  1.01834274e+00,
        1.01823003e+00,  1.01798863e+00,  1.01758988e+00,  1.01698995e+00,
        1.01612569e+00,  1.01490812e+00, -6.21066146e-02,             inf,
                   inf,  5.64083393e-02,  1.01518296e+00,  1.01628960e+00,
        1.01707400e+00,  1.01762404e+00,  1.01799721e+00,  1.01822980e+00,
        1.01834228e+00,  1.01834222e+00,  1.01822557e+00,  1.01797660e+00,
        1.01756666e+00,  1.01695167e+00,  1.01606783e+00,  1.01482497e+00,
       -6.22038465e-02,             inf,             inf,  5.63104082e-02,
        1.01504639e+00,  1.01619838e+00,  1.01701733e+00,  1.01759229e+00,
        1.01798220e+00,  1.01822479e+00,  1.01834177e+00,  1.01834172e+00,
        1.01822131e+00,  1.01796528e+00,  1.01754517e+00,  1.01691678e+00,
        1.01601588e+00,  1.01475122e+00,  1.01299383e+00,             inf,
                   inf,  5.62013067e-02,  1.01491837e+00,  1.01611344e+00,
        1.01696502e+00,  1.01756329e+00,  1.01796867e+00,  1.01822034e+00,
        1.01834132e+00,  1.01834128e+00,  1.01821775e+00,  1.01795607e+00,
        1.01752819e+00,  1.01689006e+00,  1.01597724e+00,  1.01469774e+00,
        5.55987267e-02,             inf, -2.19902326e+13,  5.60840245e-02,
        1.01480980e+00,  1.01604213e+00,  1.01692171e+00,  1.01753972e+00,
        1.01795792e+00,  1.01821691e+00,  1.01834099e+00,  1.01834097e+00,
        1.01821531e+00,  1.01795014e+00,  1.01751804e+00,  1.01687540e+00,
        1.01595792e+00,  1.01467324e+00,  5.57157676e-02,             inf,
                   inf,  5.59617722e-02,  1.01472948e+00,  1.01599033e+00,
        1.01689106e+00,  1.01752363e+00,  1.01795094e+00,  1.01821482e+00,
        1.01834081e+00,  1.01834080e+00,  1.01821428e+00,  1.01794831e+00,
        1.01751630e+00,  1.01687540e+00,  1.01596183e+00,  1.01468324e+00,
        5.58378925e-02,             inf,             inf,  5.58378925e-02,
        1.01468324e+00,  1.01596183e+00,  1.01687540e+00,  1.01751630e+00,
        1.01794831e+00,  1.01821428e+00,  1.01834080e+00,  1.01834081e+00,
        1.01821482e+00,  1.01795094e+00,  1.01752363e+00,  1.01689106e+00,
        1.01599033e+00,  1.01472948e+00,  5.59617722e-02,             inf,
                   inf,  5.57157676e-02,  1.01467324e+00,  1.01595792e+00,
        1.01687540e+00,  1.01751804e+00,  1.01795014e+00,  1.01821531e+00,
        1.01834097e+00,  1.01834099e+00,  1.01821691e+00,  1.01795792e+00,
        1.01753972e+00,  1.01692171e+00,  1.01604213e+00,  1.01480980e+00,
        5.60840245e-02,             inf,             inf,  5.55987267e-02,
        1.01469774e+00,  1.01597724e+00,  1.01689006e+00,  1.01752819e+00,
        1.01795607e+00,  1.01821775e+00,  1.01834128e+00,  1.01834132e+00,
        1.01822034e+00,  1.01796867e+00,  1.01756329e+00,  1.01696502e+00,
        1.01611344e+00,  1.01491837e+00,  5.62013067e-02,             inf,
                   inf,  1.01299383e+00,  1.01475122e+00,  1.01601588e+00,
        1.01691678e+00,  1.01754517e+00,  1.01796528e+00,  1.01822131e+00,
        1.01834172e+00,  1.01834177e+00,  1.01822479e+00,  1.01798220e+00,
        1.01759229e+00,  1.01701733e+00,  1.01619838e+00,  1.01504639e+00,
        5.63104082e-02,             inf,             inf, -6.22038465e-02,
        1.01482497e+00,  1.01606783e+00,  1.01695167e+00,  1.01756666e+00,
        1.01797660e+00,  1.01822557e+00,  1.01834222e+00,  1.01834228e+00,
        1.01822980e+00,  1.01799721e+00,  1.01762404e+00,  1.01707400e+00,
        1.01628960e+00,  1.01518296e+00,  5.64083393e-02,             inf,
                   inf, -6.21066146e-02,  1.01490812e+00,  1.01612569e+00,
        1.01698995e+00,  1.01758988e+00,  1.01798863e+00,  1.01823003e+00,
        1.01834274e+00,  1.01834281e+00,  1.01823488e+00,  1.01801224e+00,
        1.01765558e+00,  1.01712989e+00,  1.01637902e+00,  1.01531623e+00,
        5.64924147e-02,             inf,             inf, -6.20280313e-02,
        1.01498890e+00,  1.01618150e+00,  1.01702655e+00,  1.01761188e+00,
        1.01799993e+00,  1.01823418e+00,  1.01834322e+00,  1.01834329e+00,
        1.01823949e+00,  1.01802583e+00,  1.01768390e+00,  1.01717985e+00,
        1.01645864e+00,  1.01543448e+00,  5.65603276e-02,             inf,
                   inf, -6.19702820e-02,  1.01505609e+00,  1.01622771e+00,
        1.01705670e+00,  1.01762989e+00,  1.01800913e+00,  1.01823753e+00,
        1.01834361e+00,  1.01834368e+00,  1.01824317e+00,  1.01803662e+00,
        1.01770633e+00,  1.01721926e+00,  1.01652128e+00,  1.01552731e+00,
        5.66102141e-02,             inf,             inf, -6.19349752e-02,
        1.01510048e+00,  1.01625815e+00,  1.01707650e+00,  1.01764168e+00,
        1.01801513e+00,  1.01823972e+00,  1.01834385e+00,  1.01834393e+00,
        1.01824554e+00,  1.01804355e+00,  1.01772070e+00,  1.01724447e+00,
        1.01656128e+00,  1.01558650e+00,  5.66407046e-02,             inf,
       -6.19230957e-02,  1.01511598e+00,  1.01626877e+00,  1.01708339e+00,
        1.01764578e+00,  1.01801721e+00,  1.01824047e+00,  1.01834394e+00,
        1.01834402e+00,  1.01824636e+00,  1.01804594e+00,  1.01772565e+00,
        1.01725315e+00,  1.01657502e+00,  1.01560683e+00,  5.66509620e-02])
#+end_example
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = get_possible_paths()
z_vals = []
for z in np.linspace(-10, 8, 21):    
    rays_test = csims.get_final_rays_reversed([0, 0, z], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
    distances_to_keep = []
    for distances in total_distances:
        if distances[-1] != 0:
            distances_to_keep.append(distances)

    mean = np.mean(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    stdev = np.std(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    z_vals.append([z, mean, stdev])
#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 160
total number of rays making past the first ellipse = 160
total number of rays making it all the way through = 120
initial number of rays = 160
total number of rays making past the first ellipse = 160
total number of rays making it all the way through = 120
initial number of rays = 160
total number of rays making past the first ellipse = 160
total number of rays making it all the way through = 120
initial number of rays = 200
total number of rays making past the first ellipse = 200
total number of rays making it all the way through = 130
initial number of rays = 200
total number of rays making past the first ellipse = 200
total number of rays making it all the way through = 160
initial number of rays = 240
total number of rays making past the first ellipse = 240
total number of rays making it all the way through = 160
initial number of rays = 280
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 200
initial number of rays = 268
total number of rays making past the first ellipse = 268
total number of rays making it all the way through = 226
initial number of rays = 292
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 240
initial number of rays = 304
total number of rays making past the first ellipse = 304
total number of rays making it all the way through = 240
initial number of rays = 336
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 280
initial number of rays = 360
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 320
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 360
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 376
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 280
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 210
initial number of rays = 344
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 200
initial number of rays = 288
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 160
initial number of rays = 240
total number of rays making past the first ellipse = 232
total number of rays making it all the way through = 130
initial number of rays = 208
total number of rays making past the first ellipse = 200
total number of rays making it all the way through = 120
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.array(z_vals)
min_index = np.argmin(z_vals[:, 2])
np.array(z_vals)[:, 0][min_index]
#+END_SRC

#+RESULTS:
: 1.700000000000001

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals[:, 2]
#+END_SRC

#+RESULTS:
: array([1.52296781, 1.28772728, 1.06984527, 1.2483588 , 1.34514481,
:        1.03877126, 1.31736707, 1.35589219, 0.97273461, 0.56507484,
:        0.42627106, 0.22313252, 0.04743211, 0.03990745, 0.11990995,
:        0.30871485, 0.3950818 , 0.56181706, 0.54255663, 0.56624547,
:        0.55211507])

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals[:, 0]
#+END_SRC

#+RESULTS:
: array([-10. ,  -9.1,  -8.2,  -7.3,  -6.4,  -5.5,  -4.6,  -3.7,  -2.8,
:         -1.9,  -1. ,  -0.1,   0.8,   1.7,   2.6,   3.5,   4.4,   5.3,
:          6.2,   7.1,   8. ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(10, 6))
plt.plot(np.array(z_vals)[:, 0], np.array(z_vals)[:, 2], '.')
plt.title('Tracing set of initial rays through the FTS (one path)')
plt.ylabel('standard deviation of path length (mm)')
plt.xlabel('FTS z position (mm)')
#plt.axhline(.5, label='1/2 wavelength of 300 Ghz', linestyle='--', color='black')
#plt.legend()
#plt.xlim(-50, 50)
plt.savefig('path length difference plot.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/2ba27b1941349eac79ded6dc9233d3595efcbd83.png]]


I think we're ready to go to notebook utils now.

* Now try y
#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = get_possible_paths()
z_vals = []
for z in np.linspace(-.7, .7, 21):    
    rays_test = csims.get_final_rays_reversed([0, z, 0], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
    distances_to_keep = []
    for distances in total_distances:
        if distances[-1] != 0:
            distances_to_keep.append(distances)

    mean = np.mean(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    stdev = np.std(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    z_vals.append([z, mean, stdev])

#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 350
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 0
/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning:

Mean of empty slice.

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning:

invalid value encountered in double_scalars

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning:

Degrees of freedom <= 0 for slice

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning:

invalid value encountered in true_divide

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning:

invalid value encountered in double_scalars
initial number of rays = 348
total number of rays making past the first ellipse = 346
total number of rays making it all the way through = 300
initial number of rays = 350
total number of rays making past the first ellipse = 344
total number of rays making it all the way through = 312
initial number of rays = 354
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 314
initial number of rays = 358
total number of rays making past the first ellipse = 354
total number of rays making it all the way through = 314
initial number of rays = 362
total number of rays making past the first ellipse = 356
total number of rays making it all the way through = 314
initial number of rays = 366
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 316
initial number of rays = 370
total number of rays making past the first ellipse = 366
total number of rays making it all the way through = 318
initial number of rays = 372
total number of rays making past the first ellipse = 372
total number of rays making it all the way through = 318
initial number of rays = 374
total number of rays making past the first ellipse = 374
total number of rays making it all the way through = 320
initial number of rays = 380
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 320
initial number of rays = 374
total number of rays making past the first ellipse = 374
total number of rays making it all the way through = 320
initial number of rays = 372
total number of rays making past the first ellipse = 372
total number of rays making it all the way through = 316
initial number of rays = 370
total number of rays making past the first ellipse = 366
total number of rays making it all the way through = 316
initial number of rays = 366
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 314
initial number of rays = 362
total number of rays making past the first ellipse = 356
total number of rays making it all the way through = 304
initial number of rays = 358
total number of rays making past the first ellipse = 354
total number of rays making it all the way through = 308
initial number of rays = 354
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 308
initial number of rays = 350
total number of rays making past the first ellipse = 344
total number of rays making it all the way through = 302
initial number of rays = 348
total number of rays making past the first ellipse = 346
total number of rays making it all the way through = 294
initial number of rays = 350
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 0
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.array(z_vals)
min_index = np.argmin(z_vals[:, 2])
np.array(z_vals)[:, 0][min_index]
#+END_SRC

#+RESULTS:
: -0.7

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals
#+END_SRC

#+RESULTS:
#+begin_example
array([[-7.00000000e-01,             nan,             nan],
       [-6.30000000e-01,  3.45368607e+03,  3.33860863e-01],
       [-5.60000000e-01,  3.45316571e+03,  3.33661043e-01],
       [-4.90000000e-01,  3.45267761e+03,  2.87275664e-01],
       [-4.20000000e-01,  3.45224725e+03,  2.44116680e-01],
       [-3.50000000e-01,  3.45188405e+03,  2.22444548e-01],
       [-2.80000000e-01,  3.45159476e+03,  2.27797502e-01],
       [-2.10000000e-01,  3.45135601e+03,  2.00342662e-01],
       [-1.40000000e-01,  3.45118701e+03,  1.91789696e-01],
       [-7.00000000e-02,  3.45109187e+03,  2.00825795e-01],
       [ 0.00000000e+00,  3.45105417e+03,  1.87994005e-01],
       [ 7.00000000e-02,  3.45109187e+03,  2.00822757e-01],
       [ 1.40000000e-01,  3.45118407e+03,  1.88796566e-01],
       [ 2.10000000e-01,  3.45135299e+03,  1.97354279e-01],
       [ 2.80000000e-01,  3.45159234e+03,  2.26497617e-01],
       [ 3.50000000e-01,  3.45187200e+03,  2.07151657e-01],
       [ 4.20000000e-01,  3.45223949e+03,  2.37196115e-01],
       [ 4.90000000e-01,  3.45266856e+03,  2.77749165e-01],
       [ 5.60000000e-01,  3.45314222e+03,  2.99083825e-01],
       [ 6.30000000e-01,  3.45366135e+03,  3.08669624e-01],
       [ 7.00000000e-01,             nan,             nan]])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(10, 6))
plt.plot(np.array(z_vals)[:, 0], np.array(z_vals)[:, 2], '.')
plt.title('Tracing set of initial rays through the FTS (one path)')
plt.ylabel('standard deviation of path length (mm)')
plt.xlabel('FTS z position (mm)')
#plt.axhline(.5, label='1/2 wavelength of 300 Ghz', linestyle='--', color='black')
#plt.legend()
#plt.xlim(-50, 50)
plt.savefig('path length difference plot.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ecb8bac2e66f468806e24781a37fb348f5107117.png]]


