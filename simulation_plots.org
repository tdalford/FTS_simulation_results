#+BEGIN_SRC jupyter-python :session py :kernel python3
import numpy as np
import matplotlib.pyplot as plt
import itertools
import RayTraceFunctionsv2 as rt

#assert RayTraceFunctionsv2.test_dims()
from RayTraceFunctionsv2 import * 

from random import uniform
import random
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio; pio.renderers.default='browser'
import pickle
import yaml
import seaborn as sns

import time

%load_ext autoreload
%autoreload 2

import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
mpl.rcParams['figure.dpi'] = 70
#mpl.rcParams['figure.facecolor'] = '1'

import coupling_optics_sims as csims
import notebook_utils
import fts_coupling_optics_geo as fts
from fts_coupling_optics_geo import *

# Calculated from Mathematica, see FTSImagesAndChecks.nb
LAST_LENS_EDGE = [-231.24377979, -266.21940725, 0.] 
COUPLING_OPTICS_ORIGIN = [-233.28894593160666, -276.84436350628596, 0.]
#+END_SRC

#+RESULTS:
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 


#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_aspect(config, aspect, element, number):
    '''Obtain the config for a given aspect, element, and number
    
    Parameters:
        config (yaml file)  -- yaml configuration file loaded
        aspect (str)        -- aspect of the FTS (origins, angles, coefficients, etc)
        element (str)       -- element of the FTS for which this aspect is defined 
                              (ellipses, mirror, polarizers)
        number (int)        -- number of the element that we're specifically interested
                            in (1-10 for ellipses, 1-4 for polarizers)'''
    
    def get_item(dic, key, num):
        if type(dic[key]) is dict:
            return dic[key][num]
        else:
            return dic[key]
        
    if element is None:
        return get_item(config, aspect, number)
    else:
        return get_item(config[aspect], element, number)
    
#with open("lab_fts_dims_dicts.yml", "r") as stream:
#    config_v2 = yaml.safe_load(stream)
    
#with open("lab_fts_dims_dicts_old.yml", "r") as stream:
#    config_old = yaml.safe_load(stream)
    
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)
    
#with open("lab_fts_dims_mcmahon_real.yml", "r") as stream:
#    config_real = yaml.safe_load(stream)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
# For creating regions for the central polarizers and central mirror
def get_ranges_and_global_coords(n, angle, ellipse_coeffs, length, direc,
                                 origin, theta, rad):
    assert direc in ['pos', 'neg']
    x1, y1, z1, x2, y2, z2 = FTSEC(n, angle, ellipse_coeffs, length, direc)

    def get_half_ranges(rad, xvals, yvals, zvals):
        x_global, y_global, z_global = transformLG(xvals, yvals, zvals, origin,
                                                   theta)
        xset, yset, zset = SR2(rad, x_global, y_global, z_global, origin)
        return xset, yset, zset

    xg1, yg1, zg1 = get_half_ranges(rad, x1, y1, z1)
    xg2, yg2, zg2 = get_half_ranges(rad, x2, y2, z2)
    center, range_vals = xrangeGL7(xg1, yg1, zg1, xg2, yg2, zg2, origin, theta)
    xg1.extend(xg2)
    yg1.extend(yg2)
    zg1.extend(zg2)
    return center, range_vals, [xg1, yg1, zg1]

n_val = 100
angle = np.pi / 8
length = 90
rad_val = 42.278
num_ellipse = [1, 2, 3, 4, 5, 6, 8, 9]

total_ellipse_centers = []
total_ellipse_ranges = []
total_ellipse_points = []

for i, num in enumerate(num_ellipse): 
    origin = get_aspect(config, 'origins', 'ellipses', num)
    direc = ['pos', 'neg'][origin[1] > 0]
    theta = get_aspect(config, 'angles', 'ellipses', num)
    coeffs = get_aspect(config, 'coefficients', 'ellipses', num)

    center, range_vals, points = get_ranges_and_global_coords(
        n_val, angle, coeffs, length, direc, origin, theta, rad_val)

    total_ellipse_centers.append(center)
    total_ellipse_ranges.append(range_vals)
    total_ellipse_points.append(points)
    
    # Make sure these match the file!
    print('ellipse %s: ' %num)
    print('center: %s range: %s \n' %(list(np.round(center, 4)), list(np.round(range_vals, 4))))
    assert (np.abs(np.array(center) - np.array(get_aspect(config, 'centers', None, num))) < .0001).all()
    assert (np.abs(np.array(range_vals) - np.array(get_aspect(config, 'ranges', None, num))) < .0001).all()

#+END_SRC

#+RESULTS:
#+begin_example
ellipse 1: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 

ellipse 2: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 

ellipse 3: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 4: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 5: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 6: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 8: 
center: [-0.0, 466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
ellipse 9: 
center: [-0.0, -466.6171, 0.0] range: [42.2727, 200.0, 40.7508] 
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_2d_ellipse(coeffs, center, n_points=1000):
    # assume no rotation here for simplicity
    # equation is (x - h)^2 / a^2 + (y - k)^2 / b^2 = 1
    assert len(center) == 2
    x_coeff, y_coeff = coeffs
    
    # First give a range of x values
    x_vals = np.linspace(-x_coeff, x_coeff, n_points) + center[0]
    # have to plot two y function to combine to the circle
    y1 = (np.sqrt(1 - ((x_vals - center[0]) / x_coeff)  ** 2)) * y_coeff + center[1]
    y2 = -(np.sqrt(1 - ((x_vals - center[0]) / x_coeff)  ** 2)) * y_coeff + center[1]
    
    return x_vals, y1, y2

def plot_mirrors(total_points, colors, fig):
    for i, points in enumerate(total_points):
        half_index = len(points[0]) // 2
        x1, y1, z1 = [points[j][:half_index] for j in range(len(points))]
        x2, y2, z2 = [points[j][half_index:] for j in range(len(points))]

        mesh1 = go.Mesh3d(x=x1, y=y1, z=z1, color=colors[i], opacity=0.50)
        mesh2 = go.Mesh3d(x=x2, y=y2, z=z2, color=colors[i], opacity=0.50)

        fig.add_trace(mesh1)
        fig.add_trace(mesh2)
        
def plot_rays(total_ray_points, total_ray_vectors, total_ray_distances, colors, fig, ray_alpha=None):
    for i in range(len(total_ray_points)):
        for j, point in enumerate(total_ray_points[i]):
            vector = total_ray_vectors[i][j]
            distance = total_ray_distances[i][j + 1]
            x, y, z = [[point[k], point[k] + distance * vector[k]] for k in range(3)]
            #print(colors)
            if ray_alpha is None:
                ray_alpha = .5
            line_data = go.Scatter3d(x=x, y=y, z=z, mode='lines', showlegend=False, 
                                     line=dict(color=colors[j]), opacity=ray_alpha)
            fig.add_trace(line_data)
            
def plot_center_items(fig, centers, coeffs, thicknesses, colors, opacities, n_points=1000):
    for i in range(len(centers)):
        # We want to find this ellipse over x and y here..
        x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
        x, z1, z2 = get_2d_ellipse(coeffs[i], (centers[i][0], centers[i][2]), n_points=n_points)
        for y in np.linspace(centers[i][1] - thicknesses[i], centers[i][1] + thicknesses[i], 10):
            x_vals.extend(x)
            z1_vals.extend(z1)
            z2_vals.extend(z2)
            y_vals.extend(n_points * [y])

        side1 = go.Mesh3d(x=x_vals, y=y_vals, z=z1_vals, color=colors[i], opacity=opacities[i]) 
        side2 = go.Mesh3d(x=x_vals, y=y_vals, z=z2_vals, color=colors[i], opacity=opacities[i])
        fig.add_trace(side1)
        fig.add_trace(side2)
        
def plot_det(fig, det_center, det_range, det_angle, thickness):
    x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
    x, z1, z2 = get_2d_ellipse([det_range, det_range], (0, 0), n_points=100)
    for y in np.linspace(-thickness, thickness, 10):
        x_vals.extend(x)
        z1_vals.extend(z1)
        z2_vals.extend(z2)
        y_vals.extend(100 * [y])
        
    x1, y1, z1 = transformLG(x_vals, y_vals, z1_vals, det_center, det_angle)
    x2, y2, z2 = transformLG(x_vals, y_vals, z2_vals, det_center, det_angle)

    side1 = go.Mesh3d(x=x1, y=np.array(y1), z=z1, color='gray', opacity=.2, alphahull=0) 
    side2 = go.Mesh3d(x=x2, y=np.array(y2), z=z2, color='gray', opacity=.2, alphahull=0)
    fig.add_trace(side1)
    fig.add_trace(side2)
    
def plot_rotated_ellipse(fig, ellipse_center, ellipse_range, ellipse_normal_vec, thickness, 
                         n_points=100, color='gray'):
    x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
    x, z1, z2 = get_2d_ellipse([ellipse_range, ellipse_range], (0, 0), n_points=n_points)
    for y in np.linspace(-thickness, thickness, 10):
        x_vals.extend(x)
        z1_vals.extend(z1)
        z2_vals.extend(z2)
        y_vals.extend(n_points * [y])
        
    rotation_matrix = get_rotation_matrix(ellipse_normal_vec, [0, 1, 0]) # the reference vector we have chosen.
    # now rotate these 
    x1, y1, z1 = transform_points(x_vals, y_vals, z1_vals, ellipse_center, rotation_matrix)
    x2, y2, z2 = transform_points(x_vals, y_vals, z2_vals, ellipse_center, rotation_matrix)

    side1 = go.Mesh3d(x=x1, y=np.array(y1), z=z1, color=color, opacity=.2, alphahull=0) 
    side2 = go.Mesh3d(x=x2, y=np.array(y2), z=z2, color=color, opacity=.2, alphahull=0)
    fig.add_trace(side1)
    fig.add_trace(side2)
    
def plot_rotated_plane(fig, plane_center, plane_range, plane_normal_vec, thickness, 
                       n_points=100):
    x_vals, y_vals, z_vals = [], [], []
    x = np.linspace(-plane_range, plane_range, int(np.sqrt(n_points)))
    z = np.linspace(-plane_range, plane_range, int(np.sqrt(n_points)))
    xx, zz = np.meshgrid(x, z)
    xx = xx.flatten()
    zz = zz.flatten()
    
    #x, z1, z2 = get_2d_ellipse([ellipse_range, ellipse_range], (0, 0), n_points=n_points)
    for y in np.linspace(-thickness, thickness, 3):
        x_vals.extend(xx)
        z_vals.extend(zz)
        y_vals.extend(len(xx) * [y])
        
    rotation_matrix = get_rotation_matrix(plane_normal_vec, [0, 1, 0]) # the reference vector we have chosen.
    # now rotate these 
    x1, y1, z1 = transform_points(x_vals, y_vals, z_vals, plane_center, rotation_matrix)
    #x2, y2, z2 = transform_points(x_vals, y_vals, z2_vals, ellipse_center, rotation_matrix)

    side1 = go.Mesh3d(x=x1, y=np.array(y1), z=z1, color='gray', opacity=.2, alphahull=0) 
    #side2 = go.Mesh3d(x=x2, y=np.array(y2), z=z2, color='gray', opacity=.2, alphahull=0)
    fig.add_trace(side1)
    #fig.add_trace(side2)
    
def get_rotation_matrix(a, b):
    v = np.cross(a, b)
    s = np.sqrt(np.sum(np.square(v)))
    c = np.dot(a, b)
    vx = np.array([[0, -v[2], v[1]], 
                  [v[2], 0, -v[0]], 
                  [-v[1], v[0], 0]])
    return np.identity(3) + vx + np.linalg.matrix_power(vx, 2) * (1 - c) / (s ** 2)
    
    
def transform_points(x_vals, y_vals, z_vals, new_origin, rotation_matrix):
    XTR = []
    YTR = []
    ZTR = []
    for i in range(0, len(x_vals)):
        v = [x_vals[i], y_vals[i], z_vals[i]]
        #v2R = rotate(v, thetaxyz)
        v2R = np.dot(v, rotation_matrix)
        v2RS = v2R + new_origin
        XTR.append(v2RS[0])
        YTR.append(v2RS[1])
        ZTR.append(v2RS[2])
    return XTR, YTR, ZTR
    
        
def rotate_ellipse(xvals, yvals, z1_vals, z2_vals, theta):
    points_new = []
    for zvals in [z1_vals, z2_vals]:
        points = transformLG(xvals, yvals, zvals, [0, 0, 0], theta)
        points_new.append(points)
    return points_new

def plot_dihedral(fig, center, coeff, thickness):
    # We want to find this ellipse over x and z here
    x_vals, y_vals, z1_vals, z2_vals = [], [], [], []
    x, z1, z2 = get_2d_ellipse(coeff, (center[0], center[2]), n_points=1000)
    for y in np.linspace(-1 * thickness, thickness, 10):
        x_vals.extend(x)
        z1_vals.extend(z1)
        z2_vals.extend(z2)
        y_vals.extend(1000 * [y]) 

    # Rotate both parts around the x axis
    for theta in [[np.pi / 4, 0, 0], [-np.pi / 4, 0, 0]]:
        p1s, p2s = rotate_ellipse(x_vals, y_vals, z1_vals, z2_vals, theta)
        x1, y1, z1 = p1s
        x2, y2, z2 = p2s

        side1 = go.Mesh3d(x=x1, y=np.array(y1) + center[1], z=z1, color='blue', opacity=.25) 
        side2 = go.Mesh3d(x=x2, y=np.array(y2) + center[1], z=z2, color='blue', opacity=.25)
        fig.add_trace(side1)
        fig.add_trace(side2)

def plot_segment(point, vector, distance, fig, color):
    xval, yval, zval = [[point[k], point[k] + distance * vector[k]] for k in range(3)]
    line_data = go.Scatter3d(x=xval, y=yval, z=zval, mode='lines', showlegend=False, 
                         line=dict(color=color), opacity=.3 / 4)
    fig.add_trace(line_data)
    
def plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=None, 
                   ray_alpha=None):
    if (fig is None):
        fig = go.Figure()

    # Plot the elliptical mirrors
    colors = 9 * ['silver']
    plot_mirrors(total_ellipse_points, colors, fig)

    # Plot the rays
    colors = ['black', 'black', 'red', 'red', 'orange', 'black', 'orange', 'yellow',
              'yellow', 'green', 'green', 'blue', 'blue', 'purple']
    colors = 14 * ['black']
    for points, vectors, distances in zip(all_points, all_vectors, all_distances):
        plot_rays(points, vectors, distances, colors, fig, ray_alpha=ray_alpha)

    # Plot the polarizers and 'detector'
    centers = [get_aspect(config, 'origins', 'polarizers', i + 1) for i in range(4)]# + [
        #config['detector']['center']]# + np.array([0, -1, 0])]
    coeffs = [get_aspect(config, 'coefficients', 'polarizers', i + 1)[:2] for i in range(4)]# + [
        #[config['detector']['range'], config['detector']['range']]]

    #coeffs = 4 * [coeffpolar[:2]]
    thicknesses = 4 * [.4]
    colors = 4 * ['teal']# + ['black']
    opacities = 4 * [.2]# + [.4]
    n_points = 100
    plot_center_items(fig, centers, coeffs, thicknesses, colors, opacities, n_points=n_points)

    # Plot the dihedral mirror
    coeff = coeffs[0]
    thickness = 1
    plot_dihedral(fig, mirror_position, coeff, thickness)
    
    # Plot the detector
    # plot_rotated_ellipse(fig, config['detector']['center'], config['detector']['range'], 
    #                     config['detector']['normal_vec'], thicknesses[0], n_points=100)

    # # plot the final mirrors
    # plot_rotated_plane(fig, config['other_mirrors'][1]['origin'], 60,  
    #                    config['other_mirrors'][1]['normal_vec'], thicknesses[0], n_points=100)

    # plot_rotated_ellipse(fig, config['other_mirrors'][2]['origin'], 60, 
    #                      config['other_mirrors'][2]['normal_vec'], thicknesses[0], 
    #                      n_points=100)
    
    # # plot the aperture
    # plot_rotated_ellipse(fig, config['apertures'][1]['origin'], config['apertures'][1]['range'], 
    #                      config['apertures'][1]['normal_vec'], thicknesses[0], 
    #                      n_points=100, color='black')


    # Update the figure settings
    fig.update_layout(scene = dict(xaxis_title='Z (mm)', yaxis_title='Y (mm)',
                                   zaxis_title='X (mm)',
                        yaxis=dict(range=[-1000, 500]),
                        zaxis=dict(range=[-300, 300]),
                        xaxis=dict(range=[-1000, 500])),
                      width=700)#,
                      #margin=dict(r=20, b=10, l=10, t=10))


    #fig.show()
    
def transform_rays_perfect(rays, config, plot=False, plot_mirror_position=35, fig=None):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE #[-231.24377979, -266.21940725, 0.]
    angle = .19016
    for ray in rays:
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        #ray[2] = np.add(ray[2], source_point_origin)
        ray[3] = new_vec
        #ray[4] = 0
        
    possible_paths = get_possible_paths()
        
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    if (plot):
        all_points, all_vectors, all_distances= [], [], []
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238)
        
        if (plot):
            all_points.append(total_ray_points)
            all_vectors.append(total_vectors)
            all_distances.append(total_distances)
    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig)
    return rays


def step_rays(starting_rays, config, ray_func, *ray_func_args, final_dist=50, 
              debug=1):
    # Data structure which contains starting point, vector, length for each ray
    # through the sim
    total_ray_points = []
    total_ray_vectors = []
    total_ray_distances = []
    counts = []
    max_count = None

    for starting_ray in starting_rays:
        current_rays = ray_func(
            starting_ray, *ray_func_args, return_all_rays=True)
        # We want to save the point, vector, and distance travelled for each of
        # these rays!
        points = []
        vectors = []
        distances = [starting_ray[4]]
        count = 0
        max_count = len(current_rays) + 1
        for i, ray in enumerate(current_rays):
            if ray is not None:
                count += 1
                points.append(ray[2])
                vectors.append(ray[3])

                # If we're not at the final ray and the next ray hit,
                # calculated the distance!
                if (i < len(current_rays) - 1):
                    if current_rays[i + 1] is not None:
                        distances.append(
                            current_rays[i + 1][4] - current_rays[i][4])
                else:
                    # The ray made it to the last detector; give it some
                    # smaller distance to visualize.
                    final_ray = get_final_rays_tilt(
                        [ray], config['detector']['center'], config['detector']['range'],
                        config['detector']['normal_vec'])
                    if (final_ray) != []:
                        distances.append(dist(ray[2], final_ray[0][2]))
                        count += 1

                    else:
                        distances.append(final_dist)

                    # distances.append(final_dist)
            else:
                # The ray did not make it to the end.
                # Append a final distance for the last ray so we can see where
                # it went.
                distances.append(final_dist)

        total_ray_points.append(points)
        total_ray_vectors.append(vectors)
        total_ray_distances.append(distances)
        counts.append(count)

    assert debug in [0, 1, 2]
    if (debug == 2):
        print('final ray counts = %s' % counts)
    if (debug == 1):
        print('initial number of rays = %s' % len(starting_rays))
        print('total number of rays making past the first ellipse = %s' % np.sum(
            np.array(counts) != 1))
        print('total number of rays making it all the way through = %s' % np.sum(
            np.array(counts) == max_count))
    return total_ray_points, total_ray_vectors, total_ray_distances
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_plane(coeffs, center, n_points=100 * 100, point_range=10, z_set_value=None):
    # equation is given by A x + B y + C z = D
    assert len(coeffs) == 4
    assert len(center) == 2
    x_points = np.linspace(center[0] - point_range, center[0] + point_range, int(np.sqrt(n_points)))
    y_points = np.linspace(center[1] - point_range, center[1] + point_range, int(np.sqrt(n_points)))
    x, y = np.meshgrid(x_points, y_points)
    a, b, c, d = coeffs
    z = (a * x + b * y  - d) / c
    # set a highest value for z- kinda hacky
    if z_set_value is not None:
        z[z > z_set_value] = z_set_value#z_set_value
        z[z < -1 * z_set_value] = 0#-1 * z_set_value
    return x, y, z

def plot_surface(x, y, z, fig, color, alpha=.1):
    shape = go.Mesh3d(x=x, y=y, z=z, color=color,
                      opacity=alpha, alphahull=0)
    fig.add_trace(shape)
    
def plot_surface(x, y, z, fig, color, alpha=.1):

    x_tot1, y_tot1, z_tot1 = ([], [], [])

    for l in range(len(x[0])):
        x_new_1, y_new_1, z_new_1 = x[:, l], y[:, l], z[:, l]

        x_tot1.extend(x_new_1)
        y_tot1.extend(y_new_1)
        z_tot1.extend(z_new_1)

    # Change x and z directions to match FTS defined
    shape = go.Mesh3d(z=z_tot1, y=y_tot1, x=x_tot1, color=color,
                      opacity=alpha, alphahull=-1)
    fig.add_trace(shape)

def plot_plane(fig, origin, point_range=10, n_points=50,  tilt_angle=None, normal_vec=None, 
               z_set_value=None):
    # first we need to get the coefficients
    # we find these by applying the tilt to the original normal vector,
    # which is (0, 1, 0)
    if (normal_vec) is None:
        assert tilt_angle is not None
        normal_vec = transformLG(1e-10, 1, 1e-10, [0, 0, 0], tilt_angle)
    # add some jitter so we don't div by zero
    normal_vec = np.add(normal_vec, [1e-5, 1e-5, 1e-5])
    print(normal_vec)
    # our origin is still the same.. e.g. we just need to get the new d coeff
    d = np.dot(origin, np.array(normal_vec))
    # now just plot these
    a, b, c = normal_vec
    x, y, z = get_plane([a, b, c, d], origin[:2], n_points=n_points, point_range=point_range, 
                        z_set_value=z_set_value)
    plot_surface(x, y, z, fig, 'blue')
    #fig.show()

def transform_rays_end_tilt(rays, config, plot=False, plot_mirror_position=35, fig=None, 
                            ray_alpha=None):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE#[-231.24370418, -266.21901446, 0.] # should get rid of these magic numbers.
    angle = .190161
    for ray in rays:
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        #ray[2] = np.add(ray[2], source_point_origin)
        ray[3] = new_vec
        #ray[4] = 0
        
    #possible_paths = [path + ['OM1', 'A1', 'OM2'] for path in get_possible_paths()]
    possible_paths = get_possible_paths()
        
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    all_points, all_vectors, all_distances= [], [], []
    path_diffs = []
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238)
        path_diffs.append(total_distances)
        
        all_points.append(total_ray_points)
        all_vectors.append(total_vectors)
        all_distances.append(total_distances)

    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig, 
                       ray_alpha=ray_alpha)
    return all_points, all_vectors, all_distances

def transform_rays_to_fts_frame(rays):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE#[-231.24370418, -266.21901446, 0.] # should get rid of these magic numbers.
    angle = .190161
    new_rays = []
    for ray in rays:
        new_ray = [ray[0], ray[1], None, None, ray[4]]
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        new_ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        new_ray[3] = new_vec
        new_rays.append(new_ray)

    return new_rays
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
mm_to_in = 1 / 25.4
shift = [0, 0, 0]
start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.3, plot=True, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_, path_diffs = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 80
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 80
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, .4, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.3, plot=True, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_, path_diffs = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 72
: total number of rays making past the first ellipse = 72
: total number of rays making it all the way through = 72
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 72
: total number of rays making past the first ellipse = 72
: total number of rays making it all the way through = 72

#+BEGIN_SRC jupyter-python :session py :kernel python3
[['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
#+END_SRC

#+RESULTS:
: [['OM2', 'A1', 'OM1', 'R4', 'E5', 'T3', 'E4', 'DM0', 'E3', 'T2', 'E8', 'T1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'R3', 'E4', 'DM0', 'E3', 'R2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'R3', 'E4', 'DM0', 'E3', 'T2', 'E8', 'T1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'T3', 'E2', 'DM0', 'E1', 'T2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'R4', 'E5', 'R3', 'E2', 'DM0', 'E1', 'T2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'R4', 'E5', 'R3', 'E2', 'DM0', 'E1', 'R2', 'E8', 'T1'],
:  ['OM2', 'A1', 'OM1', 'R4', 'E5', 'T3', 'E4', 'DM0', 'E3', 'R2', 'E9', 'R1'],
:  ['OM2', 'A1', 'OM1', 'T4', 'E6', 'T3', 'E2', 'DM0', 'E1', 'R2', 'E8', 'T1']]

#+BEGIN_SRC jupyter-python :session py :kernel python3
# now try and plot these and see what happens!
def fts_forward_raytrace(rays, config, plot=False, plot_mirror_position=35, fig=None):
    possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
    
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    if (plot):
        all_points, all_vectors, all_distances = [], [], []

    total_made = 0
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238, debug=False)
        for distances in total_distances:
            if distances[-1] != 238:
                total_made += 1
                
        if (plot):
            all_points.append(total_ray_points)
            all_vectors.append(total_vectors)
            all_distances.append(total_distances)
    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig)
    return total_made


def create_source_rays(source_origin, source_range, source_normal_vec, n_points, config,
                       check_rays=True, theta_bound=.2, timeout=10):
    # first create rays distributed in the upwards cone
    # and then rotate them to center them around the normal
    # also create them around a variety of starting points
    # assume radially symmetric source
    rotation_matrix = get_rotation_matrix(source_normal_vec, [0, 0, 1])
    rays = []
    
    # now we really have n^4 computations... for n^2 for the circle, n^2 for the angle
    # really we should just create like 20 points distributed uniformly on the circle
    # and then for each of those get like 5 * 5 vectors worth
    # for 20 * 25 total points
    
    iters = 0
    starting_time = time.time()
    while len(rays) < n_points and time.time() - starting_time < timeout:
        # generate a random starting point
        point_origin = [source_range * (2 * np.random.random() - 1), 
                        source_range * (2 * np.random.random() - 1), 0]
        # point_origin = [0, 0, 0]
        
        # create the points/vectors first and then rotate both
        # just use the old transformLG method?
        
        # generate a random starting angle and then rotate to the frame of the source
        z_val = np.random.uniform(np.cos(theta_bound), 1)
        # theta = np.arccos(np.random.uniform(-1, 1))
        phi_val = np.random.uniform(0, 2 * np.pi)

        # Direction of ray away from the starting point
        sinthet = np.sqrt(1 - z_val ** 2)
        r_hat = [sinthet * np.cos(phi_val), sinthet * np.sin(phi_val), z_val]

        transformed_starting_vector = -1 * np.array(transform_points(
            [r_hat[0]], [r_hat[1]], [r_hat[2]], [0, 0, 0], rotation_matrix)).flatten()
        
        transformed_starting_point = np.array(transform_points([point_origin[0]], [point_origin[1]], [point_origin[2]], 
                                                               source_origin, rotation_matrix)).flatten()

        # strategically choose our starting rays such that they make it through the
        # to the first ellipse that we hit
        polarization_angle = .123
        intensity = 1.0
        ray = [polarization_angle, intensity, transformed_starting_point.tolist(), 
               transformed_starting_vector.tolist(), 0]
        # paths = ['OM2', 'A1', 'OM1', 'T4', 'E6']
        if (check_rays):
            paths = ['T4', 'E6']
            final_ray = run_ray_through_sim(ray, config, None, paths)
            if (final_ray is not None):
                rays.append(ray)
        else:
            rays.append(ray)

        iters += 1
        
    return rays


def create_source_rays_uniform(
        source_origin, source_range, source_normal_vec, n_linear_radius, 
        n_linear_z, n_linear_phi, config, check_rays=True, theta_bound=.2, 
        timeout=10):
    # first create rays distributed in the upwards cone
    # and then rotate them to center them around the normal
    # also create them around a variety of starting points
    # assume radially symmetric source
    rotation_matrix = get_rotation_matrix(source_normal_vec, [0, 0, 1])
    rays = []
    
    # now we really have n^4 computations... for n^2 for the circle, n^2 for the angle
    # really we should just create like 20 points distributed uniformly on the circle
    # and then for each of those get like 5 * 5 vectors worth
    # for 20 * 25 total points
    
    starting_time = time.time()
    for x in np.linspace(-1 * source_range, source_range, n_linear_radius):
        for y in np.linspace(-1 * source_range, source_range, n_linear_radius):
            for z_val in np.linspace(np.cos(theta_bound), 1, n_linear_z):
                for phi_val in np.linspace(0, 2 * np.pi, n_linear_phi):
                    if time.time() - starting_time > timeout:
                        print('timing out..')
                        return rays

                    point_origin = [x, y, 0]
                    
                    # Direction of ray away from the starting point
                    sinthet = np.sqrt(1 - z_val ** 2)
                    r_hat = [sinthet * np.cos(phi_val), sinthet * np.sin(phi_val), z_val]

                    transformed_starting_vector = -1 * np.array(transform_points(
                        [r_hat[0]], [r_hat[1]], [r_hat[2]], [0, 0, 0], rotation_matrix)).flatten()

                    transformed_starting_point = np.array(transform_points([point_origin[0]], [point_origin[1]], [point_origin[2]], 
                                                                           source_origin, rotation_matrix)).flatten()

                    # strategically choose our starting rays such that they make it through the
                    # to the first ellipse that we hit
                    polarization_angle = .123
                    intensity = 1.0
                    ray = [polarization_angle, intensity, transformed_starting_point.tolist(), 
                        transformed_starting_vector.tolist(), 0]
                    # paths = ['OM2', 'A1', 'OM1', 'T4', 'E6']
                    if (check_rays):
                        paths = ['T4', 'E6']
                        final_ray = run_ray_through_sim(ray, config, None, paths)
                        if (final_ray is not None):
                            rays.append(ray)
                    else:
                        rays.append(ray)
        
    return rays

def transform_rays_to_coupling_optics_frame(rays):
    # we want the rays essentially directly after they hit the last polarizer
    # in the FTS and then we need to calculate the distance between this
    # polarizer and the first lens of the coupling optics
    
    # first we need to transform the rays' points and normal vectors to the
    # frame of the coupling optics
    
    # Here we really need to make sure we're properly rotating this ray really
    # the ray should stop at the plane which makes the same beam angle as the
    # coupling optics actually things should be fine I think, but just in case
    # do it this way I guess
    # don't stop at (0, 0, 0), stop at (0, -.426, 0) equivilently
    coupling_optics_origin = COUPLING_OPTICS_ORIGIN
    angle = -0.190161
    factor = csims.mm_to_in
    new_rays = []
    for ray in rays:
        new_ray = [ray[0], ray[1], None, None, ray[4]]
        # switch the x and z coordinate of these!
        new_vec = rotate(ray[3], [0, 0, angle])
        new_ray[2] = factor * np.flip(rotate(np.subtract(ray[2], coupling_optics_origin), 
                                             [0, 0, angle]) * [1, -1, 1])
        new_ray[3] = np.flip(csims.normalize(factor * new_vec * [1, -1, 1]))
        new_rays.append(new_ray)

    return new_rays

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3 :results None
with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)
fig = go.Figure()
starting_rays = create_source_rays(config['detector']['center'], config['detector']['range'], 
                                   config['detector']['normal_vec'], 2000, config, theta_bound=.2)

# now raytrace fromt these rays onwards!
total_made = fts_forward_raytrace(starting_rays, config, plot=False, plot_mirror_position=0, fig=fig)
# print(np.sum([total_made[i][-1] != 238 for i in range(len(total_made))]))
print(total_made // 2)

# this is insane, 10000 rays???
# oh mannn
fig.show()
#+END_SRC

#+RESULTS:
: 267
#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)
fig = go.Figure()
starting_rays = create_source_rays(config['detector']['center'], 1, 
                                   config['detector']['normal_vec'], 50, config, theta_bound=.2)

# now raytrace fromt these rays onwards!
total_made = fts_forward_raytrace(starting_rays, config, plot=True, plot_mirror_position=0, fig=fig)
# print(np.sum([total_made[i][-1] != 238 for i in range(len(total_made))]))
print(total_made // 2)

# this is insane, 10000 rays???
# oh mannn
fig.show()
#+END_SRC

#+RESULTS:
: 197


# might be easier to just not plot the rays that don't make it

I'll come back to this another day. but really I should probably not debug here
and just step through as normal then maybe just have a part of the function
that immediately returns if a ray is None.

* Run rays forwards through the coupling optics

#+BEGIN_SRC jupyter-python :session py :kernel python3
#with open("lab_fts_dims_mcmahon.yml", "r") as stream:
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 50, config, 
                                   theta_bound=0.2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=-20.9, plot=True,
                                         fig=fig, color='red')
fig.show()

#+END_SRC

#+RESULTS:

* Run Rays Backwards through the Coupling Optics

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'red', fig, n_linear=7,
                                                      theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_, path_diffs = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 49
: total number of rays making past the first ellipse = 49
: total number of rays making it all the way through = 49
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 49
: total number of rays making past the first ellipse = 49
: total number of rays making it all the way through = 49

* Test that running backwards and forwards returns the same rays


#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'red', fig, n_linear=1,
                                                      theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

points, vecs, dists = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig)
fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 1
total number of rays making past the first ellipse = 1
total number of rays making it all the way through = 1
initial number of rays = 1
total number of rays making past the first ellipse = 1
total number of rays making it all the way through = 1
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
np.around(final_point, decimals=10)
#+END_SRC

#+RESULTS:
: array([233.83113845, 333.91750757,   0.        ])


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
starting_rays = [[.123, 1.0, final_point, final_vec, 0]]

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=-20.9, plot=True,
                                         fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 

Ok, first test to see whether raytracing through the FTS itself is the same
forwards and backwards. Then we test to see if raytracing through the coupling
optics is the same.. then if those are both the same I guess we have to make
sure the combination is the same too... currently it's slightly off.

definitely test the coupling optics first


#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .2, 0])
fig = go.Figure()
out = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                               theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)
fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
intersect at lens flat from reversed = [-0.      13.91335 -0.56929]
intersect at lens 22 from reversed = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vector going from flat to 22 reversed = [ 0.      -0.16141 -0.98689]
vector from 22 to 21 reversed in global frame = [ 0.      -0.99419  0.10766]
--------------------------------------------------------------------------------
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
initial normal vec = [ 0.      -0.99419  0.10766]
P21 intersect = [0.      8.25801 0.23296]
vec at 21 in 21 surface frame = [ 0.      -0.23296 -0.00971]
vec at 22 in 21 surface frame = [-0.       0.00753  2.21099]
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 12: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_22_21 = [ 0.      -0.10766 -0.99419]
normal vec spit out from snells = [ 0.      -0.20757 -0.97822]
--------------------------------------------------------------------------------
vector going from 22 to 21 reversed = [ 0.      -0.10766 -0.99419]
intersect at lens 12 from reversed = [0.      0.09573 1.9649 ]
vector going from 21 to 12 reversed = [ 0.      -0.20757 -0.97822]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
fig = go.Figure()
out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=-20.9, plot=True,
                                                   fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 22: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_12_21 = [-0.       0.20757  0.97822]
normal vec spit out from snells=[-0.       0.10766  0.99419]
normal vector from 21 to 22 forwards in global frame = [-0.       0.99419 -0.10766]
P21 intersect = [0.      8.25801 0.23296]
initial normal vec = [-0.       0.99419 -0.10766]
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
--------------------------------------------------------------------------------
intersect at lens 22 going forwards = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vec at 21 in 22 surface frame = [ 0.      -0.23296 -2.22071]
vec at 22 in 22 surface frame = [-0.00e+00  7.53e-03 -1.00e-05]
normal vector from 21 to 22 forwards = [-0.       0.10766  0.99419]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(out_backwards[0][[0, 1, 2]], decimals=5)
#+END_SRC

#+RESULTS:
: array([[  0.     ],
:        [ 13.54406],
:        [-20.9    ]])

#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position
#+END_SRC

#+RESULTS:
: array([  0.        ,  13.54406336, -20.9       ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.array(out_backwards[1]).T, decimals=5)
#+END_SRC

#+RESULTS:
: array([[ 0.000000e+00, -4.260000e-01,  1.934990e+00],
:        [ 0.000000e+00, -1.959800e-01,  1.964450e+00],
:        [ 0.000000e+00,  9.573000e-02,  1.964900e+00],
:        [ 0.000000e+00,  8.258010e+00,  2.329600e-01],
:        [-0.000000e+00,  1.047870e+01, -7.530000e-03],
:        [-0.000000e+00,  1.391335e+01, -5.692900e-01],
:        [-0.000000e+00,  1.556334e+01, -1.065744e+01],
:        [-0.000000e+00,  1.553863e+01, -1.106052e+01],
:        [ 0.000000e+00,  1.354406e+01, -2.090000e+01]])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.array(points1).T, decimals=5)[::-1]
#+END_SRC

#+RESULTS:
: array([[ 0.000000e+00, -4.260000e-01,  1.934990e+00],
:        [ 0.000000e+00, -1.959800e-01,  1.964450e+00],
:        [ 0.000000e+00,  9.573000e-02,  1.964900e+00],
:        [ 0.000000e+00,  8.258010e+00,  2.329600e-01],
:        [-0.000000e+00,  1.047870e+01, -7.530000e-03],
:        [-0.000000e+00,  1.391335e+01, -5.692900e-01],
:        [-0.000000e+00,  1.556334e+01, -1.065744e+01],
:        [-0.000000e+00,  1.553863e+01, -1.106052e+01],
:        [ 0.000000e+00,  1.354406e+01, -2.090000e+01]])


So it is indeed slightly off.... we see that the culprit begins at the fourth
point from the end!!


first should check and see if the vectors are the same...

#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .4, 0])
# fig = go.Figure()
out, points1 = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                               theta_bound=.2, plot=False, y_ap=-.426, alpha=.2)

starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]

out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=-20.9, plot=False,
                                                   fig=fig, color='red')
# fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
intersect at lens flat from reversed = [-0.      13.67928 -0.33521]
intersect at lens 22 from reversed = [-0.      10.4553   0.30896]
vector going from flat to 22 reversed = [ 0.      -0.19593 -0.98062]
intersect at lens 21 from reversed = [0.      8.2266  0.47814]
vector going from 22 to 21 reversed = [ 0.      -0.07569 -0.99713]
intersect at lens 12 from reversed = [0.      0.48285 0.40472]
vector going from 21 to 12 reversed = [ 0.       0.00948 -0.99996]
intersection at point 21 going forwards= [0.      8.2266  0.47814]
normal vector going from 12 to 21 forwards = [-0.      -0.00948  0.99996]
intersect at lens 22 going forwards = [-0.      10.38319  0.61849]
normal vector from 21 to 22 forwards = [-0.      -0.06495  0.99789]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.array(out_backwards[1]).T, decimals=10)
#+END_SRC

#+RESULTS:
: array([[  0.        ,  -0.426     ,   0.37100744],
:        [  0.        ,  -0.41787461,   0.37164615],
:        [  0.        ,   0.48284728,   0.40471509],
:        [  0.        ,   8.22659585,   0.47813597],
:        [ -0.        ,  10.38319078,   0.61849444],
:        [ -0.        ,  12.88805014,   0.45601322],
:        [ -0.        ,  13.57392188, -10.11759151],
:        [ -0.        ,  13.60278475, -11.2755673 ],
:        [ -0.        ,  13.84920871, -20.9       ]])

The problem is at p_21 the normal vectors are different, causing a different intersect point at P_22


#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .2, 0])
# fig = go.Figure()
out, points1 = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                               theta_bound=.2, plot=False, y_ap=-.426, alpha=.2)

starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]

out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=-20.9, plot=False,
                                                   fig=fig, color='red')
# fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
intersect at lens flat from reversed = [-0.      13.91335 -0.56929]
intersect at lens 22 from reversed = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vector going from flat to 22 reversed = [ 0.      -0.16141 -0.98689]
vector from 22 to 21 reversed in global frame = [ 0.      -0.99419  0.10766]
--------------------------------------------------------------------------------
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
initial normal vec = [ 0.      -0.99419  0.10766]
P21 intersect = [0.      8.25801 0.23296]
vec at 21 in 21 surface frame = [ 0.      -0.23296 -0.00971]
vec at 22 in 21 surface frame = [-0.       0.00753  2.21099]
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 12: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_22_21 = [ 0.      -0.10766 -0.99419]
normal vec spit out from snells = [ 0.      -0.20757 -0.97822]
--------------------------------------------------------------------------------
vector going from 22 to 21 reversed = [ 0.      -0.10766 -0.99419]
intersect at lens 12 from reversed = [0.      0.09573 1.9649 ]
vector going from 21 to 12 reversed = [ 0.      -0.20757 -0.97822]
--------------------------------------------------------------------------------
norm at 21 = [-0.       0.08348]
snells law at 21 to go to 22: n_lens = 1.517. 
 N_hat = [ 0.      -0.08319  0.99653]. tan_12_21 = [-0.       0.20757  0.97822]
normal vec spit out from snells=[-0.       0.10766  0.99419]
normal vector from 21 to 22 forwards in global frame = [-0.       0.99419 -0.10766]
P21 intersect = [0.      8.25801 0.23296]
initial normal vec = [-0.       0.99419 -0.10766]
P22 intersect = [-0.00000e+00  1.04787e+01 -7.53000e-03]
--------------------------------------------------------------------------------
intersect at lens 22 going forwards = [-0.00000e+00  1.04787e+01 -7.53000e-03]
vec at 21 in 22 surface frame = [ 0.      -0.23296 -2.22071]
vec at 22 in 22 surface frame = [-0.00e+00  7.53e-03 -1.00e-05]
normal vector from 21 to 22 forwards = [-0.       0.10766  0.99419]
#+end_example



#+begin_src jupyter-python :session py :kernel python3
N_hat = [ 0.,      -0.17074,  0.98532]
tan_22_21 = [ 0.,      -0.07569, -0.99713]
csims.snell_vec(1, 1.517, np.array(N_hat), np.array(tan_22_21))
#+end_src

#+RESULTS:
: array([ 0.        ,  0.00948078, -0.99995888])

#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [ 0.,      -0.17074,  0.98532]
tan_12_21 = [-0.,      -0.00948078,  0.99995888]
csims.snell_vec(1, 1.517, -1 * np.array(N_hat), np.array(tan_12_21))
#+END_SRC

#+RESULTS:
: array([ 0.        , -0.06494426,  0.99789273])

#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [ 0.,      -0.17074,  0.98532]
tan_12_21 = [-0.,      -0.00948078,  0.99995888]
print(csims.snell_vec(1.517, 1, -1 * np.array(N_hat), np.array(tan_12_21)))
print(tan_22_21)
#+END_SRC

#+RESULTS:
: [0.         0.07569293 0.99713501]
: [0.0, -0.07569, -0.99713]

THIS IS IT!!!!!!!


#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [0, 1, 0]
tan_12_21 = csims.normalize([.3, .7, 0])
csims.normalize(csims.snell_vec(1, 2, np.array(N_hat), np.array(tan_12_21)))
#+END_SRC

#+RESULTS:
: array([ 0.19695965, -0.9804116 ,  0.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
N_hat = [0, 1, 0]
tan_12_21 = [-.19696, .9804, 0]
print(csims.normalize(csims.snell_vec(2, 1, np.array(N_hat), np.array(tan_12_21))))
print(csims.normalize(csims.snell_vec(1, 2, np.array(N_hat), np.array(tan_12_21))))
print(tan_12_21)
#+END_SRC

#+RESULTS:
: [-0.39392    -0.91914473  0.        ]
: [-0.09848    -0.99513903  0.        ]
: [-0.19696, 0.9804, 0]


Ok at this point I should test this in Mathematica:


Maybe make sure the n vac and n lens usages are correct

Ok the problem is that I forgot to switch the n_vac and n_lens for these surfaces
yeah I thin

IT'S FIXED!!!!!!!!

Ok now I should just test to make sure that in total the forwards and backwards raytraces are the same!

* Test Backwards and Forwards Total

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = [0, ((210+82)*csims.mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'red', fig, n_linear=1,
                                                      theta_bound=.2, plot=True, y_ap=-.426, alpha=.2)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

points, vecs, dists = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig)
fig.show()
#+END_SRC

#+RESULTS:
:RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
np.around(final_point, decimals=10)
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: 
: IndexErrorTraceback (most recent call last)
: <ipython-input-17-5cdcd3c9a546> in <module>
: ----> 1 final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
:       2 final_vec = -1 * csims.normalize(vecs[0][0][-1])
:       3 np.around(final_point, decimals=10)
: 
: IndexError: invalid index to scalar variable.
:END:

#+begin_src jupyter-python :session py :kernel python3
final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
np.around(final_point, decimals=10)
#+end_src

#+RESULTS:
: array([223.34284917, 234.10097961,   0.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays
#+END_SRC

#+RESULTS:
: [[0.123,
:   1,
:   array([ 1.02817913e-16, -4.26000000e-01,  1.93499098e+00]),
:   array([5.49278019e-18, 9.91898230e-01, 1.27035040e-01]),
:   0]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(csims.normalize(final_vec), decimals=6)
#+END_SRC

#+RESULTS:
: array([-0.1045  , -0.994525,  0.      ])


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

final_point = points[0][0][-1] + dists[0][0][-1] * csims.normalize(vecs[0][0][-1])
final_vec = -1 * csims.normalize(vecs[0][0][-1])
starting_rays = [[.123, 1.0, final_point, final_vec, 0]]

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=-20.9, plot=True,
                                         fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

* Now run some rays in reverse and see how they line up

#+BEGIN_SRC jupyter-python :session py :kernel python3
mm_to_in = 1 / 25.4
shift = [0, 0, 0]
start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

# fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.25, plot=False, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

rays, path_diffs
 = transform_rays_end_tilt_path_diffs(
    start_rays_mcmahon, config, plot=False, plot_mirror_position=5, fig=fig, ray_alpha=.05)
# fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 88
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 88
: total number of rays making past the first ellipse = 80
: total number of rays making it all the way through = 80

#+BEGIN_SRC jupyter-python :session py :kernel python3
path_diffs
#+END_SRC

#+RESULTS:
#+begin_example
[[[935.6216455277413,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   246.26768649331734,
   0.0,
   247.82387484882474,
   241.54336137644714,
   240.22808473828127,
   233.8678023778366,
   235.89427916329117],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   245.1799988301318,
   0.0,
   245.95973392534142,
   240.6375808343173,
   239.99405954860413,
   235.38274383981798,
   236.1436799783266],
  [936.906393858963,
   272.9466401116455,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   244.3624512422191,
   0.0,
   244.64001259794668,
   239.4793969609159,
   239.2726457013814,
   236.63463128490457,
   236.87202221613174],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   243.58618616951412,
   0.0,
   243.6155143981373,
   238.28198429987606,
   238.2714101138754,
   237.64025227671846,
   237.8755373453394],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   242.70058829260142,
   0.0,
   242.7241385317684,
   237.1812373836283,
   237.1338653884095,
   238.4590703384997,
   239.0224249077148],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   241.60410307508891,
   0.0,
   241.87132475713588,
   236.26576044890453,
   235.94443018435413,
   239.1876224313246,
   240.22645616380262],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   240.23811465258154,
   0.0,
   241.01630003738728,
   235.5832462012354,
   234.73268814242056,
   239.96520418203772,
   241.44471213491815],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   238.5903354059344,
   0.0,
   240.15355534174023,
   235.13489530285278,
   233.48247342246714,
   241.0026409952061,
   242.68977745797318],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   239.57944089455123,
   12.570095283695537,
   241.4915786814786,
   241.35689717938249,
   240.0312580121008,
   234.07629180357344,
   236.09312625455073],
  [936.4332783600396,
   274.04272948648554,
   236.1447822578973,
   235.94194917096615,
   235.17975505584627,
   240.0642350689236,
   9.763416556840639,
   241.02144290309798,
   240.4879709288125,
   239.83807792268726,
   235.51809699978912,
   236.30053868193724],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   241.16630414391147,
   6.16619156734032,
   241.50628125346566,
   239.38334595318747,
   239.17308284740238,
   236.71070741831045,
   236.97212692441548],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   242.50293212115184,
   2.106531188841018,
   242.53900320199136,
   238.24887905496007,
   238.2371882827747,
   237.66484708890448,
   237.9100059619104],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   241.67076945164763,
   2.1064346521538937,
   241.7014548701577,
   237.21451589792196,
   237.16824647966178,
   238.43428366380977,
   238.98772717310467],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   238.57404580543812,
   6.165645260490692,
   238.9054109572685,
   236.36353152900165,
   236.04559865245392,
   239.10971633291774,
   240.12424899060443],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   235.41823590398553,
   9.76345531278821,
   236.37840472169182,
   235.73852391110495,
   234.89407400721575,
   239.82412745639658,
   241.28181830237992],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   232.35881094371803,
   12.573454449061956,
   234.28710444453282,
   235.33510778700474,
   233.69262828206593,
   240.7806677360545,
   242.4786825880354],
  [938.0643732746073, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   232.9231142033202,
   23.674498495983244,
   235.74231741369113,
   240.81770532592782,
   239.4622880977813,
   234.6788662382587,
   236.66774885549825],
  [936.4332780210191,
   273.57365694793657,
   236.55859139660538,
   236.41055303424105,
   235.64489139897955,
   235.11792893243978,
   18.365312086416907,
   236.5264618112542,
   240.05623858782474,
   239.38804180717807,
   235.9087884220421,
   236.75321295337002],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   238.1381779340186,
   11.591755311418183,
   238.63650631321616,
   239.10648737639576,
   238.88613183451298,
   236.93006875186302,
   237.2607246976096],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   241.49144227121656,
   3.9590811399607446,
   241.5445413097823,
   238.15352651110925,
   238.13862308178886,
   237.73569798805056,
   238.0092938903048],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   240.81304740806468,
   3.958934404574393,
   240.8618465842328,
   237.3103071731016,
   237.26721493960122,
   238.36294695395918,
   238.88785909873647],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   236.02400007117853,
   11.591009760346424,
   236.51758970883975,
   236.6447453182659,
   236.33661507819534,
   238.88572152824872,
   239.8303276793652],
  [936.4332750298576,
   269.36269484321554,
   240.27344035461806,
   240.62656972661398,
   239.829295561251,
   231.32572569770173,
   18.366026281529685,
   232.74582388891758,
   236.1846065187642,
   235.3577931815562,
   239.41894446581773,
   240.8138630161272],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.52560475656333,
   239.9261427976728,
   227.0249154393582,
   23.681844738090604,
   229.87717349459172,
   235.90910813571782,
   234.29534366814505,
   240.14395354848102,
   241.8730475719058],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0643805775521, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.4702940954569,
   227.24774807106223,
   31.975574008392414,
   231.11096537557432,
   239.9849724772057,
   238.58411105082178,
   235.6085970458803,
   237.5541010068037],
  [936.4332775016093,
   272.8517986847595,
   237.19540442592688,
   237.13209370330242,
   236.3610748763747,
   231.010809939228,
   24.768539625624726,
   232.936997643812,
   239.39203839085667,
   238.69592348696415,
   236.51013835835374,
   237.44969625032095],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   235.6692564035759,
   15.622285525746975,
   236.34828783402054,
   238.68147416780312,
   238.4457125073609,
   237.2670437484153,
   237.70391610697294],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   240.67659747225252,
   5.334196659875488,
   240.7488982095506,
   238.00735200354256,
   237.9875334835765,
   237.84434295618894,
   238.1615257151282],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   240.23379030930505,
   5.334068790470155,
   240.30335174627453,
   237.45698058380503,
   237.41876310365342,
   238.25374954612244,
   238.73496755845977],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   234.28854589610592,
   15.621721437275028,
   234.9661809149511,
   237.07471080663845,
   236.78165716997592,
   238.54347782659397,
   239.38108272271216],
  [936.4332755492673,
   270.1033841306013,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   228.53192415191643,
   24.769824793565476,
   230.4724913326154,
   236.86512328974277,
   236.0654696396159,
   238.80111708334607,
   240.10000360619537],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   223.38881658611513,
   31.984252909924635,
   227.2885689470495,
   236.78141784020136,
   235.21189021323107,
   239.17540482333925,
   240.95142949318998],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   223.43623004521714,
   36.42261276200952,
   227.99491604354807,
   238.95236634467346,
   237.49607155464946,
   236.75999534741004,
   238.65133769950734],
  [936.433276864459,
   271.96098291889666,
   237.98126919595757,
   238.02319244782484,
   237.24552732565257,
   228.3316479765831,
   28.184852900239548,
   230.60108551313942,
   238.57268659184547,
   237.84253522990548,
   237.25243929721682,
   238.30896901879615],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   234.08882751231295,
   17.768481239913854,
   234.88630526932275,
   238.15871732654068,
   237.90415092267858,
   237.68189409585466,
   238.2492895104939],
  [937.1253739307541,
   271.22120400517963,
   238.0072055539565,
   237.989396791824,
   237.9592926155624,
   240.1600203724031,
   6.065907652091482,
   240.24446247631977,
   237.82790000087516,
   237.80206378551657,
   237.9777733785386,
   238.34845430563365],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051877,
   240.00623060550015,
   6.065857453505487,
   240.08973660388438,
   237.6367582202315,
   237.6045321074007,
   238.11995854657835,
   238.54760837054025],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   233.60912776941495,
   17.76828208238112,
   234.40650573547964,
   237.60069985532618,
   237.3262359051755,
   238.12518873904492,
   238.83175823683115],
  [936.4332761864177,
   271.00649026687665,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   227.46987448145933,
   28.185530361695328,
   229.74586202055661,
   237.69512385862527,
   236.92901179579985,
   238.04806226393112,
   239.22938985406023],
  [935.621642146249,
   271.4048152058127,
   239.53528663123097,
   239.39414406227706,
   237.82043034027447,
   222.09388690727792,
   36.4266166031116,
   226.66869304421925,
   237.839852542299,
   236.3249710745672,
   237.99867243844346,
   239.8311746556291],
  [935.6216421462492,
   271.4048152058125,
   239.5352866312312,
   239.39414406227706,
   237.82043034027424,
   222.09388690727747,
   36.42661660311205,
   226.66869304421925,
   237.83985254229947,
   236.32497107456766,
   237.99867243844346,
   239.83117465562904],
  [936.4332761864177,
   271.0064902668769,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   227.46987448145956,
   28.185530361694873,
   229.74586202055661,
   237.69512385862572,
   236.92901179579985,
   238.04806226393112,
   239.22938985406023],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   233.60912776941495,
   17.76828208238112,
   234.40650573547964,
   237.60069985532618,
   237.3262359051755,
   238.12518873904492,
   238.83175823683115],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051877,
   240.00623060550015,
   6.065857453505487,
   240.08973660388438,
   237.6367582202315,
   237.6045321074007,
   238.11995854657835,
   238.54760837054025],
  [937.1253739307541,
   271.22120400517963,
   238.0072055539565,
   237.989396791824,
   237.9592926155624,
   240.1600203724031,
   6.065907652091482,
   240.24446247631977,
   237.82790000087516,
   237.80206378551657,
   237.9777733785386,
   238.34845430563365],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   234.08882751231295,
   17.768481239913854,
   234.8863052693232,
   238.15871732654068,
   237.90415092267858,
   237.68189409585466,
   238.2492895104939],
  [936.4332768644591,
   271.96098291889655,
   237.9812691959578,
   238.02319244782484,
   237.24552732565257,
   228.33164797658287,
   28.184852900239548,
   230.60108551313942,
   238.57268659184547,
   237.84253522990548,
   237.25243929721682,
   238.30896901879615],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   223.43623004521714,
   36.42261276200952,
   227.99491604354807,
   238.95236634467346,
   237.49607155464946,
   236.75999534741004,
   238.65133769950734],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   223.38881658611513,
   31.984252909924635,
   227.28856894704904,
   236.7814178402009,
   235.21189021323107,
   239.17540482333925,
   240.95142949319],
  [936.4332755492674,
   270.10338413060117,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   228.53192415191643,
   24.769824793565476,
   230.4724913326154,
   236.86512328974277,
   236.0654696396159,
   238.80111708334607,
   240.10000360619537],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   234.28854589610592,
   15.621721437275028,
   234.9661809149511,
   237.07471080663845,
   236.78165716997592,
   238.54347782659397,
   239.38108272271216],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   240.23379030930505,
   5.334068790470155,
   240.30335174627453,
   237.45698058380503,
   237.41876310365342,
   238.25374954612244,
   238.73496755845977],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   240.67659747225252,
   5.334196659875488,
   240.7488982095506,
   238.00735200354256,
   237.9875334835765,
   237.84434295618894,
   238.1615257151282],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   235.6692564035759,
   15.622285525746975,
   236.34828783402054,
   238.68147416780312,
   238.4457125073609,
   237.2670437484153,
   237.70391610697294],
  [936.4332775016095,
   272.8517986847595,
   237.1954044259271,
   237.13209370330242,
   236.36107487637446,
   231.01080993922778,
   24.768539625624726,
   232.936997643812,
   239.39203839085667,
   238.69592348696415,
   236.51013835835374,
   237.44969625032095],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.47029409545667,
   227.247748071062,
   31.975574008392414,
   231.11096537557432,
   239.9849724772057,
   238.58411105082178,
   235.60859704587983,
   237.5541010068037],
  [938.0643805775524, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.5256047565631,
   239.9261427976728,
   227.02491543935844,
   23.68184473809015,
   229.87717349459172,
   235.90910813571782,
   234.29534366814505,
   240.14395354848102,
   241.87304757190577],
  [936.4332750298578,
   269.36269484321554,
   240.27344035461806,
   240.6265697266142,
   239.829295561251,
   231.32572569770173,
   18.366026281529685,
   232.74582388891758,
   236.1846065187642,
   235.3577931815562,
   239.41894446581773,
   240.81386301612716],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   236.02400007117853,
   11.591009760346424,
   236.51758970883975,
   236.6447453182659,
   236.33661507819534,
   238.88572152824872,
   239.83032767936515],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   240.81304740806468,
   3.958934404574393,
   240.8618465842328,
   237.3103071731016,
   237.26721493960122,
   238.36294695395918,
   238.88785909873647],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   241.49144227121656,
   3.9590811399607446,
   241.5445413097823,
   238.15352651110925,
   238.13862308178886,
   237.73569798805056,
   238.0092938903048],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   238.1381779340186,
   11.591755311417728,
   238.63650631321616,
   239.10648737639576,
   238.88613183451298,
   236.93006875186302,
   237.26072469760962],
  [936.4332780210193,
   273.57365694793657,
   236.55859139660538,
   236.41055303424082,
   235.64489139897955,
   235.11792893243978,
   18.365312086416907,
   236.5264618112542,
   240.05623858782474,
   239.38804180717807,
   235.9087884220421,
   236.75321295337002],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   232.9231142033202,
   23.674498495983244,
   235.74231741369113,
   240.81770532592827,
   239.4622880977813,
   234.6788662382587,
   236.6677488554982],
  [938.0643732746074, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   232.35881094371803,
   12.573454449061956,
   234.28710444453282,
   235.33510778700474,
   233.69262828206593,
   240.7806677360545,
   242.4786825880354],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   235.41823590398553,
   9.76345531278821,
   236.37840472169182,
   235.73852391110495,
   234.89407400721575,
   239.82412745639658,
   241.28181830237992],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   238.57404580543812,
   6.165645260490692,
   238.9054109572685,
   236.36353152900165,
   236.04559865245392,
   239.10971633291774,
   240.12424899060446],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   241.67076945164763,
   2.1064346521538937,
   241.7014548701577,
   237.21451589792196,
   237.16824647966178,
   238.43428366380977,
   238.98772717310467],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   242.50293212115184,
   2.106531188841018,
   242.53900320199136,
   238.24887905496007,
   238.2371882827747,
   237.66484708890448,
   237.9100059619104],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   241.16630414391147,
   6.16619156734032,
   241.50628125346566,
   239.38334595318747,
   239.17308284740238,
   236.71070741831045,
   236.97212692441548],
  [936.4332783600397,
   274.0427294864854,
   236.14478225789753,
   235.94194917096615,
   235.17975505584627,
   240.06423506892384,
   9.763416556840639,
   241.02144290309798,
   240.4879709288125,
   239.83807792268726,
   235.51809699978912,
   236.30053868193724],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   239.57944089455123,
   12.570095283695537,
   241.4915786814786,
   241.35689717938249,
   240.0312580121008,
   234.07629180357344,
   236.09312625455073],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   238.5903354059344,
   0.0,
   240.15355534174023,
   235.13489530285278,
   233.48247342246714,
   241.0026409952061,
   242.68977745797318],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   240.23811465258154,
   0.0,
   241.01630003738728,
   235.5832462012354,
   234.73268814242056,
   239.96520418203772,
   241.44471213491818],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   241.60410307508891,
   0.0,
   241.87132475713588,
   236.26576044890453,
   235.94443018435413,
   239.1876224313246,
   240.22645616380262],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   242.70058829260142,
   0.0,
   242.7241385317684,
   237.1812373836283,
   237.1338653884095,
   238.4590703384997,
   239.0224249077148],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   243.58618616951412,
   0.0,
   243.6155143981373,
   238.28198429987606,
   238.2714101138754,
   237.64025227671846,
   237.8755373453394],
  [936.9063938589629,
   272.9466401116456,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   244.3624512422191,
   0.0,
   244.64001259794668,
   239.4793969609159,
   239.2726457013814,
   236.63463128490457,
   236.87202221613174],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   245.1799988301318,
   0.0,
   245.95973392534142,
   240.6375808343173,
   239.99405954860413,
   235.38274383981798,
   236.1436799783266],
  [935.6216455277415,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   246.26768649331711,
   0.0,
   247.82387484882474,
   241.54336137644714,
   240.22808473828127,
   233.8678023778366,
   235.89427916329117]],
 [[935.6216455277413,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   235.88823782263762,
   0.0,
   237.45966274818556,
   243.07168291653943,
   241.25590613050917,
   233.3791431011482,
   234.8727964703897],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   234.87933581183233,
   0.0,
   235.6404963467594,
   241.87302325770543,
   240.94748551916746,
   235.0684536924573,
   235.2253643842697],
  [936.906393858963,
   272.9466401116455,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   234.11707811557858,
   0.0,
   234.3752333031798,
   240.48380947090754,
   240.13814469560748,
   236.46349891602586,
   236.0362026998687],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   233.38365809236325,
   0.0,
   233.40582580081445,
   239.09516181355139,
   239.04507961724403,
   237.58839666662107,
   237.11245137544418],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   232.53514267341507,
   0.0,
   232.56503935018145,
   237.82842390738597,
   237.815805406648,
   238.50574901684377,
   238.3308390901435],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   231.4741171334308,
   0.0,
   231.7546953071178,
   236.76293724289053,
   236.53561123234067,
   239.31180789943164,
   239.6127889605859],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   230.14410194511424,
   0.0,
   230.93175016845498,
   235.94138188446595,
   235.23184433834604,
   240.1420626308195,
   240.92284645669193],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   228.5328532350561,
   0.0,
   230.09085727780848,
   235.36367014656753,
   233.88082524302354,
   241.19881162988713,
   242.28189858238184],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   228.90747650972844,
   13.15740746820211,
   230.85081775221124,
   242.84612323986676,
   241.04061931013803,
   233.60805039296747,
   235.08925871776046],
  [936.4332783600396,
   274.04272948648554,
   236.1447822578973,
   235.94194917096615,
   235.17975505584627,
   229.57899161619025,
   10.137917680373448,
   230.5253161510891,
   241.69693791234977,
   240.77812253167167,
   235.21866649721096,
   235.39366348930756],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   230.81906594295515,
   6.3746344394739936,
   231.14277187167,
   240.37244328074712,
   240.0304342441127,
   236.54853786199556,
   236.14280570502964],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   232.26789773242444,
   2.1735453861278984,
   232.2974393505756,
   239.0570485059584,
   239.0081060961138,
   237.61597134934163,
   237.14905273229775],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   231.4704812676964,
   2.1736465385542942,
   231.50733167927365,
   237.86670482370846,
   237.8529667876478,
   238.4779999484308,
   238.29396183300184],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   228.33448787026987,
   6.375530440637704,
   228.68042129141986,
   236.87598233775634,
   236.64517609446057,
   239.225056725973,
   239.50367510345563],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   225.1260315457621,
   10.140038787270896,
   226.10187218811598,
   236.12308457577774,
   235.40724905859634,
   239.98623218526882,
   240.74744844283092],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   221.99017834898655,
   13.158803098869157,
   223.93084018530453,
   235.6031237446673,
   234.11049930143827,
   240.95595936193968,
   242.05131460664646],
  [938.0643732746073, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   221.99805297951275,
   24.780271811091097,
   224.8889212780491,
   242.19431788901966,
   240.41832041933503,
   234.26949760838852,
   235.71488037782424],
  [936.4332780210191,
   273.57365694793657,
   236.55859139660538,
   236.41055303424105,
   235.64489139897955,
   224.47641122922346,
   19.070122017440553,
   225.89391721579295,
   241.18897763610266,
   240.28944779145831,
   235.65212938119112,
   235.87944656684328],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   227.70627502497973,
   11.983857867960523,
   228.19663239916554,
   240.0514931265934,
   239.71998024954019,
   236.79368710968492,
   236.4501817933906],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   231.2298453319861,
   4.08506456389614,
   231.27815494375136,
   238.9472767950424,
   238.9016127605837,
   237.69539944899452,
   237.2544896281808],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   230.57970275762614,
   4.085220751967427,
   230.63406538962,
   237.9769009330289,
   237.9599357990387,
   238.39813029064135,
   238.18782633624014],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   225.6793041515641,
   11.985325792469666,
   226.1901720522742,
   237.2011834923851,
   236.96032546841752,
   238.9755721094307,
   239.18994156264455],
  [936.4332750298576,
   269.36269484321554,
   240.27344035461806,
   240.62656972661398,
   239.829295561251,
   220.84059188961191,
   19.074054603740024,
   222.2917430683865,
   236.6452675930459,
   235.91122099074573,
   239.5385458520973,
   240.2436920402105],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.52560475656333,
   239.9261427976728,
   216.3473728179183,
   24.784705335608123,
   219.25674170076127,
   236.29010750800762,
   234.7692250903956,
   240.2592049431355,
   241.3899407700527],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0643805775521, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.4702940954569,
   216.1469549786193,
   33.4683042571105,
   220.1276723844653,
   241.18893726072702,
   239.45792956666628,
   235.28966147317578,
   236.68019143601134],
  [936.4332775016093,
   272.8517986847595,
   237.19540442592688,
   237.13209370330242,
   236.3610748763747,
   220.26313027204856,
   25.71983374936326,
   222.22203515715546,
   240.4080058800073,
   239.5378180387993,
   236.31896362625776,
   236.62714631453093],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   225.1810047931092,
   16.15124770369721,
   225.86267274464763,
   239.5589472964407,
   239.24342855996338,
   237.1701148979605,
   236.92233868131555],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   230.3976790569459,
   5.504010069802007,
   230.46763390285423,
   238.77901365262005,
   238.73836227313404,
   237.81717680652218,
   237.41616528622157],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   229.97327628055632,
   5.504148632982833,
   230.04725235824208,
   238.14564668037883,
   238.12372720158828,
   238.2758508150996,
   238.02535626412214],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   223.85692029883512,
   16.152633848092137,
   224.5537529350736,
   237.69856314590606,
   237.44221627961497,
   238.59421457131566,
   238.71055567841748],
  [936.4332755492673,
   270.1033841306013,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   217.88577197470977,
   25.72397726017789,
   219.87379013313193,
   237.44241132353454,
   236.68024430456717,
   238.85553889415905,
   239.47555681727692],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   212.44954862897453,
   33.47451820838023,
   216.45790441677536,
   237.33548766356625,
   235.7710340882095,
   239.19889593792732,
   240.38398305614908],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   212.26804604988547,
   38.12187874512847,
   216.97314858856043,
   239.94438142843,
   238.26818713848888,
   236.55237770544954,
   237.87570674955293],
  [936.433276864459,
   271.96098291889666,
   237.98126919595757,
   238.02319244782484,
   237.24552732565257,
   217.54463721996262,
   29.26840075464179,
   219.86468461861705,
   239.4454444977414,
   238.61090699406486,
   237.14151371613661,
   237.55007880896787],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   223.5805405251872,
   18.37084273290202,
   224.39014043576753,
   238.95338235316376,
   238.65733923391463,
   237.63326645051575,
   237.50357135972328],
  [937.1253739307541,
   271.22120400517963,
   238.00720555395674,
   237.98939679182422,
   237.95929261556216,
   229.87523314824784,
   6.25911533055114,
   229.95995786732828,
   238.5724705842963,
   238.53795142156105,
   237.9667021491955,
   237.61471676167946],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051855,
   229.72782843685104,
   6.259170366313356,
   229.81396567674892,
   238.35250474490113,
   238.32449110839207,
   238.12599774010414,
   237.82628627487517],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   223.12045042663794,
   18.371414746108712,
   223.9357204947869,
   238.3072830078545,
   238.03179031667014,
   238.127845496399,
   238.1246048556388],
  [936.4332761864177,
   271.00649026687665,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   216.71801434917438,
   29.27021433794016,
   219.0498020922846,
   238.41552733437265,
   237.61850717788002,
   238.0224337320078,
   238.5392877556587],
  [935.621642146249,
   271.4048152058127,
   239.53528663123097,
   239.39414406227706,
   237.82043034027447,
   210.9817743144481,
   38.12493415995232,
   215.70004568947024,
   238.60614910206868,
   236.9878074240146,
   237.90997954005707,
   239.16194281035163],
  [935.6216421462492,
   271.4048152058125,
   239.5352866312312,
   239.39414406227706,
   237.82043034027424,
   210.9817743144481,
   38.12493415995232,
   215.70004568947024,
   238.60614910206868,
   236.9878074240146,
   237.90997954005707,
   239.16194281035166],
  [936.4332761864177,
   271.0064902668769,
   238.8233086073776,
   238.97881634229657,
   238.19398652231644,
   216.71801434917415,
   29.270214337939706,
   219.0498020922846,
   238.41552733437265,
   237.61850717788047,
   238.0224337320078,
   238.5392877556587],
  [936.9063925266629,
   270.922965648111,
   238.40637054124727,
   238.54235705591873,
   238.2665175757029,
   223.12045042663794,
   18.371414746108712,
   223.9357204947869,
   238.3072830078545,
   238.03179031667014,
   238.127845496399,
   238.1246048556388],
  [937.1253738012615,
   271.0158375952078,
   238.1577683257583,
   238.19478625347074,
   238.16461356051855,
   229.72782843685104,
   6.259170366313356,
   229.81396567674892,
   238.35250474490113,
   238.32449110839207,
   238.12599774010414,
   237.82628627487517],
  [937.1253739307541,
   271.22120400517963,
   238.00720555395674,
   237.98939679182422,
   237.95929261556216,
   229.87523314824784,
   6.25911533055114,
   229.95995786732828,
   238.5724705842963,
   238.53795142156105,
   237.9667021491955,
   237.61471676167946],
  [936.9063929209063,
   271.52459856644066,
   237.9372619545693,
   237.940244359708,
   237.66617270471147,
   223.5805405251872,
   18.37084273290202,
   224.39014043576753,
   238.95338235316376,
   238.65733923391463,
   237.63326645051575,
   237.50357135972328],
  [936.4332768644591,
   271.96098291889655,
   237.9812691959578,
   238.02319244782484,
   237.24552732565257,
   217.5446372199624,
   29.26840075464179,
   219.86468461861705,
   239.4454444977414,
   238.61090699406486,
   237.14151371613616,
   237.55007880896787],
  [935.6216431468727,
   272.63862124742195,
   238.2207672987745,
   238.16191807251425,
   236.60300997729678,
   212.26804604988547,
   38.12187874512847,
   216.97314858856043,
   239.94438142843046,
   238.26818713848888,
   236.55237770544954,
   237.87570674955296],
  [938.064408027612, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216412059706,
   270.2329425010513,
   240.7838209147185,
   240.56370419787572,
   238.97588369398522,
   212.44954862897453,
   33.47451820838023,
   216.45790441677536,
   237.33548766356625,
   235.7710340882095,
   239.19889593792732,
   240.38398305614908],
  [936.4332755492674,
   270.10338413060117,
   239.62001541050154,
   239.88378207281016,
   239.09213186416855,
   217.88577197470977,
   25.72397726017789,
   219.87379013313193,
   237.4424113235341,
   236.68024430456717,
   238.85553889415905,
   239.47555681727692],
  [936.9063921561954,
   270.35544951545603,
   238.84887730782884,
   239.11087447565092,
   238.83335924621838,
   223.85692029883512,
   16.152633848092137,
   224.5537529350736,
   237.69856314590606,
   237.44221627961497,
   238.59421457131566,
   238.71055567841748],
  [937.125373679579,
   270.82261935661916,
   238.29942476080532,
   238.38810103811488,
   238.35786375612088,
   229.97327628055632,
   5.504148632982833,
   230.04725235824208,
   238.14564668037883,
   238.12372720158828,
   238.2758508150996,
   238.02535626412214],
  [937.1253740524369,
   271.41394879766654,
   237.86589622172778,
   237.79670492547848,
   237.7666649302205,
   230.3976790569459,
   5.504010069802007,
   230.46763390285423,
   238.77901365262005,
   238.73836227313404,
   237.81717680652218,
   237.41616528622157],
  [936.9063932913739,
   272.0877947118861,
   237.49812341595066,
   237.37714117235032,
   237.10471635121849,
   225.1810047931092,
   16.15124770369721,
   225.86267274464763,
   239.5589472964407,
   239.24342855996338,
   237.1701148979605,
   236.92233868131555],
  [936.4332775016095,
   272.8517986847595,
   237.1954044259271,
   237.13209370330242,
   236.36107487637446,
   220.26313027204878,
   25.71983374936326,
   222.22203515715591,
   240.4080058800073,
   239.5378180387993,
   236.31896362625776,
   236.6271463145309],
  [935.621644087151,
   273.7857415122237,
   236.99860442387262,
   237.015480016046,
   235.47029409545667,
   216.14695497861908,
   33.46830425711096,
   220.12767238446486,
   241.18893726072702,
   239.45792956666628,
   235.28966147317578,
   236.68019143601137],
  [938.0643805775524, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [938.0644153305461, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216404394481,
   269.268545757732,
   241.81130646180168,
   241.5256047565631,
   239.9261427976728,
   216.34737281791809,
   24.78470533560767,
   219.25674170076127,
   236.29010750800762,
   234.7692250903956,
   240.2592049431355,
   241.38994077005276],
  [936.4332750298578,
   269.36269484321554,
   240.27344035461806,
   240.6265697266142,
   239.829295561251,
   220.84059188961191,
   19.074054603740024,
   222.29174306838604,
   236.6452675930459,
   235.91122099074573,
   239.5385458520973,
   240.2436920402105],
  [936.9063918541875,
   269.89124496283637,
   239.21082934265746,
   239.57629441366498,
   239.29740257162166,
   225.6793041515641,
   11.985325792469666,
   226.1901720522742,
   237.2011834923851,
   236.96032546841752,
   238.9755721094307,
   239.18994156264455],
  [937.1253735803821,
   270.6649362574376,
   238.41502888713512,
   238.545916726506,
   238.51562664396806,
   230.57970275762614,
   4.085220751967427,
   230.63406538962,
   237.9769009330289,
   237.9599357990387,
   238.39813029064135,
   238.18782633624014],
  [937.1253741516337,
   271.57090653399814,
   237.75082388874966,
   237.63984360614154,
   237.6098557862722,
   231.2298453319861,
   4.08506456389614,
   231.27815494375136,
   238.9472767950424,
   238.9016127605837,
   237.69539944899452,
   237.2544896281808],
  [936.9063935933816,
   272.5453805415966,
   237.1413318981363,
   236.92001654153592,
   236.64892402943406,
   227.70627502497973,
   11.983857867960523,
   228.19663239916554,
   240.0514931265934,
   239.71998024954019,
   236.79368710968492,
   236.4501817933906],
  [936.4332780210193,
   273.57365694793657,
   236.55859139660538,
   236.41055303424082,
   235.64489139897955,
   224.47641122922346,
   19.070122017440553,
   225.89391721579295,
   241.18897763610266,
   240.28944779145831,
   235.65212938119112,
   235.87944656684328],
  [935.6216448536732,
   274.71221001633535,
   236.01152786624107,
   236.0890088316694,
   234.55487501393054,
   221.99805297951275,
   24.780271811091097,
   224.8889212780491,
   242.19431788901966,
   240.41832041933503,
   234.26949760838852,
   235.71488037782424],
  [938.0643732746074, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238],
  [935.6216399391368,
   268.6346287356081,
   242.48669294509818,
   242.15758942400066,
   240.5504595305208,
   221.99017834898655,
   13.158803098869157,
   223.93084018530453,
   235.6031237446673,
   234.11049930143827,
   240.95595936193968,
   242.05131460664646],
  [936.4332746908368,
   268.87706149550684,
   240.7018587225043,
   241.11385940448486,
   240.3128830912558,
   225.1260315457621,
   10.140038787270896,
   226.10187218811598,
   236.12308457577774,
   235.40724905859588,
   239.98623218526882,
   240.74744844283092],
  [936.9063916570526,
   269.5874973439238,
   239.447669014937,
   239.88103048448147,
   239.60123497821974,
   228.33448787026987,
   6.375530440637704,
   228.68042129141986,
   236.87598233775634,
   236.64517609446057,
   239.225056725973,
   239.5036751034556],
  [937.1253735156359,
   270.56193337981324,
   238.49054463819084,
   238.6490323295634,
   238.6187077124555,
   231.4704812676964,
   2.1736465385542942,
   231.50733167927365,
   237.86670482370846,
   237.8529667876478,
   238.4779999484308,
   238.29396183300184],
  [937.1253742163799,
   271.6732715368987,
   237.6757757899004,
   237.5375672639973,
   237.5076134289411,
   232.26789773242444,
   2.1735453861278984,
   232.2974393505756,
   239.0570485059584,
   239.0081060961138,
   237.61597134934163,
   237.14905273229775],
  [936.906393790503,
   272.84330763474554,
   236.9090304007459,
   236.62257546340516,
   236.35234765291398,
   230.81906594295515,
   6.3746344394739936,
   231.14277187167,
   240.37244328074712,
   240.0304342441127,
   236.54853786199556,
   236.14280570502964],
  [936.4332783600397,
   274.0427294864854,
   236.14478225789753,
   235.94194917096615,
   235.17975505584627,
   229.57899161619002,
   10.137917680373448,
   230.5253161510891,
   241.69693791234977,
   240.77812253167167,
   235.21866649721096,
   235.39366348930756],
  [935.6216453539851,
   275.3127682024874,
   235.371682100548,
   235.48818452775322,
   233.96120027736038,
   228.90747650972844,
   13.15740746820211,
   230.85081775221124,
   242.84612323986676,
   241.04061931013803,
   233.60805039296747,
   235.08925871776046],
  [935.62163976538,
   268.41364239108566,
   242.7221357211672,
   242.3778477872329,
   240.76804188439155,
   228.5328532350561,
   0.0,
   230.09085727780848,
   235.36367014656753,
   233.88082524302354,
   241.19881162988713,
   242.28189858238184],
  [936.4332745730961,
   268.70799737566006,
   240.85100451083736,
   241.28355230335592,
   240.48128440144615,
   230.14410194511424,
   0.0,
   230.93175016845498,
   235.94138188446595,
   235.2318443383465,
   240.1420626308195,
   240.92284645669196],
  [936.9063915885927,
   269.48186613132157,
   239.5300323272386,
   239.987041267397,
   239.7069309659953,
   231.4741171334308,
   0.0,
   231.7546953071178,
   236.76293724289053,
   236.53561123234067,
   239.31180789943164,
   239.6127889605859],
  [937.1253734931498,
   270.5261455883814,
   238.51678217649305,
   238.6848641183501,
   238.6545274942805,
   232.53514267341507,
   0.0,
   232.56503935018145,
   237.82842390738597,
   237.815805406648,
   238.50574901684377,
   238.3308390901435],
  [937.1253742388658,
   271.7088074115827,
   237.64972294213158,
   237.50206692596635,
   237.47212488075456,
   233.38365809236325,
   0.0,
   233.40582580081445,
   239.09516181355139,
   239.04507961724403,
   237.58839666662107,
   237.11245137544418],
  [936.9063938589629,
   272.9466401116456,
   236.82845937749744,
   236.51944575532275,
   236.24951735174227,
   234.11707811557858,
   0.0,
   234.3752333031798,
   240.48380947090754,
   240.13814469560748,
   236.46349891602586,
   236.0362026998687],
  [936.4332784777806,
   274.20525295245204,
   236.00140635133994,
   235.77963627099257,
   235.01864107290976,
   234.87933581183233,
   0.0,
   235.6404963467594,
   241.87302325770543,
   240.94748551916746,
   235.0684536924573,
   235.2253643842697],
  [935.6216455277415,
   275.5205787467628,
   235.15027690640864,
   235.280233460393,
   233.7557204744537,
   235.88823782263785,
   0.0,
   237.45966274818602,
   243.07168291653988,
   241.25590613050917,
   233.3791431011482,
   234.87279647038974]]]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / ((np.array([np.sum(i) for i in path_diffs[0]]) - np.array([np.sum(i) for i in path_diffs[1]])) / (4 * 5))
#+END_SRC

#+RESULTS:
:RESULTS:
: <ipython-input-40-83392a12912a>:1: RuntimeWarning:
: 
: divide by zero encountered in true_divide
: 
#+begin_example
array([1.01534904, 1.01710579, 1.01795713, 1.0183138 , 1.01831307,
       1.01792882, 1.01696925, 1.01498309, 1.01528333, 1.01707862,
       1.01794915, 1.01831305, 1.01831235, 1.01792217, 1.01694832,
       1.01493283,        inf, 1.01511113, 1.01700779, 1.01792854,
       1.01831113, 1.01831053, 1.01790575, 1.01689743, 1.01481176,
              inf,        inf, 1.0148978 , 1.01692102, 1.01790383,
       1.01830892, 1.0183085 , 1.01788837, 1.01684592, 1.0146923 ,
              inf, 1.01472347, 1.01685178, 1.01788512, 1.0183074 ,
       1.01830725, 1.01787962, 1.016825  , 1.01464981, 1.01464981,
       1.016825  , 1.01787962, 1.01830725, 1.0183074 , 1.01788512,
       1.01685178, 1.01472347,        inf, 1.0146923 , 1.01684592,
       1.01788837, 1.0183085 , 1.01830892, 1.01790383, 1.01692102,
       1.0148978 ,        inf,        inf, 1.01481176, 1.01689743,
       1.01790575, 1.01831053, 1.01831113, 1.01792854, 1.01700779,
       1.01511113,        inf, 1.01493283, 1.01694832, 1.01792217,
       1.01831235, 1.01831305, 1.01794915, 1.01707862, 1.01528333,
       1.01498309, 1.01696925, 1.01792882, 1.01831307, 1.0183138 ,
       1.01795713, 1.01710579, 1.01534904])
#+end_example
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
(((np.array([np.sum(i) for i in path_diffs[0]])) - (np.array([np.sum(i) for i in path_diffs[1]]))))
#+END_SRC

#+RESULTS:
#+begin_example
array([19.69765981, 19.66363794, 19.6471928 , 19.64031124, 19.6403254 ,
       19.64773928, 19.66627793, 19.70476181, 19.69893472, 19.66416318,
       19.64734676, 19.64032575, 19.64033931, 19.64786766, 19.66668283,
       19.70573758,  0.        , 19.70227627, 19.66553276, 19.64774465,
       19.64036272, 19.6403743 , 19.64818452, 19.66766701, 19.70808843,
        0.        ,  0.        , 19.70641768, 19.66721066, 19.64822162,
       19.64040545, 19.64041341, 19.64852002, 19.66866319, 19.71040881,
        0.        , 19.70980339, 19.66854992, 19.64858279, 19.64043471,
       19.64043756, 19.64868898, 19.66906786, 19.71123423, 19.71123423,
       19.66906786, 19.64868898, 19.64043756, 19.64043471, 19.64858279,
       19.66854992, 19.70980339,  0.        , 19.71040881, 19.66866319,
       19.64852002, 19.64041341, 19.64040545, 19.64822162, 19.66721066,
       19.70641768,  0.        ,  0.        , 19.70808843, 19.66766701,
       19.64818452, 19.6403743 , 19.64036272, 19.64774465, 19.66553276,
       19.70227627,  0.        , 19.70573758, 19.66668283, 19.64786766,
       19.64033931, 19.64032575, 19.64734676, 19.66416318, 19.69893472,
       19.70476181, 19.66627793, 19.64773928, 19.6403254 , 19.64031124,
       19.6471928 , 19.66363794, 19.69765981])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
(np.array([np.sum(i) for i in path_diffs[1]]))
#+END_SRC

#+RESULTS:
#+begin_example
array([3341.25588431, 3341.07237414, 3341.06442366, 3341.08866977,
       3341.08869232, 3341.06422006, 3341.07110059, 3341.25222366,
       3341.25523385, 3341.07211021, 3341.06434829, 3341.08866339,
       3341.08868445, 3341.06415334, 3341.07089419, 3341.25172922,
       3318.06437327, 3341.25352895, 3341.07142264, 3341.06415418,
       3341.08864744, 3341.08866435, 3341.06398777, 3341.07039155,
       3341.25053838, 3318.06441533, 3318.06438058, 3341.25141549,
       3341.07058223, 3341.06392362, 3341.08862998, 3341.08864082,
       3341.06380946, 3341.06987973, 3341.24936451, 3318.06440803,
       3341.24968615, 3341.06991536, 3341.0637536 , 3341.08862016,
       3341.08862388, 3341.06371269, 3341.0696647 , 3341.24895143,
       3341.24895143, 3341.0696647 , 3341.06371269, 3341.08862388,
       3341.08862016, 3341.0637536 , 3341.06991536, 3341.24968615,
       3318.06440803, 3341.24936451, 3341.06987973, 3341.06380946,
       3341.08864082, 3341.08862998, 3341.06392362, 3341.07058223,
       3341.25141549, 3318.06438058, 3318.06441533, 3341.25053838,
       3341.07039155, 3341.06398777, 3341.08866435, 3341.08864744,
       3341.06415418, 3341.07142264, 3341.25352895, 3318.06437327,
       3341.25172922, 3341.07089419, 3341.06415334, 3341.08868445,
       3341.08866339, 3341.06434829, 3341.07211021, 3341.25523385,
       3341.25222366, 3341.07110059, 3341.06422006, 3341.08869232,
       3341.08866977, 3341.06442366, 3341.07237414, 3341.25588431])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
mm_to_in = 1 / 25.4
shift = [4, 4, -10]
start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
new_start = np.add(start_position, shift)

fig = go.Figure()

with open("lab_fts_dims_mcmahon.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=20,
                                                      theta_bound=1.5, plot=True, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_ = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [1, 1, 2, 4, 2, 4, 1]
: initial number of rays = 7
: total number of rays making past the first ellipse = 4
: total number of rays making it all the way through = 0
: final ray counts = [1, 1, 2, 4, 2, 4, 1]
: initial number of rays = 7
: total number of rays making past the first ellipse = 4
: total number of rays making it all the way through = 0

#+BEGIN_SRC jupyter-python :session py :kernel python3
def transform_rays_end_tilt_path_diffs(rays, config, plot=False, plot_mirror_position=35, fig=None, 
                                       ray_alpha=None, debug=True):
    #source_point_origin = [-223.58, -233.782 + 15.86, 0]
    #source_point_origin = [-233.28894593, -276.84436351, 0.]
    source_point_origin = LAST_LENS_EDGE#[-231.24377979, -266.21940725, 0.]
    angle = .190161
    for ray in rays:
        new_vec = rotate(ray[3], [0, 0, angle])# .19635 #.253406]) #should actually be 10.89 deg #11.25 degrees now
        ray[2] = np.add(rotate(ray[2], [0, 0, angle]), source_point_origin)
        #ray[2] = np.add(ray[2], source_point_origin)
        ray[3] = new_vec
        #ray[4] = 0
        
    possible_paths = [path for path in get_possible_paths()]
        
    # Now try a bunch of different paths!
    mirror_position = [0, plot_mirror_position, 0]
    if (plot):
        all_points, all_vectors, all_distances= [], [], []
    path_diffs = []
    for path in [possible_paths[1], possible_paths[5]]:
        total_ray_points, total_vectors, total_distances = step_rays(
            rays, config, run_ray_through_sim, config, mirror_position, 
            path, final_dist=238, debug=debug)
        path_diffs.append(total_distances)
        
        if (plot):
            all_points.append(total_ray_points)
            all_vectors.append(total_vectors)
            all_distances.append(total_distances)
    if (plot):
        plot_all_items(config, all_points, all_vectors, all_distances, mirror_position, fig=fig, 
                       ray_alpha=ray_alpha)
    return rays, path_diffs

def calculate_position_snr(shift_position):
    start_position = [0, ((210+82)*mm_to_in + 1.848), -20.9]
    new_start = np.add(start_position, shift_position)

    # fig = go.Figure()

    out = csims.run_rays_through_coupling_optics_reversed(new_start, fts_geo, 'black', fig, n_linear=30,
                                                          theta_bound=.3, plot=False, y_ap=-.426, alpha=.15)
    # fig.show()
    start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

    rays, path_diffs = transform_rays_end_tilt_path_diffs(
        start_rays_mcmahon, config, plot=False, plot_mirror_position=0, fig=fig, ray_alpha=.05, 
        debug=False)
    snr_1 = np.sum([238 not in path_diffs[0][i] for i in range(len(path_diffs[0]))])
    snr_2 = np.sum([238 not in path_diffs[1][i] for i in range(len(path_diffs[1]))])
    return np.mean([snr_1, snr_2])

shift_snr_data = []
for x_shift in np.linspace(-4, 4, 20):
    print(x_shift)
    for y_shift in np.linspace(-4, 4, 20):
        for z_shift in np.append(np.linspace(-10, 8, 4), 0):
            snr = calculate_position_snr([x_shift, y_shift, z_shift])
            shift_snr_data.append([x_shift, y_shift, z_shift, snr])
    
#fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
-4.0
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/coupling_optics_sims.py:31: RuntimeWarning:

invalid value encountered in sqrt
-3.5789473684210527
-3.1578947368421053
-2.736842105263158
-2.3157894736842106
-1.8947368421052633
-1.473684210526316
-1.0526315789473686
-0.6315789473684212
-0.2105263157894739
0.21052631578947345
0.6315789473684212
1.0526315789473681
1.473684210526315
1.8947368421052628
2.3157894736842106
2.7368421052631575
3.1578947368421044
3.578947368421052
4.0
#+end_example

: -4.0
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.sum(shift_snr_data[:, 3])
#+END_SRC

#+RESULTS:
: 24358.0

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.append(np.linspace(-10, 8, 4), 0)
shift_snr_data = np.array(shift_snr_data)
for z in z_vals:
    plt.figure(figsize=(10, 10))
    shift_z_data = shift_snr_data[np.where(shift_snr_data[:, 2] == z)]
    plt.scatter(shift_z_data[:, 0], shift_z_data[:, 1], c=shift_z_data[:, 3],
                norm=mpl.colors.LogNorm())
    plt.title('z shift = %s' %z)
    #if z != 10:
    plt.colorbar(label='# of rays making it through the FTS')
    plt.axis('equal')
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/c6150984d9e634ff5acbed22574acd4386c28eae.png]]
[[file:./.ob-jupyter/a174886519af3e51b023cbd57484bfb49a61f92c.png]]
[[file:./.ob-jupyter/b7747eb3e620246ba64e47f7ae2ea5458fa29c5a.png]]
[[file:./.ob-jupyter/ce7dedc20643cdf0392b6b6400c503657618697f.png]]
[[file:./.ob-jupyter/fea100b64e0e385d753f3f23ec4b68d6b5180fe8.png]]
:END:

Try running rays in the forwards direction and stopping them at z = -30.9 and
see what they look like. Then run these in reverse and see if we return to sender.

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 50, config, 
                                   theta_bound=0.2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=True,
                                                  fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards[3]
#+END_SRC

#+RESULTS:
#+begin_example
array([3350.88621513, 3351.05446006, 3350.97362151, 3351.26634068,
       3351.01161703, 3350.88605922, 3350.88067284, 3350.98284309,
       3350.89894517, 3350.94162246, 3350.88975193, 3351.09993202,
       3351.0131515 , 3350.8903652 , 3350.90237406, 3350.91138386,
       3351.03113842, 3351.08187428, 3351.13863101, 3350.88379026,
       3350.88893254, 3351.19624332, 3350.8806478 , 3351.01894469,
       3350.88626997, 3350.91033656, 3350.98422149, 3350.88005533,
       3350.92666505, 3350.90910216, 3351.00164824, 3350.91071593,
       3350.89520041, 3350.91831428, 3350.89784605, 3351.17099418,
       3351.02858975, 3351.07293268, 3350.91035547, 3350.92404692,
       3350.88015675, 3350.88018248, 3350.92549659, 3350.88876375,
       3350.89741497, 3350.88918037, 3351.01984984, 3350.94714306,
       3351.09384886, 3351.19703479])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays_reversed = []
for ray_out in out_forwards.T:
    assert ray_out[2] == csims.FOCUS[2]
    starting_rays_reversed.append([.123, 1, ray_out[[0, 1, 2]].flatten(), -1 * ray_out[[8, 9, 10]].flatten(), 0])
    
#+END_SRC

#+RESULTS:

We should really check and make sure that the distances match up too!

#+BEGIN_SRC jupyter-python :session py :kernel python3
fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=True, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_ = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 50
: total number of rays making past the first ellipse = 50
: total number of rays making it all the way through = 50
: final ray counts = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
: initial number of rays = 50
: total number of rays making past the first ellipse = 50
: total number of rays making it all the way through = 50


Ok, great. Now we just need to check that the distances are the same and also
check starting vectors out in a cone around some of the far points at x=-10 to
see why none of them are hitting. Then we'll pretty much be good to go here.

* Check that distances are the same

- ray by ray comparison here I guess.

#+BEGIN_SRC jupyter-python :session py :kernel python3
start_position = np.add(csims.FOCUS, [0, .2, 0])
out = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'red', fig, n_linear=1,
                                                      theta_bound=.2, plot=False, alpha=.2)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_point = out[[0, 1, 2]].flatten()
starting_vec = out[[8, 9, 10]].flatten()
starting_rays = [[.123, 1, starting_point, -1 * starting_vec, 0]]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_backwards = csims.run_rays_forwards_input_rays(starting_rays, z_ap=csims.FOCUS[2], plot=False,
                                                   fig=fig, color='red')
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
out[3]
#+END_SRC

#+RESULTS:
: array([36.76161766])

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_backwards[3] * csims.mm_to_in
#+END_SRC

#+RESULTS:
: array([36.76161766])

** Check that the distances are the same when inputting many rays

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 2, 
                                  config['detector']['normal_vec'], 100, config, 
                                  theta_bound=0.4)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)
transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)
out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=False,
                                                  fig=fig, color='red')

starting_rays_reversed = []
for ray_out in out_forwards.T:
    assert ray_out[2] == csims.FOCUS[2]
    starting_rays_reversed.append([.123, 1, ray_out[[0, 1, 2]].flatten(), -1 * ray_out[[8, 9, 10]].flatten(), 0])

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=False, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]
transformed_start_rays = transform_rays_to_fts_frame(start_rays_mcmahon)

possible_paths = get_possible_paths()
# only do the 1st of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    transformed_start_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean(out_forwards[3]), np.std(out_forwards[3])
#+END_SRC

#+RESULTS:
: (3451.1463706505997, 0.2148808840259485)

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(remove_outliers(out_forwards)[3])
#+END_SRC

#+RESULTS:
: 0.3142997636046779

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.hist(remove_outliers(out_forwards)[3])
#+END_SRC

#+RESULTS:
:RESULTS:
: (array([ 9.,  5., 13., 14., 10., 13., 10.,  5.,  5.,  2.]),
:  array([3450.97898779, 3451.33707396, 3451.69516013, 3452.0532463 ,
:         3452.41133247, 3452.76941864, 3453.12750481, 3453.48559098,
:         3453.84367715, 3454.20176332, 3454.55984949]),
:  <BarContainer object of 10 artists>)
[[file:./.ob-jupyter/d08f9d3e825d5d8f074a01e5e223f199f5ddbe41.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean([ray[4] for ray in final_rays]), np.std([ray[4] for ray in final_rays])
#+END_SRC

#+RESULTS:
: (3451.4954203750067, 0.27196604868351704)

Alright I'll call this one close enough, 3 decimal places is our original precision


It really should be perfect here.

** Check points, vectors distances

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st of these paths
possible_paths = [possible_paths[1]]

all_points_forwards, all_vectors_forwards, all_distances_forwards = [], [], []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238)

    all_points_forwards.append(total_ray_points)
    all_vectors_forwards.append(total_vectors)
    all_distances_forwards.append(total_distances)
#+END_SRC

#+RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=False, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]
transformed_start_rays = transform_rays_to_fts_frame(start_rays_mcmahon)

all_points_backwards, all_vectors_backwards, all_distances_backwards = [], [], []

possible_paths = get_possible_paths()
# only do the 1st of these paths
possible_paths = [possible_paths[1]]

for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        transformed_start_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238)

    all_points_backwards.append(total_ray_points)
    all_vectors_backwards.append(total_vectors)
    all_distances_backwards.append(total_distances)
#+END_SRC

#+RESULTS:
: final ray counts = [12]
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1


#+BEGIN_SRC jupyter-python :session py :kernel python3
all_points_forwards
#+END_SRC

#+RESULTS:
#+begin_example
[[[[225.0, 233.782, 0.0],
   (186.31835975360082, 0, 7.690811949339315),
   [147.7062496221141, -233.36177766141975, 15.367799690728779],
   (96.39931162244588, 0, 7.690811949339319),
   [45.00020336787598, -233.7809999999562, 3.2897367154838264e-05],
   [-4.762063146681292, -7.445831180479388, -7.44583118047941],
   [-8.147531761173607, -7.952394504638895, 7.952394504638895],
   [-57.70625410879198, -233.36177745033817, 15.367802529997935],
   (-96.31856069872687, 0, 7.690845911661434),
   [-135.00023233117759, -233.78099999993404, 9.803169743261009e-05],
   (-173.68167433371553, 0, -7.69074676639979)]]]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_points_backwards[0][0][-1] + np.multiply(all_distances_backwards[0][0][-1], all_vectors_backwards[0][0][-1])
#+END_SRC

#+RESULTS:
: array([ 2.24999992e+02,  2.33782002e+02, -1.29758747e-05])

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_distances_forwards
#+END_SRC

#+RESULTS:
#+begin_example
[[[0,
   237.08530406710565,
   236.65914405085937,
   239.05869007626802,
   239.48814662268933,
   231.86058894316784,
   15.774135741489317,
   230.91220226932955,
   236.65917488636728,
   237.0843210425419,
   237.08428672114314,
   263.34972794871527]]]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_distances_backwards[0][0][::-1]
#+END_SRC

#+RESULTS:
#+begin_example
[237.0853056368177,
 236.65914471013411,
 239.05868847842066,
 239.48814435786971,
 231.8606018344558,
 15.774109185362704,
 230.91221667607442,
 236.65917643607918,
 237.0843219512867,
 237.08428672113632,
 272.53752532949954,
 936.6772800352911]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.sum(all_distances_backwards)
#+END_SRC

#+RESULTS:
: 3350.880801352428

* Check the points in a cone around some of the far points at x=-10


#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 50, config, 
                                   theta_bound=0.2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2] - 10, plot=True,
                                                  fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards[3]
#+END_SRC

#+RESULTS:
#+begin_example
array([3607.70106121, 3605.40667966, 3610.20924308, 3605.55331105,
       3610.85753749, 3608.80492269, 3606.79800455, 3609.81658383,
       3610.8069358 , 3610.27988296, 3606.4719263 , 3605.57094641,
       3606.26587301, 3608.44131357, 3605.10981244, 3605.81735729,
       3606.86279446, 3609.78232773, 3606.73713764, 3604.99772641,
       3610.68994737, 3605.23932515, 3610.67446586, 3606.72985448,
       3610.42365132, 3604.94092979, 3607.75317465, 3608.26690982,
       3605.84355965, 3610.94357686, 3606.15730598, 3607.82747988,
       3606.7419801 , 3609.87705443, 3608.18029018, 3606.3446854 ,
       3608.87239889, 3607.21420318, 3607.4170345 , 3608.94452071,
       3611.07264068, 3610.25101006, 3607.71346774, 3608.26854137,
       3610.40232955, 3607.3611857 , 3607.7159255 , 3608.87397072,
       3607.75282742, 3606.91795736])
#+end_example

# Now take just one of these rays and roll with it

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_out[[0, 1, 2]].flatten()
#+END_SRC

#+RESULTS:
: array([ -0.93046588,  14.47165823, -30.9       ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_out[[0, 1, 2]].flatten() - csims.FOCUS
#+END_SRC

#+RESULTS:
: array([ -0.93046588,   1.12759487, -10.        ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays_reversed = []
for ray_out in out_forwards.T[0:1]:
    assert ray_out[2] == csims.FOCUS[2] - 10
    starting_rays_reversed.append([.123, 1, ray_out[[0, 1, 2]].flatten(), -1 * ray_out[[8, 9, 10]].flatten(), 0])
    

other_rays = create_source_rays(starting_rays_reversed[0][2], .5, 
                                [0.00001, 0.00001, -.99999], 50, None, theta_bound=.15, check_rays=False)
starting_rays_reversed.extend(other_rays)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(None, fts_geo, 'red', fig, 
                                                      starting_rays=starting_rays_reversed,
                                                      plot=True, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

_ = transform_rays_end_tilt(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=0, fig=fig, ray_alpha=.05)
fig.show()
#+END_SRC

#+RESULTS:
: final ray counts = [12, 2, 2, 12, 2, 2, 12, 2, 12, 1, 2, 12, 12, 2, 12]
: initial number of rays = 15
: total number of rays making past the first ellipse = 14
: total number of rays making it all the way through = 7
: final ray counts = [12, 2, 2, 12, 2, 2, 12, 2, 12, 1, 2, 12, 12, 2, 12]
: initial number of rays = 15
: total number of rays making past the first ellipse = 14
: total number of rays making it all the way through = 7

#+BEGIN_SRC jupyter-python :session py :kernel python3
starting_rays_reversed[0:4]
#+END_SRC

#+RESULTS:
#+begin_example
[[0.123,
  1,
  array([ -0.93046588,  14.47165823, -30.9       ]),
  array([ 0.09342564, -0.11321891,  0.9891679 ]),
  0],
 [0.123,
  1.0,
  [-0.9008078187458298, 14.482708625968241, -30.899999592911417],
  [-0.03020276451124469, 0.13200934464911512, 0.9907782745725334],
  0],
 [0.123,
  1.0,
  [-0.92565216004613, 14.053251811615457, -30.900004135968402],
  [0.06389958659010128, -0.002209642171074717, 0.9979438883618337],
  0],
 [0.123,
  1.0,
  [-1.224937592781247, 14.379036263563627, -30.90000387097556],
  [-0.031661294387972154, 0.10063166135512415, 0.9944098785119858],
  0]]
#+end_example

* Try a gigantic forwards raytrace and see how the path lengths look now.. 
** maybe try plotting too
Then I think we will possibly be ready for action over here.

- later tonight should maybe re-do the previous focus computation thing but with more rays
- instead of doing it backwards we can do it forwards and see how many rays go
  to each position- just have to run the rays once now!

#+BEGIN_SRC jupyter-python :session py :kernel python3

#with open("lab_fts_dims_mcmahon.yml", "r") as stream:
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 50, 
                                   config['detector']['normal_vec'], 50000, config, 
                                   theta_bound=0.4, timeout=2000)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
# for now do the 1st to reduce plotting
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=True)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

#plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2] - 10, 
                                         plot=False, fig=fig, color='red')
#fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
initial number of rays = 50000
total number of rays making past the first ellipse = 50000
total number of rays making it all the way through = 37527
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
#+end_example

It'd be cool to make some density plots of the rays actually lie here.... think
I'll be done for now though
- should redo this but with a systematic creation of spread rays instead of random
  
should also make sure that when we intersect with the -233 plane that the x
coordinate is left of 225
- trust the dims otherwise


#+BEGIN_SRC jupyter-python :session py :kernel python3
def remove_outliers(points, threshold=10, debug=False):
    new_points = []
    mean_x = csims.FOCUS[0]
    mean_y = csims.FOCUS[1]
    if (debug):
        print(f'focus is at {np.array(csims.FOCUS)[[0, 1]]}')
    for point in points:
        if np.abs(point[0] - mean_x) > threshold or np.abs(
                point[1] - mean_y) > threshold:
            if (debug):
                print(f'Taking away outlier point {point}')
            continue
        new_points.append(point)
    return np.array(new_points).T

def remove_outliers(out, threshold=5, debug=False):
    new_out = []
    mean_x = csims.FOCUS[0]
    mean_y = csims.FOCUS[1]
    if (debug):
        print(f'focus is at {np.array(csims.FOCUS)[[0, 1]]}')
        
    for i in range(out.shape[1]):
        point = out[[0, 1, 2], i]
        if np.abs(point[0] - mean_x) > threshold or np.abs(
                point[1] - mean_y) > threshold:
            if (debug):
                print(f'Taking away outlier point {point}')
            continue
        new_out.append(out[:, i])
    return np.array(new_out).T

# just subtract our z coordinate until we hit -20.9
def get_distances_at_z(out, z_coordinate):
    iters = (out[2] - z_coordinate) / out[5]
    return out[8] - iters / csims.mm_to_in

def get_rays_at_z(out, z_coordinate):
    iters = (out[2] - z_coordinate) / out[5]
    points = out[[0, 1, 2]]
    vectors = out[[3, 4, 5]]
    new_points = out[[0, 1, 2]] - out[[3, 4, 5]] * iters
   
    new_out = out.copy()
    new_out[[0, 1, 2]] = new_points
    new_out[8] = get_distances_at_z(out, z_coordinate)
    return new_out
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
points = remove_outliers(out[[0, 1, 2]].T)
points.shape
#points = out[[0, 1, 2]]
plt.figure(figsize=(3, 3))
import seaborn as sns
sns.set()
sns.kdeplot(x=points[0], y=points[1], fill=True, cmap='viridis', levels=100, thresh=0)
plt.axis('equal')
plt.scatter(csims.FOCUS[0], csims.FOCUS[1], s=1, color='black')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/f575696fb36c9e9111bd98c8bf27b408fadb535a.png]]

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.linspace(-10.9, -30.9, 5):
    points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], shade=True, cbar=True, cmap='viridis', thresh=0.01, 
                levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    plt.xlim(-4, 4)
    plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
   
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/8ca8b1a071499a572147a51a90d36037c5173577.png]]
[[file:./.ob-jupyter/9bdd9878693406dec32ffe8e3d62649208b047cf.png]]
[[file:./.ob-jupyter/795c08c2869f507a30270ad483c28699d4b5b72e.png]]
[[file:./.ob-jupyter/eb8bb16d14afc823b137340892b3946afe0acd53.png]]
[[file:./.ob-jupyter/51b7d5b2be325b2fdcdfe367b7e7c2d812c63dc1.png]]
:END:


#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(2, 2))
points = remove_outliers(get_rays_at_z(out, z), threshold=4)
sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1])
#+END_SRC

#+RESULTS:
:RESULTS:
: <AxesSubplot:>
[[file:./.ob-jupyter/0e1221bbdb34d79e58e051d7c6b291c207e7cfd3.png]]
:END:

* Uniform Rays

#+BEGIN_SRC jupyter-python :session py :kernel python3

#with open("lab_fts_dims_mcmahon.yml", "r") as stream:
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays_uniform(
    config['detector']['center'], 50, config['detector']['normal_vec'], 
    30, 30, 20, config, theta_bound=0.4, timeout=600, check_rays=True)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
# for now do the 1st to reduce plotting
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=True)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

#plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2] - 10, 
                                         plot=False, fig=fig, color='red')
#fig.show()
#+END_SRC

#+RESULTS:
#+begin_example
initial number of rays = 21131
total number of rays making past the first ellipse = 21131
total number of rays making it all the way through = 16636
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.linspace(csims.FOCUS[2] + 10, csims.FOCUS[2] - 10, 11):
    out_removed = remove_outliers(get_rays_at_z(out, z), threshold=5)
    #points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    points = out_removed[[0, 1, 2]]
    plt.figure(figsize=(5, 5))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20, norm=mpl.colors.LogNorm())
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    plt.xlim(-4, 4)
    plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/6cef6e0bccf5e42a499203a64222a313b4ef7ab0.png]]
[[file:./.ob-jupyter/fab1c8c6a2b1c9132c06e2988a14053c4cb71a29.png]]
[[file:./.ob-jupyter/9ed55f3532849980819cb528aff97fdfb351d8d2.png]]
[[file:./.ob-jupyter/e1f28b824f110fd5f6e3a8e4beaeb933cce05f35.png]]
[[file:./.ob-jupyter/e548f9f156c96c6193085d1a51cc83e021ee2596.png]]
[[file:./.ob-jupyter/003b7648f8700bdf0a73c5e0a9fa21d3dece2577.png]]
[[file:./.ob-jupyter/10a8f75b8e0b7078475f1bf958c6a9e55872a24e.png]]
[[file:./.ob-jupyter/2857c254a791c0f5b0472125cd8a3446d92147a3.png]]
[[file:./.ob-jupyter/295da0ef962cfd11266259c8cdb336bffba1776c.png]]
[[file:./.ob-jupyter/31b44dd4254289765ddd2ed0439456a3ee4454d9.png]]
[[file:./.ob-jupyter/4212b6bf079b8425a9757b55ced0a618ddf7a8bf.png]]
:END:

I guess we just have to run things now...

Can do the standard deviation of rays vs z position graph here too I guess.


#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
get_distances_at_z(out, -20.9)
#+END_SRC

#+RESULTS:
: array([3454.75532249, 3454.38312125, 3454.30880079, ..., 3454.14774156,
:        3454.38729444, 3454.47851741])

:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(remove_outliers(out)[3])
#+END_SRC

#+RESULTS:
: 2.443162030395897

#+BEGIN_SRC jupyter-python :session py :kernel python3
[np.std(get_distances_at_z(remove_outliers(out), d)) for d in np.linspace(-10.9, -30.9, 11)]
#+END_SRC

#+RESULTS:
#+begin_example
[2.1729681770305826,
 1.7841711683673258,
 1.4192792866449444,
 1.1022937470502547,
 0.8862055020667199,
 0.8516335801394439,
 1.0172562084202066,
 1.3091797081143297,
 1.6621382910358982,
 2.04476569922759,
 2.443162030395897]
#+end_example

Maybe see why this std is so high here...

try on a smaller number of rays?

and try the older amount and see if that keeps it the same..

try picking a spot and get all the rays within distance .05 of that spot.

if we illuminate ~10 detectors

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_rays_within_spot(out, spot, radius=.05):
    out_z = get_rays_at_z(out, spot[2])
    assert out_z[2][0] == spot[2]
    points = out_z[[0, 1, 2]]
    assert points[2][0] == spot[2]
    x_vals = points[0]
    y_vals = points[1]
    distances = np.sqrt((x_vals - spot[0]) ** 2 + (y_vals - spot[1]) ** 2)
    return out_z[:, np.where(distances <= radius)]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out[:, [0, 1, 2, 3]][:, 3]
#+END_SRC

#+RESULTS:
: array([ 1.96425464e-02, -4.26000000e-01,  3.76671069e-01,  3.68920647e+01,
:         0.00000000e+00,  2.31293364e-03, -9.99014969e-01,  4.43141337e-02,
:        -3.01481671e-03, -9.99835582e-01, -1.78807112e-02])

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_cleaned = remove_outliers(out)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
smaller_points = get_rays_within_spot(out_cleaned, [csims.FOCUS[0], csims.FOCUS[1], -30.9], radius=.1)
smaller_points.shape
#+END_SRC

#+RESULTS:
: (11, 1, 24)

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(smaller_points[3])
#+END_SRC

#+RESULTS:
: 0.9236131644054153
#+RESULTS:


#+BEGIN_SRC jupyter-python :session py :kernel python3
remove_outliers(out).shape
#+END_SRC

#+RESULTS:
: (11, 14950)

#+BEGIN_SRC jupyter-python :session py :kernel python3
ps.T[0]
#+END_SRC

#+RESULTS:
: array([-0.36993651, -0.36391476, -0.36320876, ...,  0.35932308,
:         0.38789004,  0.32628853])

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_cleaned.shape
#+END_SRC

#+RESULTS:
: (11, 14950)

#+BEGIN_SRC jupyter-python :session py :kernel python3
spot_rays = get_rays_within_spot(out_cleaned, [csims.FOCUS[0], csims.FOCUS[1], -20.9], 
                                 radius=1)
print(spot_rays.shape)
print(np.std(spot_rays[3]))
ps = spot_rays[[0, 1, 2]]
plt.scatter(ps[0], ps[1] - csims.FOCUS[1], c=spot_rays[3], s=10)
plt.colorbar()
#+END_SRC

#+RESULTS:
:RESULTS:
: (11, 1, 14950)
: 0.8516335801394439
: <matplotlib.colorbar.Colorbar at 0x7f9ca2e47670>
[[file:./.ob-jupyter/c55a384f5bdbc149f2add93455b6b58753810a00.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
ps[0][0]
#+END_SRC

#+RESULTS:
: array([-0.36993651, -0.36391476, -0.36320876, ...,  0.35932308,
:         0.38789004,  0.32628853])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(spot_rays[3])
#+END_SRC

#+RESULTS:
: 0.17610861024831181

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(get_rays_at_z(out_cleaned, -20.9)[3])
#+END_SRC

#+RESULTS:
: 0.8516335801394439

#+BEGIN_SRC jupyter-python :session py :kernel python3
ps = get_rays_at_z(out_cleaned, -20.9)[[0, 1, 2]]
plt.scatter(ps[0], ps[1])
#+END_SRC

#+RESULTS:
:RESULTS:
: <matplotlib.collections.PathCollection at 0x7f9cb39e5ac0>
[[file:./.ob-jupyter/dc9be1e7c414a47e1e555e0eddaf6abc1388f6e2.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in [-20.9]:
    points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    # plt.xlim(-4, 4)
    # plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/84d8077851f1194541664cb808e28cd72081bf50.png]]

* Test the Reverse Raytracing one more time
#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, -.4]
start = np.add(csims.FOCUS, shift)

# fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(start, fts_geo, 'black', fig, n_linear=20,
                                                      theta_bound=.25, plot=False, y_ap=-.426, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

rays, path_diffs = transform_rays_end_tilt_path_diffs(
    start_rays_mcmahon, config, plot=False, plot_mirror_position=5, fig=fig, ray_alpha=.05)
# fig.show()
#+END_SRC

#+RESULTS:
: initial number of rays = 356
: total number of rays making past the first ellipse = 356
: total number of rays making it all the way through = 308
: initial number of rays = 356
: total number of rays making past the first ellipse = 356
: total number of rays making it all the way through = 294

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / ((np.array([np.sum(i) for i in path_diffs[0]]) - np.array([np.sum(i) for i in path_diffs[1]])) / (4 * 5))
#+END_SRC

#+RESULTS:
:RESULTS:
: <ipython-input-1052-83392a12912a>:1: RuntimeWarning:
: 
: divide by zero encountered in true_divide
: 
#+begin_example
array([ 5.66509620e-02,  1.01560683e+00,  1.01657502e+00,  1.01725315e+00,
        1.01772565e+00,  1.01804594e+00,  1.01824636e+00,  1.01834402e+00,
        1.01834394e+00,  1.01824047e+00,  1.01801721e+00,  1.01764578e+00,
        1.01708339e+00,  1.01626877e+00,  1.01511598e+00, -6.19230957e-02,
                   inf,  5.66407046e-02,  1.01558650e+00,  1.01656128e+00,
        1.01724447e+00,  1.01772070e+00,  1.01804355e+00,  1.01824554e+00,
        1.01834393e+00,  1.01834385e+00,  1.01823972e+00,  1.01801513e+00,
        1.01764168e+00,  1.01707650e+00,  1.01625815e+00,  1.01510048e+00,
       -6.19349752e-02,             inf,             inf,  5.66102141e-02,
        1.01552731e+00,  1.01652128e+00,  1.01721926e+00,  1.01770633e+00,
        1.01803662e+00,  1.01824317e+00,  1.01834368e+00,  1.01834361e+00,
        1.01823753e+00,  1.01800913e+00,  1.01762989e+00,  1.01705670e+00,
        1.01622771e+00,  1.01505609e+00, -6.19702820e-02,             inf,
                   inf,  5.65603276e-02,  1.01543448e+00,  1.01645864e+00,
        1.01717985e+00,  1.01768390e+00,  1.01802583e+00,  1.01823949e+00,
        1.01834329e+00,  1.01834322e+00,  1.01823418e+00,  1.01799993e+00,
        1.01761188e+00,  1.01702655e+00,  1.01618150e+00,  1.01498890e+00,
       -6.20280313e-02,             inf,             inf,  5.64924147e-02,
        1.01531623e+00,  1.01637902e+00,  1.01712989e+00,  1.01765558e+00,
        1.01801224e+00,  1.01823488e+00,  1.01834281e+00,  1.01834274e+00,
        1.01823003e+00,  1.01798863e+00,  1.01758988e+00,  1.01698995e+00,
        1.01612569e+00,  1.01490812e+00, -6.21066146e-02,             inf,
                   inf,  5.64083393e-02,  1.01518296e+00,  1.01628960e+00,
        1.01707400e+00,  1.01762404e+00,  1.01799721e+00,  1.01822980e+00,
        1.01834228e+00,  1.01834222e+00,  1.01822557e+00,  1.01797660e+00,
        1.01756666e+00,  1.01695167e+00,  1.01606783e+00,  1.01482497e+00,
       -6.22038465e-02,             inf,             inf,  5.63104082e-02,
        1.01504639e+00,  1.01619838e+00,  1.01701733e+00,  1.01759229e+00,
        1.01798220e+00,  1.01822479e+00,  1.01834177e+00,  1.01834172e+00,
        1.01822131e+00,  1.01796528e+00,  1.01754517e+00,  1.01691678e+00,
        1.01601588e+00,  1.01475122e+00,  1.01299383e+00,             inf,
                   inf,  5.62013067e-02,  1.01491837e+00,  1.01611344e+00,
        1.01696502e+00,  1.01756329e+00,  1.01796867e+00,  1.01822034e+00,
        1.01834132e+00,  1.01834128e+00,  1.01821775e+00,  1.01795607e+00,
        1.01752819e+00,  1.01689006e+00,  1.01597724e+00,  1.01469774e+00,
        5.55987267e-02,             inf, -2.19902326e+13,  5.60840245e-02,
        1.01480980e+00,  1.01604213e+00,  1.01692171e+00,  1.01753972e+00,
        1.01795792e+00,  1.01821691e+00,  1.01834099e+00,  1.01834097e+00,
        1.01821531e+00,  1.01795014e+00,  1.01751804e+00,  1.01687540e+00,
        1.01595792e+00,  1.01467324e+00,  5.57157676e-02,             inf,
                   inf,  5.59617722e-02,  1.01472948e+00,  1.01599033e+00,
        1.01689106e+00,  1.01752363e+00,  1.01795094e+00,  1.01821482e+00,
        1.01834081e+00,  1.01834080e+00,  1.01821428e+00,  1.01794831e+00,
        1.01751630e+00,  1.01687540e+00,  1.01596183e+00,  1.01468324e+00,
        5.58378925e-02,             inf,             inf,  5.58378925e-02,
        1.01468324e+00,  1.01596183e+00,  1.01687540e+00,  1.01751630e+00,
        1.01794831e+00,  1.01821428e+00,  1.01834080e+00,  1.01834081e+00,
        1.01821482e+00,  1.01795094e+00,  1.01752363e+00,  1.01689106e+00,
        1.01599033e+00,  1.01472948e+00,  5.59617722e-02,             inf,
                   inf,  5.57157676e-02,  1.01467324e+00,  1.01595792e+00,
        1.01687540e+00,  1.01751804e+00,  1.01795014e+00,  1.01821531e+00,
        1.01834097e+00,  1.01834099e+00,  1.01821691e+00,  1.01795792e+00,
        1.01753972e+00,  1.01692171e+00,  1.01604213e+00,  1.01480980e+00,
        5.60840245e-02,             inf,             inf,  5.55987267e-02,
        1.01469774e+00,  1.01597724e+00,  1.01689006e+00,  1.01752819e+00,
        1.01795607e+00,  1.01821775e+00,  1.01834128e+00,  1.01834132e+00,
        1.01822034e+00,  1.01796867e+00,  1.01756329e+00,  1.01696502e+00,
        1.01611344e+00,  1.01491837e+00,  5.62013067e-02,             inf,
                   inf,  1.01299383e+00,  1.01475122e+00,  1.01601588e+00,
        1.01691678e+00,  1.01754517e+00,  1.01796528e+00,  1.01822131e+00,
        1.01834172e+00,  1.01834177e+00,  1.01822479e+00,  1.01798220e+00,
        1.01759229e+00,  1.01701733e+00,  1.01619838e+00,  1.01504639e+00,
        5.63104082e-02,             inf,             inf, -6.22038465e-02,
        1.01482497e+00,  1.01606783e+00,  1.01695167e+00,  1.01756666e+00,
        1.01797660e+00,  1.01822557e+00,  1.01834222e+00,  1.01834228e+00,
        1.01822980e+00,  1.01799721e+00,  1.01762404e+00,  1.01707400e+00,
        1.01628960e+00,  1.01518296e+00,  5.64083393e-02,             inf,
                   inf, -6.21066146e-02,  1.01490812e+00,  1.01612569e+00,
        1.01698995e+00,  1.01758988e+00,  1.01798863e+00,  1.01823003e+00,
        1.01834274e+00,  1.01834281e+00,  1.01823488e+00,  1.01801224e+00,
        1.01765558e+00,  1.01712989e+00,  1.01637902e+00,  1.01531623e+00,
        5.64924147e-02,             inf,             inf, -6.20280313e-02,
        1.01498890e+00,  1.01618150e+00,  1.01702655e+00,  1.01761188e+00,
        1.01799993e+00,  1.01823418e+00,  1.01834322e+00,  1.01834329e+00,
        1.01823949e+00,  1.01802583e+00,  1.01768390e+00,  1.01717985e+00,
        1.01645864e+00,  1.01543448e+00,  5.65603276e-02,             inf,
                   inf, -6.19702820e-02,  1.01505609e+00,  1.01622771e+00,
        1.01705670e+00,  1.01762989e+00,  1.01800913e+00,  1.01823753e+00,
        1.01834361e+00,  1.01834368e+00,  1.01824317e+00,  1.01803662e+00,
        1.01770633e+00,  1.01721926e+00,  1.01652128e+00,  1.01552731e+00,
        5.66102141e-02,             inf,             inf, -6.19349752e-02,
        1.01510048e+00,  1.01625815e+00,  1.01707650e+00,  1.01764168e+00,
        1.01801513e+00,  1.01823972e+00,  1.01834385e+00,  1.01834393e+00,
        1.01824554e+00,  1.01804355e+00,  1.01772070e+00,  1.01724447e+00,
        1.01656128e+00,  1.01558650e+00,  5.66407046e-02,             inf,
       -6.19230957e-02,  1.01511598e+00,  1.01626877e+00,  1.01708339e+00,
        1.01764578e+00,  1.01801721e+00,  1.01824047e+00,  1.01834394e+00,
        1.01834402e+00,  1.01824636e+00,  1.01804594e+00,  1.01772565e+00,
        1.01725315e+00,  1.01657502e+00,  1.01560683e+00,  5.66509620e-02])
#+end_example
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = get_possible_paths()
z_vals = []
for z in np.linspace(-10, 8, 21):    
    rays_test = csims.get_final_rays_reversed([0, 0, z], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
    distances_to_keep = []
    for distances in total_distances:
        if distances[-1] != 0:
            distances_to_keep.append(distances)

    mean = np.mean(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    stdev = np.std(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    z_vals.append([z, mean, stdev])
#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 160
total number of rays making past the first ellipse = 160
total number of rays making it all the way through = 120
initial number of rays = 160
total number of rays making past the first ellipse = 160
total number of rays making it all the way through = 120
initial number of rays = 160
total number of rays making past the first ellipse = 160
total number of rays making it all the way through = 120
initial number of rays = 200
total number of rays making past the first ellipse = 200
total number of rays making it all the way through = 130
initial number of rays = 200
total number of rays making past the first ellipse = 200
total number of rays making it all the way through = 160
initial number of rays = 240
total number of rays making past the first ellipse = 240
total number of rays making it all the way through = 160
initial number of rays = 280
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 200
initial number of rays = 268
total number of rays making past the first ellipse = 268
total number of rays making it all the way through = 226
initial number of rays = 292
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 240
initial number of rays = 304
total number of rays making past the first ellipse = 304
total number of rays making it all the way through = 240
initial number of rays = 336
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 280
initial number of rays = 360
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 320
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 360
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 376
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 280
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 210
initial number of rays = 344
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 200
initial number of rays = 288
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 160
initial number of rays = 240
total number of rays making past the first ellipse = 232
total number of rays making it all the way through = 130
initial number of rays = 208
total number of rays making past the first ellipse = 200
total number of rays making it all the way through = 120
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.array(z_vals)
min_index = np.argmin(z_vals[:, 2])
np.array(z_vals)[:, 0][min_index]
#+END_SRC

#+RESULTS:
: 1.700000000000001

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals[:, 2]
#+END_SRC

#+RESULTS:
: array([1.52296781, 1.28772728, 1.06984527, 1.2483588 , 1.34514481,
:        1.03877126, 1.31736707, 1.35589219, 0.97273461, 0.56507484,
:        0.42627106, 0.22313252, 0.04743211, 0.03990745, 0.11990995,
:        0.30871485, 0.3950818 , 0.56181706, 0.54255663, 0.56624547,
:        0.55211507])

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals[:, 0]
#+END_SRC

#+RESULTS:
: array([-10. ,  -9.1,  -8.2,  -7.3,  -6.4,  -5.5,  -4.6,  -3.7,  -2.8,
:         -1.9,  -1. ,  -0.1,   0.8,   1.7,   2.6,   3.5,   4.4,   5.3,
:          6.2,   7.1,   8. ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(10, 6))
plt.plot(np.array(z_vals)[:, 0], np.array(z_vals)[:, 2], '.')
plt.title('Tracing set of initial rays through the FTS (one path)')
plt.ylabel('standard deviation of path length (mm)')
plt.xlabel('FTS z position')
#plt.axhline(.5, label='1/2 wavelength of 300 Ghz', linestyle='--', color='black')
#plt.legend()
#plt.xlim(-50, 50)
plt.savefig('path length difference plot.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/2ba27b1941349eac79ded6dc9233d3595efcbd83.png]]


I think we're ready to go to notebook utils now.

* Now try y
#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = get_possible_paths()
z_vals = []
for z in np.linspace(-.7, .7, 21):    
    rays_test = csims.get_final_rays_reversed([0, z, 0], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
    distances_to_keep = []
    for distances in total_distances:
        if distances[-1] != 0:
            distances_to_keep.append(distances)

    mean = np.mean(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    stdev = np.std(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    z_vals.append([z, mean, stdev])

#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 350
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 0
/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning:

Mean of empty slice.

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning:

invalid value encountered in double_scalars

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning:

Degrees of freedom <= 0 for slice

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning:

invalid value encountered in true_divide

/Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning:

invalid value encountered in double_scalars
initial number of rays = 348
total number of rays making past the first ellipse = 346
total number of rays making it all the way through = 300
initial number of rays = 350
total number of rays making past the first ellipse = 344
total number of rays making it all the way through = 312
initial number of rays = 354
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 314
initial number of rays = 358
total number of rays making past the first ellipse = 354
total number of rays making it all the way through = 314
initial number of rays = 362
total number of rays making past the first ellipse = 356
total number of rays making it all the way through = 314
initial number of rays = 366
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 316
initial number of rays = 370
total number of rays making past the first ellipse = 366
total number of rays making it all the way through = 318
initial number of rays = 372
total number of rays making past the first ellipse = 372
total number of rays making it all the way through = 318
initial number of rays = 374
total number of rays making past the first ellipse = 374
total number of rays making it all the way through = 320
initial number of rays = 380
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 320
initial number of rays = 374
total number of rays making past the first ellipse = 374
total number of rays making it all the way through = 320
initial number of rays = 372
total number of rays making past the first ellipse = 372
total number of rays making it all the way through = 316
initial number of rays = 370
total number of rays making past the first ellipse = 366
total number of rays making it all the way through = 316
initial number of rays = 366
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 314
initial number of rays = 362
total number of rays making past the first ellipse = 356
total number of rays making it all the way through = 304
initial number of rays = 358
total number of rays making past the first ellipse = 354
total number of rays making it all the way through = 308
initial number of rays = 354
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 308
initial number of rays = 350
total number of rays making past the first ellipse = 344
total number of rays making it all the way through = 302
initial number of rays = 348
total number of rays making past the first ellipse = 346
total number of rays making it all the way through = 294
initial number of rays = 350
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 0
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.array(z_vals)
min_index = np.argmin(z_vals[:, 2])
np.array(z_vals)[:, 0][min_index]
#+END_SRC

#+RESULTS:
: -0.7

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals
#+END_SRC

#+RESULTS:
#+begin_example
array([[-7.00000000e-01,             nan,             nan],
       [-6.30000000e-01,  3.45368607e+03,  3.33860863e-01],
       [-5.60000000e-01,  3.45316571e+03,  3.33661043e-01],
       [-4.90000000e-01,  3.45267761e+03,  2.87275664e-01],
       [-4.20000000e-01,  3.45224725e+03,  2.44116680e-01],
       [-3.50000000e-01,  3.45188405e+03,  2.22444548e-01],
       [-2.80000000e-01,  3.45159476e+03,  2.27797502e-01],
       [-2.10000000e-01,  3.45135601e+03,  2.00342662e-01],
       [-1.40000000e-01,  3.45118701e+03,  1.91789696e-01],
       [-7.00000000e-02,  3.45109187e+03,  2.00825795e-01],
       [ 0.00000000e+00,  3.45105417e+03,  1.87994005e-01],
       [ 7.00000000e-02,  3.45109187e+03,  2.00822757e-01],
       [ 1.40000000e-01,  3.45118407e+03,  1.88796566e-01],
       [ 2.10000000e-01,  3.45135299e+03,  1.97354279e-01],
       [ 2.80000000e-01,  3.45159234e+03,  2.26497617e-01],
       [ 3.50000000e-01,  3.45187200e+03,  2.07151657e-01],
       [ 4.20000000e-01,  3.45223949e+03,  2.37196115e-01],
       [ 4.90000000e-01,  3.45266856e+03,  2.77749165e-01],
       [ 5.60000000e-01,  3.45314222e+03,  2.99083825e-01],
       [ 6.30000000e-01,  3.45366135e+03,  3.08669624e-01],
       [ 7.00000000e-01,             nan,             nan]])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(10, 6))
plt.plot(np.array(z_vals)[:, 0], np.array(z_vals)[:, 2], '.')
plt.title('Tracing set of initial rays through the FTS (one path)')
plt.ylabel('standard deviation of path length (mm)')
plt.xlabel('FTS z position (mm)')
#plt.axhline(.5, label='1/2 wavelength of 300 Ghz', linestyle='--', color='black')
#plt.legend()
#plt.xlim(-50, 50)
plt.savefig('path length difference plot.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ecb8bac2e66f468806e24781a37fb348f5107117.png]]



#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.linspace(.6, .7, 10):
    rays_test = csims.get_final_rays_reversed([z, 0, 0], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
#+END_SRC

#+RESULTS:
#+begin_example
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 313
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 311
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 307
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 298
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 266
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 213
initial number of rays = 352
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 160
initial number of rays = 350
total number of rays making past the first ellipse = 350
total number of rays making it all the way through = 100
initial number of rays = 352
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 11
initial number of rays = 352
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 1
#+end_example

* Loading in some full reverse runs just like before!

#+BEGIN_SRC jupyter-python :session py :kernel python3
import notebook_utils
import pickle
import numpy as np
import matplotlib.pyplot as plt

def load_data(fname):
    total_attrs = pickle.load(open(fname, 'rb'))
    data = np.array(total_attrs, dtype='object')
    shifts = np.array(list(map(np.array, data[:, 0])))
    return data, shifts

def get_shift_index(data, shift):
    return np.where(np.array([(np.round(data[i][0], 2) == np.round(shift, 2)).all() for i in range(
        len(data))]) == True)[0][0]


def plot_data(data, shift):
    n = get_shift_index(data, shift)
    rays = data[n][-1]
    delay = data[n][1]
    shift = data[n][0]

    gaussian_shifts = data[n][2]
    gaussian_amplitudes = data[n][4]
    freqs = data[n][-2]
    #_ = notebook_utils.plot_shifts(delay, rays, np.arange(15, 301), 20, shift=[0, 0, -2], plot=True)
    notebook_utils.plot_shifts_end(shift, freqs, gaussian_shifts, gaussian_amplitudes / np.max(gaussian_amplitudes))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xz_15_15_20_57.p')

for i in range(len(shifts)):
    plot_data(data, np.sort(shifts, axis=0)[i])
    plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/79b81c7cde9d4686b70caab62b5f06f5d5ce6d03.png]]


#+BEGIN_SRC jupyter-python :session py :kernel python3
rays_test = csims.get_final_rays_reversed([-.5, .5, 0], 20, theta_bound=.25)
transformed_test = transform_rays_to_fts_frame(rays_test)

points, vectors, total_distances = step_rays(
    transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
    possible_paths[6], final_dist=0)
#+END_SRC

#+RESULTS:
: initial number of rays = 351
: total number of rays making past the first ellipse = 350
: total number of rays making it all the way through = 1

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.around(np.linspace(-.45, .45, 15), 3)
#+END_SRC

#+RESULTS:
: array([-0.45 , -0.386, -0.321, -0.257, -0.193, -0.129, -0.064,  0.   ,
:         0.064,  0.129,  0.193,  0.257,  0.321,  0.386,  0.45 ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')

def plot_freq_shifts(y_data, z_data, values, clabel=None, cmap=None):
    plt.figure(figsize=(10, 5))
    plt.scatter(y_data, values, c=z_data, cmap=cmap, alpha=.6)
    if (clabel is not None):
        plt.colorbar(label=clabel)
    plt.grid()

cmap = plt.get_cmap('inferno')
s1 = np.where((shifts[:, 2] == 0) & (np.abs(shifts[:, 1]) <= .6))
#s1 = np.where((shifts_xy[:, 0]) == 0)
plot_freq_shifts(25.4 * shifts[:, 1][s1], 25.4 * shifts[:, 0][s1], data[:, 6][s1],
                 clabel='z shift (mm)', cmap=cmap)
#plt.ylim(-.005, .007)
plt.xlabel('y shift (mm)')
plt.ylabel('fractional frequency shift (Ghz)')
plt.title('frequency correction factor, detector shifting in x and y (z centered)')
#plt.savefig('frequency_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/c1033454d8d0e16422232cbd5948489b7ec1f65c.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')

def plot_freq_shifts(y_data, z_data, values, clabel=None, cmap=None):
    plt.figure(figsize=(10, 5))
    plt.scatter(y_data, values, c=z_data, cmap=cmap, alpha=.6)
    if (clabel is not None):
        plt.colorbar(label=clabel)
    plt.grid()

cmap = plt.get_cmap('inferno')
s1 = np.where((shifts[:, 2] == 0) & (np.abs(shifts[:, 1]) <= .6))
#s1 = np.where((shifts_xy[:, 0]) == 0)
plot_freq_shifts(25.4 * shifts[:, 1][s1], 25.4 * shifts[:, 0][s1], (1.017 / 1.015) / (data[:, 6][s1] + 1),
                 clabel='z shift (mm)', cmap=cmap)
#plt.ylim(-.005, .007)
plt.xlabel('y shift (mm)')
plt.ylabel('fractional frequency shift (Ghz)')
plt.title('frequency correction factor, detector shifting in x and y (z centered)')
#plt.savefig('frequency_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/41d0b5f08eeb01d73fee69703df0c59e6366999c.png]]


#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(6, 5))
plt.scatter(25.4 * shifts[:, 0][s1], 25.4 * shifts[:, 1][s1], c=100 * (data[:, 6][s1] - np.min(data[:, 6][s1])), 
            cmap='inferno')
#plt.xlim(-9.5, 9.5)
plt.colorbar(label='frequency shift (%)')
plt.xlabel('detector x position (mm)')
plt.ylabel('detector y position (mm)')
plt.title('Frequency shift at z = 0')
plt.axis('equal')
plt.savefig('/Users/tommyalford/Desktop/paper_figures/focal_plane_freq_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/c76d555be54c75eb247d8fe7c1d71ec96c1cfc60.png]]


#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(6, 5))
data_freq_shift, shifts_freq_shift = load_data('data/total_attrs_xy_15_15_20_57_freq_shift.p')
plt.scatter(25.4 * shifts_freq_shift[:, 0][s1], 25.4 * shifts_freq_shift[:, 1][s1], 
            c=100 * (data_freq_shift[:, 6][s1] - np.mean(data_freq_shift[:, 6][s1])), 
            cmap='RdBu', norm=mpl.colors.TwoSlopeNorm(vcenter=0))
#plt.xlim(-9.5, 9.5)

plt.colorbar(label='frequency shift from (%)')
plt.xlabel('detector x position (mm)')
plt.ylabel('detector y position (mm)')
plt.title('Frequency shift at z = 0, tilted source')
plt.axis('equal')
plt.savefig('/Users/tommyalford/Desktop/paper_figures/focal_plane_freq_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/80120ee56660f7e3d785a065a6bf584d0c0aa5aa.png]]


#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')
s1 = np.where((shifts[:, 2] == 0) & (np.abs(shifts[:, 1]) <= 10))
plt.plot(25.4 * np.sqrt(shifts[:, 0][s1] ** 2 + shifts[:, 1][s1] ** 2), 
         1 / (1 + data[:, 6][s1]), '.')
#plt.xlim(-9.5, 9.5)
#plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/72f4eef1b2a179a137b46ffa09ef72001c5da25f.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
def fit_poly(freqs, data, order=7):
    poly_params = np.polyfit(freqs, data, order)
    freq_eval = np.arange(15, 250, .1)
    poly_template = np.polyval(poly_params, freqs)
    return freqs, poly_template

fig, axes = plt.subplots(5, 5, figsize=(15, 15), sharex=True, sharey=True)
for j, x in enumerate(np.unique(shifts[:, 0])[[1, 4, 7, 10, 13]]):
    for i, z in enumerate(np.unique(shifts[:, 1])[::-1][[1, 4, 7, 10, 13]]):
        plot_shift = [x, z, 0]
        n = get_shift_index(data, plot_shift)
        rays = data[n][-1]
        delay = data[n][1]
        shift = data[n][0]

        gaussian_shifts = data[n][2]
        gaussian_amplitudes = data[n][4]
        freqs = data[n][-2]
        freq_plot, yvals = fit_poly(freqs, gaussian_amplitudes / np.max(gaussian_amplitudes), order=7)
        axes[i][j].plot(freq_plot, yvals, color='blue')
        #axes[i][j].plot(freqs, gaussian_amplitudes / np.max(gaussian_amplitudes), '.', color='blue')
        axes[i][j].grid()
        axes[i][j].set_xlim(0, 300)
        axes[i][j].set_title('(%d, %.0f, %d)' %tuple(np.multiply(shift, 25.4)))
        #axes[i][j].set_ylim(0, -.10)
        if (i == 4):
            axes[i][j].set_xlabel('frequency (Ghz)')

        if (j == 0):
            axes[i][j].set_ylabel('normalized amplitude')
        
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/c1d77d86ec4031b9f8ded22a317456e763343ca4.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
data_z, shifts_z = load_data('data/total_attrs_xyz_5_5_11_20_57.p')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.unique(shifts_z[:, 2][::-1])[2:-2]
#+END_SRC

#+RESULTS:
: array([-2.4, -1.6, -0.8,  0. ,  0.8,  1.6,  2.4])

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.unique(shifts_z[:, 0])
#+END_SRC

#+RESULTS:
: array([-0.45 , -0.225,  0.   ,  0.225,  0.45 ])


#+BEGIN_SRC jupyter-python :session py2 :kernel python3
fig, axes = plt.subplots(7, 5, figsize=(10, 10), sharex=True, sharey=True)
for j, x in enumerate(np.unique(shifts_z[:, 0])):
    for i, z in enumerate(np.unique(shifts_z[:, 2])[2:-2]):
        plot_shift = [x, 0, z]
        n = get_shift_index(data_z, plot_shift)
        rays = data_z[n][-1]
        delay = data_z[n][1]
        shift = data_z[n][0]

        gaussian_shifts = data_z[n][2]
        gaussian_amplitudes = data_z[n][4]
        freqs = data_z[n][-2]
        _, yvals = fit_poly(freqs, gaussian_amplitudes / np.max(gaussian_amplitudes), 
                            order=7)
        yvals /= np.max(yvals)
        axes[i][j].plot(freqs, yvals, color='blue')
        axes[i][j].grid()
        axes[i][j].set_title('(%.1f, %.0f, %.1f)' %tuple(np.multiply(shift, 1)))

        if (i == 6):
            axes[i][j].set_xlabel('frequency (Ghz)')

        if (j == 0):
            axes[i][j].set_ylabel('normalized amplitude')
        axes[i][j].set_xlim(20, 300)
        
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/d16f28b8601be4c621b09019f5cc0ca324fab5ca.png]]

* Looking at the frequency shift

#+BEGIN_SRC jupyter-python :session py :kernel python3
data_freq_shift, shifts_freq_shift = load_data('data/total_attrs_xy_15_15_20_57_freq_shift.p')

cmap = plt.get_cmap('inferno')
s1 = np.where((shifts_freq_shift[:, 2] == 0) & (np.abs(shifts_freq_shift[:, 1]) <= .6))
#s1 = np.where((shifts_xy[:, 0]) == 0)
plot_freq_shifts(25.4 * shifts_freq_shift[:, 1][s1], 25.4 * shifts_freq_shift[:, 0][s1], 
                 (1.052 / 1.055) / (data_freq_shift[:, 6][s1] + 1), clabel='x shift (mm)', cmap=cmap)
#plt.ylim(-.005, .007)
plt.xlabel('y shift (mm)')
plt.ylabel('fractional frequency shift (Ghz)')
plt.title('frequency correction factor, detector shifting in x and y (z centered)')
#plt.savefig('frequency_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/25e99c46cdc70b8fc7c18718d4f97b9e1811043d.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
data_freq_shift, shifts_freq_shift = load_data('data/total_attrs_xy_15_15_20_57_freq_shift.p')
plt.scatter(25.4 * shifts_freq_shift[:, 0][s1], 25.4 * shifts_freq_shift[:, 1][s1], 
            c=100 * (data_freq_shift[:, 6][s1] - np.mean(data_freq_shift[:, 6][s1])), 
            cmap='RdBu', norm=mpl.colors.TwoSlopeNorm(vcenter=0))
#plt.xlim(-9.5, 9.5)
plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/fe190fc5441ec53f050d3b3621a2486802165571.png]]

* Finding the focus
#+BEGIN_SRC jupyter-python :session py :kernel python3
np.arange(-22.1, -20.1, .2)
#+END_SRC

#+RESULTS:
: array([-22.1, -21.9, -21.7, -21.5, -21.3, -21.1, -20.9, -20.7, -20.5,
:        -20.3])

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.arange(-21.9, -19.9, .2):
    points = remove_outliers(get_rays_at_z(out_cleaned, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    # plt.xlim(-4, 4)
    # plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/92b0b43ee6b0e1fc6029327cc5cebac3d3715d32.png]]
[[file:./.ob-jupyter/84ecdb60366e033309b3cfb2c1a8a8ff84394eca.png]]
[[file:./.ob-jupyter/5680633f4fb87a5869f7a552003f28a3b96137f9.png]]
[[file:./.ob-jupyter/3ee9bb4bbdbc59318350fb2f9b63f45b53e7bef1.png]]
[[file:./.ob-jupyter/326bbe7bf3c9d3a730fa344f34d7072175e2a1b0.png]]
[[file:./.ob-jupyter/607e97e0b24352ee830b3d73cbcfe724c5afa8ae.png]]
[[file:./.ob-jupyter/1f71936de8d63cf2e97cbfde5e06fc54690e7cf0.png]]
[[file:./.ob-jupyter/e53a177aeb43f1151af602534fa5618f05667b47.png]]
[[file:./.ob-jupyter/2caaa6870da4009849bee0374624b71e95b94961.png]]
[[file:./.ob-jupyter/8a1a0decb4f8ab68bfd17609ecb86526930030a6.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.arange(-19.9, -17.9, .2):
    points = remove_outliers(get_rays_at_z(out_cleaned, z), threshold=5)
    #points = out[[0, 1, 2]]
    plt.figure(figsize=(3, 3))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20)
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    # plt.xlim(-4, 4)
    # plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/88b5532c13e0e5bf7c6a403102a5fa6f40717d5c.png]]
[[file:./.ob-jupyter/d4f943903e7b2ca5b0bd62d31c1108809eee7417.png]]
[[file:./.ob-jupyter/a3f66eb6f537b35d70c4a7ab687c7a25beaa35f6.png]]
[[file:./.ob-jupyter/fe5a5ab67d282de57f843385d6652f22d76b1d2f.png]]
[[file:./.ob-jupyter/915ce3bc69652663c1a7b3a821465ac858d97da2.png]]
[[file:./.ob-jupyter/5a0d621403ac4adf519f51cea18890cf194e9592.png]]
[[file:./.ob-jupyter/89bb081cd307cf1e6f5ce4dc464a1d53f418cd62.png]]
[[file:./.ob-jupyter/45fa568cbfda24caa0238f6ea5ba2875353cd71c.png]]
[[file:./.ob-jupyter/275d1ccf9c6c1fc343bff43b2c517a388011189b.png]]
[[file:./.ob-jupyter/b6d893a75557b2ea31d1826f6ec7eff5cabea73a.png]]
:END:

* Final Transfer Function stuff

#+BEGIN_SRC jupyter-python :session py2 :kernel python3
data_z, shifts_z = load_data('data/total_attrs_xyz_5_5_5_20_57.p')
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python :session py2 :kernel python3
fig, axes = plt.subplots(5, 5, figsize=(10, 10), sharex=True, sharey=True)
for j, x in enumerate(np.unique(shifts_z[:, 1])):
    for i, z in enumerate(np.unique(shifts_z[:, 2])):
        plot_shift = [x, 0, z]
        n = get_shift_index(data_z, plot_shift)
        rays = data_z[n][-1]
        delay = data_z[n][1]
        shift = data_z[n][0]

        gaussian_shifts = data_z[n][2]
        gaussian_amplitudes = data_z[n][4]
        freqs = data_z[n][-2]
        # _, yvals = fit_poly(freqs, gaussian_amplitudes / np.max(gaussian_amplitudes), 
        #                     order=7)
        # yvals /= np.max(yvals)
        yvals = gaussian_amplitudes / np.max(gaussian_amplitudes)
        axes[i][j].plot(freqs, yvals, '.', color='blue')
        axes[i][j].grid()
        axes[i][j].set_title('(%.1f, %.0f, %.1f)' %tuple(np.multiply(shift, 25.4)))

        if (i == 6):
            axes[i][j].set_xlabel('frequency (Ghz)')

        if (j == 0):
            axes[i][j].set_ylabel('normalized amplitude')
        axes[i][j].set_xlim(20, 300)
        
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/6c178c52e576ba651c2c67a05deaec2a68f98218.png]]

* Paper Outline
10 pages, what

1 page for science- see first page of ACT paper

- mention the need for precision calibration
  - mention the need for 

section for simulating the FTS + coupling optics

- figure of a reverse raytrace


section for the simulation results
- frequency shift at focus
- frequency shift when moving around in z
- transfer functions at focus
- transfer functions when moving around in z
  
- frequency shift when changing source angle
- mention the effect that the source angle has on things
  
section for other color corrections:
- thin membrane window (still in progress)
- lens dissipation
  

section for bandpasses- ACT

- show an example of the number of detectors illuminated per region
- show all the bands
- show the frequency shift that we see
- show band centers, widths, SNR, 5% band edges, etc
  

section for bandpasses- SO LATRt optics tube

- mention the different source
- mention that the changes do not significantly effect what we see
- mention the new demodulation
- NDF filter?
  
- all the error bars from the bootstrapping to the error bars from the NDF
  
- show frequency shift seen and note that it is pretty negligible
  - the 'beam maps' of SNR and frequency shift, that is
    
total_attrs_xz_5_5_11_20_57.p


* Paper Plots
** Plot of the Forward and Reverse Raytrace Distributions
*** z = -10

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(5, 5))
out_removed = remove_outliers(get_rays_at_z(out, csims.FOCUS[2] - 10), threshold=5)
points = out_removed[[0, 1, 2]]
sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=False, 
            cmap='viridis', thresh=0.01, levels=20, alpha=.4)

shift_z_data = shift_snr_data[np.where(shift_snr_data[:, 2] == -10)]
plt.scatter(shift_z_data[:, 0], shift_z_data[:, 1], c=shift_z_data[:, 3],
            norm=mpl.colors.LogNorm())



plt.scatter(0, 0, s=1, color='black')
plt.axis('equal')
plt.xlim(-4, 4)
plt.ylim(-4, 4)
plt.title('z shift = %.1f' %(-10 - csims.FOCUS[2]))
plt.show()


# plt.figure(figsize=(10, 10))
# shift_z_data = shift_snr_data[np.where(shift_snr_data[:, 2] == -10)]
# plt.scatter(shift_z_data[:, 0], shift_z_data[:, 1], c=shift_z_data[:, 3],
#             norm=mpl.colors.LogNorm())
# plt.title('z shift = %s' %z)
# plt.colorbar(label='# of rays making it through the FTS')
# plt.axis('equal')
# plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ca7c7fb1ce23aa981f82e66688b34a7e988d0967.png]]

*** z = 0

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(5, 5))
out_removed = remove_outliers(get_rays_at_z(out, csims.FOCUS[2]), threshold=5)
points = out_removed[[0, 1, 2]]
sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=False, 
            cmap='viridis', thresh=0.01, levels=20, alpha=.4)

shift_z_data = shift_snr_data[np.where(shift_snr_data[:, 2] == 0)]
plt.scatter(shift_z_data[:, 0], shift_z_data[:, 1], c=shift_z_data[:, 3],
            norm=mpl.colors.LogNorm())

plt.scatter(0, 0, s=1, color='black')
plt.axis('equal')
plt.xlim(-.8, .8)
plt.ylim(-.8, .8)
plt.title('z shift = %.1f' %(0))
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/c1b3c8a088c93106b8b80ca240c26df533e93c2d.png]]

** A Raytrace Plot showing the FTS and Coupling optics
- use the highest resolution here for the surfaces- going to nix that
- do the raytrace in reverse
  
#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = np.add(csims.FOCUS, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'black', fig, n_linear=10,
                                                      theta_bound=.23, plot=True, alpha=.25)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

rays, path_diffs = transform_rays_end_tilt_path_diffs(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=10, fig=fig, ray_alpha=.05)

fig.show()
#+END_SRC

#+RESULTS:
: initial number of rays = 100
: total number of rays making past the first ellipse = 100
: total number of rays making it all the way through = 80
: initial number of rays = 100
: total number of rays making past the first ellipse = 100
: total number of rays making it all the way through = 80

[[/Users/tommyalford/Desktop/plots/20_raytrace.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
shift = [0, 0, 0]
start_position = np.add(csims.FOCUS, shift)

fig = go.Figure()

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

out = csims.run_rays_through_coupling_optics_reversed(start_position, fts_geo, 'black', fig, n_linear=1,
                                                      theta_bound=0, plot=False, alpha=.15)

start_rays_mcmahon = [csims.convert_to_ray_mcmahon(out_arr) for out_arr in out.T]

rays, path_diffs = transform_rays_end_tilt_path_diffs(
    start_rays_mcmahon, config, plot=True, plot_mirror_position=20, fig=fig, ray_alpha=1)

fig.update_layout(scene = dict(xaxis_title='Z (mm)', yaxis_title='Y (mm)',
                                zaxis_title='X (mm)',
                    yaxis=dict(range=[-400, 400]),
                    zaxis=dict(range=[-50, 50]),
                    xaxis=dict(range=[-300, 300])),
                    width=700)#,

fig.show()
#+END_SRC

#+RESULTS:
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1
: initial number of rays = 1
: total number of rays making past the first ellipse = 1
: total number of rays making it all the way through = 1

** Amplitude Transfer Functions
- test out what happens when we plot over radius as well
- e.g. plot frequency shift vs radius from center
  - then could color this by z coordinate or something too
*** Amplitude Transfer Function, z=0
- see plot:
[[/Users/tommyalford/Desktop/paper_figures/z_0_transfers.png]]
[[/Users/tommyalford/Desktop/paper_figures/z_0_transfers.png]]

*** Amplitude Transfer Function, z=-10
#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xyz_20_20_z_shift=-10_20_57.p')

def plot_freq_shifts(y_data, z_data, values, clabel=None, cmap=None):
    plt.figure(figsize=(10, 5))
    plt.scatter(y_data, values, c=z_data, cmap=cmap, alpha=.6)
    if (clabel is not None):
        plt.colorbar(label=clabel)
    plt.grid()

cmap = plt.get_cmap('inferno')
s1 = np.where((shifts[:, 2] <= 100) & (shifts[:, 0] == np.min(np.abs(shifts[:, 0]))))
#s1 = np.where((shifts_xy[:, 0]) == 0)
plot_freq_shifts(25.4 * shifts[:, 1][s1], 25.4 * shifts[:, 0][s1], 1 / (1 + data[:, 6][s1]),
                 clabel='z shift (mm)', cmap=cmap)
#plt.ylim(-.005, .007)
plt.ylim(1, 1.2)
plt.xlabel('y shift (mm)')
plt.ylabel('fractional frequency shift (Ghz)')
plt.title('frequency correction factor, detector shifting in x and y (z centered)')
#plt.savefig('frequency_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/d23039218f1304f4b16a0b6c8f92513197c01701.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(np.sqrt(shifts[:, 0][s1] ** 2 + shifts[:, 1][s1] ** 2), 
         1 / (1 + data[:, 6][s1]), '.')
plt.axhline(notebook_utils.smart_rms(1 / (1 + data[:, 6][s1]), 20, 3)[0], color='black')
plt.ylim(1, 1.1)
#plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/4bdcda1727cd0ca9820f7a311d6cf5e11a08f79d.png]]

# Maybe try getting the frequency shift here but for nonoutliers and do it at
# specific frequencies-- e.g. 90, 150, etc to also reduce outliers for now i'd
# say just keep this as-is though..

#+BEGIN_SRC jupyter-python :session py :kernel python3
notebook_utils.smart_rms(1 / (1 + data[:, 6][s1]), 20, 3)
#+END_SRC

#+RESULTS:
: (1.051896375632559, 0.0045848488165254825)

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.scatter(shifts[:, 0][s1], shifts[:, 1][s1], c=1 / (1 + data[:, 6][s1]), 
            cmap='inferno', vmin=1, vmax=1.1)
#plt.xlim(-9.5, 9.5)
plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/2251f529f94ca89f7b54702bf8e66b21f9fe311c.png]]

*** Amplitude Transfer Function varying z
- see plot:
[[/Users/tommyalford/Desktop/paper_figures/z_shift_transfers.png]]
[[/Users/tommyalford/Desktop/paper_figures/z_shift_transfers.png]]

*** Amplitude Transfer Function, z=0 freq shifted
-done
*** Amplitude Transfer Function varying z freq shifted
-done
** Frequency Shift
*** No source tilt

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(np.array(data[:, 2])[0])
plt.plot(np.array(data[:, 2])[1])
plt.plot(np.array(data[:, 2])[2])
plt.plot(np.array(data[:, 2])[3])
plt.plot(np.array(data[:, 2])[60])
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/59d4e1b29629a99c10ac0edfa6b637c3b719f3cd.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
index_f
#+END_SRC

#+RESULTS:
: 25

#+BEGIN_SRC jupyter-python :session py :kernel python3
f = 40
index_f = np.where(freqs == f)[0][0]
plt.plot(rs[s1], 100 * (freq_shift_data[:, index_f] + .015), '.')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/7a2653168f4cd76f73ab9b0595ace89b7edaa764.png]]



#+BEGIN_SRC jupyter-python :session py :kernel python3
min_vals = np.min(100 * (freq_shift_data + .015), axis=0)
max_vals = np.max(100 * (freq_shift_data + .015), axis=0)
plt.plot(freqs, min_vals, label='mins')
plt.plot(freqs, max_vals, label='maxes')
plt.plot(freqs, max_vals - min_vals, label='diffs')
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/7faad2634f47877f7ba41e5ef4e0d89b0ccf68f7.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
# now for f in this range, get the min and max intervals
for f in freqs:
    index_f = np.where(freqs == f)[0][0]
    #min_val = np.min(100 * freq_shfit_data[s1][:, index_f] + .015)
    #max_val = np.min(100 * freq_shfit_data[s1][:, index_f] + .015)
    plt.plot(rs[s1], 100 * (freq_shift_data[:, index_f] + .015), '.')
    plt.show()
#+END_SRC

#+BEGIN_SRC jupyter-python :session py :kernel python3
min_ind = np.where(rs == np.min(rs))[0][0]
plt.plot(freq_shift_data[min_ind])
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/50f92900168d73f7d8456bb85847ca27a1f4b87b.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
test = data[22, -1][299, :, 2].flatten()
plt.hist(test[test.nonzero()])
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/4be3d5fb962748c72804cc0023a29db28d482ed9.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
from sklearn.cluster import KMeans
km = KMeans(n_clusters=2)
km.fit(test[test.nonzero()].reshape(-1, 1))
np.diff(km.cluster_centers_[:, 0])[0] / 40
#+END_SRC

#+RESULTS:
: -0.9839483700079199

# try making some fake interferograms to test this out....

#+BEGIN_SRC jupyter-python :session py :kernel python3
diffs = []
poses = np.linspace(-20, 20, 400)
for i, pos in enumerate(poses):
    test = data[22, -1][i, :, 2].flatten()
    km = KMeans(n_clusters=2)
    km.fit(test[test.nonzero()].reshape(-1, 1))
    diff = np.abs(np.diff(km.cluster_centers_[:, 0])[0] / (4 * pos))
    diffs.append(diff)

plt.plot(poses, diffs, '.')
plt.show()
#+END_SRC

#+RESULTS:


[[file:./.ob-jupyter/81800047bf058ad5aff6d81c3a0b4d5c4bfe1159.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.median(1 - np.array(diffs))
#+END_SRC

#+RESULTS:
: 0.013721353493440835

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(poses, 1 - np.array(diffs), '.')
plt.grid()
plt.ylim(0, .02)
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/556ee79290262719906774546f649aac3cff0392.png]]

# Ok I should really test this path length difference now...

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.arccos(.98) * 180 / np.pi
#+END_SRC

#+RESULTS:
: 11.478340954533579

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')
freqs = data[:, -2][0]
plt.figure(figsize=(6, 5))
rs = np.sqrt(shifts[:, 0] ** 2 + shifts[:, 1] ** 2)
s1 = np.where((shifts[:, 2] == 0) & (rs <= (15 / 25.4)))
freq_shift_data = np.array(list(data[:, 2][s1]))
index_40 = np.where(freqs == 40)[0][0]
plt.scatter(25.4 * shifts[:, 0][s1], 25.4 * shifts[:, 1][s1], 
            c=(freq_shift_data[:, index_40] + .015) * 100, 
            cmap='inferno')
#plt.xlim(-9.5, 9.5)
plt.colorbar(label='frequency shift (%)')
plt.xlabel('detector x position (mm)')
plt.ylabel('detector y position (mm)')
plt.title('Frequency shift at z = 0')
plt.axis('equal')
plt.tight_layout()
#plt.savefig('/Users/tommyalford/Desktop/paper_figures/focal_plane_freq_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/c60393d3661a6855e94a259b4b655ffac3166b57.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')
plt.figure(figsize=(6, 5))
s1 = np.where((shifts[:, 2] == 0) & (np.abs(shifts[:, 1]) <= 1))
plt.scatter(25.4 * shifts[:, 0][s1], 25.4 * shifts[:, 1][s1], c=100 * (data[:, 6][s1] - np.min(data[:, 6][s1])), 
            cmap='inferno')
#plt.xlim(-9.5, 9.5)
plt.colorbar(label='frequency shift (%)')
plt.xlabel('detector x position (mm)')
plt.ylabel('detector y position (mm)')
plt.title('Frequency shift at z = 0')
plt.axis('equal')
plt.tight_layout()
#plt.savefig('/Users/tommyalford/Desktop/paper_figures/focal_plane_freq_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/8fb54c04239200099bc41af535e4ae0021c87b31.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')
plt.figure(figsize=(6, 5))
plt.scatter(25.4 * shifts[:, 0][s1], 25.4 * shifts[:, 1][s1], c=100 * (data[:, 6][s1] - np.min(data[:, 6][s1])), 
            cmap='inferno')
#plt.xlim(-9.5, 9.5)
plt.colorbar(label='frequency shift (%)')
plt.xlabel('detector x position (mm)')
plt.ylabel('detector y position (mm)')
plt.title('Frequency shift at z = 0')
plt.axis('equal')
plt.tight_layout()
#plt.savefig('/Users/tommyalford/Desktop/paper_figures/focal_plane_freq_shift.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/8fb54c04239200099bc41af535e4ae0021c87b31.png]]

*** Source Tilt

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.figure(figsize=(6, 5))
data_freq_shift, shifts_freq_shift = load_data('data/total_attrs_xy_15_15_20_57_freq_shift.p')
plt.scatter(25.4 * shifts_freq_shift[:, 0][s1], 25.4 * shifts_freq_shift[:, 1][s1], 
            c=100 * (data_freq_shift[:, 6][s1] - np.mean(data_freq_shift[:, 6][s1])), 
            cmap='RdBu', norm=mpl.colors.TwoSlopeNorm(vcenter=0))
#plt.xlim(-9.5, 9.5)

plt.colorbar(label='frequency shift from (%)')
plt.xlabel('detector x position (mm)')
plt.ylabel('detector y position (mm)')
plt.title('Frequency shift at z = 0, tilted source')
plt.axis('equal')
plt.tight_layout()
plt.savefig('/Users/tommyalford/Desktop/paper_figures/focal_plane_freq_shift_source_tilt.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/d8a6db4120e642716d91112e45f6acb8ecdee141.png]]

** Loss tangent color correction plot with error bars
- check the distance out for this too
  
  #+BEGIN_SRC jupyter-python :session py :kernel python3
out = csims.run_rays_through_coupling_optics_reversed(
    csims.FOCUS, fts_geo, None, None, n_linear=25,
theta_bound=.23, plot=False)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean(out[4]), np.std(out[4])
#+END_SRC

#+RESULTS:
: (0.7600722774650247, 0.026223519625013778)

#+BEGIN_SRC jupyter-python :session py :kernel python3
100 * np.std(out[4]) / np.mean(out[4])
#+END_SRC

#+RESULTS:
: 3.4501349940658077

#+BEGIN_SRC jupyter-python :session py :kernel python3
freqs = np.arange(15, 300)
plt.figure(figsize=(6, 4))
mpl.rcParams.update({'font.size': 13})
power_vals = []
for freq in freqs:
    power = np.mean(np.power(np.mean(out[4]), (freq / 300)))
    power_vals.append(power)

lower_limit = np.power(power_vals, 1e-4 / 3e-4)
upper_limit = np.power(power_vals, 5e-4 / 3e-4)

plt.plot(freqs, power_vals / np.max(power_vals), color='red')

plt.fill_between(freqs, lower_limit / np.max(lower_limit), upper_limit / np.max(upper_limit), 
                 color='lightpink')
plt.grid()
plt.ylim(0, 1)
plt.xlim(15, 300)
plt.title('Dissipative loss in coupling optics lenses, \n color correction limits')
plt.xlabel('frequency (Ghz)')
plt.ylabel('average ray intensity, normalized')
plt.tight_layout()
#plt.savefig('/Users/tommyalford/Desktop/paper_figures/loss_tangent_plot.png')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/f0aee413007cc1a5fbc8fa8e982feb150f6583c0.png]]

** ACT channel positions
- not really sure how much to show here, maybe just one run as an example
[[/Users/tommyalford/Desktop/paper_figures/example_ACT_run.png]]
[[/Users/tommyalford/Desktop/paper_figures/example_ACT_run.png]]
** All ACT Bands
*** Initial
*** Log
- let's just say I already have both of these for now
  
** Example run for ACT? maybe leave this out
- leaving this out
** Plot of the left/right asymmetry shifts for ACT
- for now don't include the correction
  
[[/Users/tommyalford/Desktop/paper_figures/freq_shift_ACT.png]]

** Image of the FTS Mounted above the window
- get from slides
[[/Users/tommyalford/Desktop/paper_figures/cryo_mount.png]]
  
** Initial passband measurements of the optics tube
- show the averages only
[[/Users/tommyalford/Desktop/paper_figures/initial_averages.png]]
[[/Users/tommyalford/Desktop/paper_figures/initial_averages.png]]
** Some FTS 'beam maps' for SNR and also center, upper edge, lower edge
- will do these later, might not even be necessary
** the NDF corrected bands along with bootstrapping errors
[[/Users/tommyalford/Desktop/paper_figures/corrected_averages.png]]
[[/Users/tommyalford/Desktop/paper_figures/corrected_averages.png]]
- just take from the plot!
** Run at z=10 a 20x20 grid of x and y values
** Run at all z values changing just r and z- 40 r and 20 z should be pretty good
** Checking to see what happens if we change the tilt angle in x

* Making the color corrections
** Frequency shift correction

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xy_15_15_20_57.p')
s1 = np.where((shifts[:, 2] == 0) & (np.abs(shifts[:, 1]) <= ((10 / np.sqrt(2)) / 25.4)))
plt.plot(25.4 * np.sqrt(shifts[:, 0][s1] ** 2 + shifts[:, 1][s1] ** 2), 
         1 / (1 + data[:, 6][s1]), '.')
#plt.xlim(-9.5, 9.5)
#plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:

[[file:./.ob-jupyter/86d178625ce2cce1e9b90cde624b7605f6d4f1fd.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
# What I should really do is fit this distribution to a function in R
x_vals = (25.4 * np.sqrt(shifts[:, 0][s1] ** 2 + shifts[:, 1][s1] ** 2))
inds = np.argsort(x_vals)
y_vals = 1 / (1 + data[:, 6][s1])
plt.plot(x_vals[inds], y_vals[inds], '.')
#+END_SRC

#+RESULTS:
:RESULTS:
: [<matplotlib.lines.Line2D at 0x7fa7202d6b80>]
[[file:./.ob-jupyter/3649990c546fdf5ffd09f2096d88002ca1343010.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.savetxt('frequency_shift_fit_data.dat', np.array([x_vals[inds], y_vals[inds]]).T)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.hist(1 / (1 + data[:, 6][s1]))
plt.grid()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/2ff0ee1130387449830f1251767fcf20020d6a86.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.median(1 / (1 + data[:, 6][s1]))
#+END_SRC

#+RESULTS:
: 1.013864614089067

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.max(1 / (1 + data[:, 6][s1])) - np.median(1 / (1 + data[:, 6][s1]))
#+END_SRC

#+RESULTS:
: 0.001482254473464062

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.min(data[:, 6][s1])
#+END_SRC

#+RESULTS:
: -0.015114902145961503

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean(data[:, 6][s1])
#+END_SRC

#+RESULTS:
: -0.013483679558610013

#+BEGIN_SRC jupyter-python :session py :kernel python3
11.4 * 1.414
#+END_SRC

#+RESULTS:
: 16.1196

#+BEGIN_SRC jupyter-python :session py :kernel python3
.7 * 25.4
#+END_SRC

#+RESULTS:
: 17.779999999999998

#+BEGIN_SRC jupyter-python :session py :kernel python3
.6 * 25.4
#+END_SRC

#+RESULTS:
: 15.239999999999998


* Testing the path length difference for a centered ray

- should also make the amplitude just the max of the interferogram... maybe?
- try fitting a sinewave instead of taking the FFT!
  
#+BEGIN_SRC jupyter-python :session py :kernel python3
import notebook_utils
import RayTraceFunctionsv2 as rt
n_linear = 2
FTS_stage_throw = 20.     # total throw extent in mm
FTS_stage_step_size = 0.1  # FTS step size in mm
# n_mirror_positions = (20 * 2 / .1)
n_mirror_positions = (2 * FTS_stage_throw / FTS_stage_step_size)
ymax = FTS_stage_throw

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = rt.get_possible_paths()

# x_vals = np.linspace(-.65, .65, 1)
# y_vals = np.linspace(-.65, .65, 1)
# z_vals = np.linspace(0, 0, 1)

x_vals = np.linspace(0, 0, 1)
y_vals = np.linspace(0, 0, 1)
z_vals = np.linspace(0, 0, 1)

start_rays = csims.get_final_rays_reversed([0, 0, 0], theta_bound=.00001, 
                                           n_linear=n_linear)
transformed_start_rays = notebook_utils.transform_rays_to_fts_frame(start_rays)

delay, final_rays = rt.run_all_rays_through_sim_optimized(
    transformed_start_rays, config, n_mirror_positions, paths=possible_paths, 
    ymax=FTS_stage_throw, progressbar=True)
#+END_SRC

#+RESULTS:
: 100%|██████████| 400/400 [00:24<00:00, 16.34it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_mat = notebook_utils.rays_to_matrix(final_rays)
nyquist_freq = notebook_utils.c / ((2 * ymax / n_mirror_positions) * 4 * 2)
freqs = np.arange(15, nyquist_freq - 10 + 1)
gaussian_shifts, peak_shifts, gaussian_amplitudes, fft_maxes = notebook_utils.plot_shifts(
    delay, ray_mat, freqs, ymax, shift=shift)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(freqs, gaussian_shifts)
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/688ecd4efa64e42245debcbfe411f6087fc746f2.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
diffs = []
for i, pos in enumerate(delay):
    test = ray_mat[i, :, 2].flatten()
    km = KMeans(n_clusters=2)
    km.fit(test[test.nonzero()].reshape(-1, 1))
    diff = np.abs(np.diff(km.cluster_centers_[:, 0])[0] / pos)
    diffs.append(diff)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(poses, diffs, '.')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/9305b969254d55eb8e4be8691ae37ac2ee9af2f5.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / np.array(diffs[0:10])
#+END_SRC

#+RESULTS:
: array([1.01833848, 1.01833868, 1.01833886, 1.01833905, 1.01833924,
:        1.01833943, 1.01833961, 1.01833979, 1.01833998, 1.01834016])

#+BEGIN_SRC jupyter-python :session py :kernel python3
gaussian_shifts[:5]
#+END_SRC

#+RESULTS:
: [-0.015747573177295374,
:  -0.015097858909422612,
:  -0.015630704705841936,
:  -0.015328017973372157,
:  -0.015583499437839035]

At this point I think I should sum out the fields and look at the interference
terms directly... why are these different? the path length difference is always
the same relative to position. the same relative to position.....

#+BEGIN_SRC jupyter-python :session py :kernel python3
final_rays[0][:8]
#+END_SRC

#+RESULTS:
#+begin_example
[[0.785398,
  8.399445063175851e-13,
  [251.2262663012911, 330.56917566303065, 0.0],
  array([0.18871768, 0.98203138, 0.        ]),
  3411.632669599506],
 [2.3561943267948964,
  1.3807405046434805e-12,
  [251.22626630129116, 330.56917566303065, -1.1927818218587285e-35],
  [0.1887176789690118, 0.9820313832279235, 3.241720550536643e-40],
  3411.632669599505],
 [2.3561943267948964,
  0.09455966963802497,
  [251.2262663012911, 330.56917566303065, 0.0],
  [0.18871767896901168, 0.9820313832279235, 0.0],
  3411.632669599506],
 [2.3561943267948964,
  1.3807258491023549e-12,
  [236.3833345342063, 333.4262436035454, -2.8657350755951274e-14],
  [0.18873748245978889, 0.9820275773697708, -6.94871757858078e-19],
  3490.1920103297334],
 [0.785398,
  0.15544000725023469,
  [236.38333453420634, 333.4262436035454, -2.865735075595127e-14],
  array([ 1.88737482e-01,  9.82027577e-01, -6.94871758e-19]),
  3490.1920103297334],
 [0.785398,
  8.399355908577134e-13,
  [236.3833345342063, 333.42624360354546, -2.8657350755951274e-14],
  array([ 1.88737482e-01,  9.82027577e-01, -6.94871758e-19]),
  3490.1920103297334],
 [0.785398,
  0.15544165715505767,
  [251.22626630129113, 330.5691756630306, -1.1927818218587285e-35],
  array([1.88717679e-01, 9.82031383e-01, 3.24172055e-40]),
  3411.632669599505],
 [2.3561943267948964,
  0.09455866595305502,
  [236.38333453420634, 333.42624360354546, -2.8657350755951274e-14],
  [0.18873748245978894, 0.9820275773697709, -6.94871757858078e-19],
  3490.1920103297334]]
#+end_example


#+BEGIN_SRC jupyter-python :session py :kernel python3
test_rays = final_rays[0][:8]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
polarizations = np.array(test_rays, dtype='object')[:, 0]
intensities = np.array(test_rays, dtype='object')[:, 1]
distances = np.array(test_rays, dtype='object')[:, 4]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
distances
#+END_SRC

#+RESULTS:
: array([3411.632669599506, 3411.632669599505, 3411.632669599506,
:        3490.1920103297334, 3490.1920103297334, 3490.1920103297334,
:        3411.632669599505, 3490.1920103297334], dtype=object)

#+BEGIN_SRC jupyter-python :session py :kernel python3
test_rays = ray_mat[:, :8, :]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
c = 300.
test_rays = ray_mat[:, :8, :]
lambda_calc = c / 300.
ij = rt.get_interferogram(test_rays, lambda_calc)
plt.plot(delay, ij)
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/06a09c82b8cdc75acc71dd417ef4c7acdff8c9c6.png]]



Now make a new matrix of test rays that have our mathematica distances and see
if things match up

I should really go to bed though... but I want to see this through goddamnit.


#+BEGIN_SRC jupyter-python :session py :kernel python3
import numpy, scipy.optimize

def fit_sin(tt, yy):
    '''Fit sin to the input time sequence, and return fitting parameters "amp", "omega", "phase", "offset", "freq", "period" and "fitfunc"'''
    tt = numpy.array(tt)
    yy = numpy.array(yy)
    ff = numpy.fft.fftfreq(len(tt), (tt[1]-tt[0]))   # assume uniform spacing
    Fyy = abs(numpy.fft.fft(yy))
    guess_freq = abs(ff[numpy.argmax(Fyy[1:])+1])   # excluding the zero frequency "peak", which is related to offset
    guess_amp = numpy.std(yy) * 2.**0.5
    guess_offset = numpy.mean(yy)
    guess = numpy.array([guess_amp, 2.*numpy.pi*guess_freq, 0., guess_offset])

    def sinfunc(t, A, w, p, c):  return A * numpy.sin(w*t + p) + c
    popt, pcov = scipy.optimize.curve_fit(sinfunc, tt, yy, p0=guess)
    A, w, p, c = popt
    f = w/(2.*numpy.pi)
    fitfunc = lambda t: A * numpy.sin(w*t + p) + c
    return {"amp": A, "omega": w, "phase": p, "offset": c, "freq": f, "period": 1./f, "fitfunc": fitfunc, "maxcov": numpy.max(pcov), "rawres": (guess,popt,pcov)}
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, fit_sin(np.array(delay), ij)['fitfunc'](np.array(delay)))
plt.plot(delay, ij)
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/6be689a58720c7479a901c42e6237d9b1e1db5ab.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.arccos(1 / ((2 * np.pi / (fit_sin(np.array(delay), ij)['omega'])) / lambda_calc)) * (180 / np.pi)
#+END_SRC

#+RESULTS:
: 10.892186719233774

#+BEGIN_SRC jupyter-python :session py :kernel python3
((2 * np.pi / (fit_sin(np.array(delay), ij)['omega'])) / lambda_calc)
#+END_SRC

#+RESULTS:
: 1.0183460229247183

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / np.cos(10.8954 * np.pi / 180)
#+END_SRC

#+RESULTS:
: 1.0183570144549947

I swear to god if I really just need to fit a sinewave instead I am going to be
PISSED but also very happy....

Should check this instead now changing to a sine wave fit (with decaying
envelope maybe) and also changing the amplitude computation...

Then I should also check this redoing the computation but with all the
frequencies at once to see the color correction I get. And the frequency shift
too.

ok I am done for the night

Next time I will first try generating some perfect cosine data to see how that
changes things

#+BEGIN_SRC jupyter-python :session py :kernel python3
import scipy.signal
fftfreq = np.fft.rfftfreq(len(ij), d=(4 * 2 * 20 / 400) / 1.018357) 
plt.plot(300 * fftfreq, np.abs(np.fft.rfft(ij * scipy.signal.triang(len(ij)))))
plt.xlim(295, 310)
plt.axvline((c / lambda_calc), color='black', label='actual frequency')
plt.xlabel('frequency')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/74f7d613a4497af6715314da40836ae2b3c52201.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 - (301 / 300.)
#+END_SRC

#+RESULTS:
: -0.0033333333333334103

#+BEGIN_SRC jupyter-python :session py :kernel python3
1.0183 - 1.0153
#+END_SRC

#+RESULTS:
: 0.0029999999999998916


#+BEGIN_SRC jupyter-python :session py :kernel python3
def cosine(t, freq=3, phi=0):
    return np.cos(2 * np.pi * freq * t + phi)

times = np.arange(-10, 10 + .05, .2)
plt.plot(times, cosine(times, freq=2))
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/eeab9e9a0deea48088b9d3d552742170557a5d14.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
fftfreq = np.fft.rfftfreq(len(times), d=times[1] - times[0]) 
plt.plot(fftfreq, np.abs(np.fft.rfft(cosine(times))))
plt.grid()
plt.axvline(2, color='black')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ef198603fd1e3270a888ba66acbd4722342e07ac.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
1 / (times[1] - times[0])
#+END_SRC

#+RESULTS:
: 5.000000000000001

This looks like a sampling phenomenon...

* Trying a larger throw

#+BEGIN_SRC jupyter-python :session py :kernel python3
n_linear = 2
FTS_stage_throw = 40.     # total throw extent in mm
FTS_stage_step_size = 0.1  # FTS step size in mm
# n_mirror_positions = (20 * 2 / .1)
n_mirror_positions = (2 * FTS_stage_throw / FTS_stage_step_size)
ymax = FTS_stage_throw

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = rt.get_possible_paths()

# x_vals = np.linspace(-.65, .65, 1)
# y_vals = np.linspace(-.65, .65, 1)
# z_vals = np.linspace(0, 0, 1)

x_vals = np.linspace(0, 0, 1)
y_vals = np.linspace(0, 0, 1)
z_vals = np.linspace(0, 0, 1)

start_rays = csims.get_final_rays_reversed([0, 0, 0], theta_bound=.00001, 
                                           n_linear=n_linear)
transformed_start_rays = notebook_utils.transform_rays_to_fts_frame(start_rays)

delay, final_rays = rt.run_all_rays_through_sim_optimized(
    transformed_start_rays, config, n_mirror_positions, paths=possible_paths, 
    ymax=FTS_stage_throw, progressbar=True)
#+END_SRC

#+RESULTS:
: 100%|██████████| 800/800 [00:51<00:00, 15.42it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_mat = notebook_utils.rays_to_matrix(final_rays)
nyquist_freq = notebook_utils.c / ((2 * ymax / n_mirror_positions) * 4 * 2)
freqs = np.arange(15, nyquist_freq - 10 + 1)
gaussian_shifts, peak_shifts, gaussian_amplitudes, fft_maxes = notebook_utils.plot_shifts(
    delay, ray_mat, freqs, ymax, shift=shift)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
test_rays = ray_mat[:, :8, :]
lambda_calc = c / 300.
ij = rt.get_interferogram(test_rays, lambda_calc)
plt.plot(delay, ij, '.')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/a5e5c93c56df38b285f2bd9575a2313b147802d6.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, fit_sin(np.array(delay), ij)['fitfunc'](np.array(delay)))
plt.plot(delay, ij)
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/6174dcb033e9ff013bbede8659409a6808491731.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.arccos(1 / ((2 * np.pi / (fit_sin(np.array(delay), ij)['omega'])) / lambda_calc)) * (180 / np.pi)
#+END_SRC

#+RESULTS:
: 10.882150402641441

#+BEGIN_SRC jupyter-python :session py :kernel python3
((2 * np.pi / (fit_sin(np.array(delay), ij)['omega'])) / lambda_calc)
#+END_SRC

#+RESULTS:
: 1.0183117142832243

#+BEGIN_SRC jupyter-python :session py :kernel python3
fftfreq = np.fft.rfftfreq(len(ij), d=(4 * 2 * 40 / 800) / 1.018357) 
plt.plot(300 * fftfreq, np.abs(np.fft.rfft(ij * scipy.signal.triang(len(ij)))))
plt.xlim(295, 305)
plt.axvline((c / lambda_calc), color='black', label='actual frequency')
plt.xlabel('frequency')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ffe6bcf03b8739ca6bd89d90ad17822c6b416544.png]]

* Try making a whole frequency spectrum at once

#+BEGIN_SRC jupyter-python :session py :kernel python3
c = 300.
n_linear = 1
FTS_stage_throw = 20.     # total throw extent in mm
FTS_stage_step_size = 0.1  # FTS step size in mm
# n_mirror_positions = (20 * 2 / .1)
n_mirror_positions = (2 * FTS_stage_throw / FTS_stage_step_size)
ymax = FTS_stage_throw

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = rt.get_possible_paths()

start_rays = csims.get_final_rays_reversed([0, 0, 0], theta_bound=1e-15, 
                                           n_linear=n_linear)
transformed_start_rays = notebook_utils.transform_rays_to_fts_frame(start_rays)

delay, final_rays = rt.run_all_rays_through_sim_optimized(
    transformed_start_rays, config, n_mirror_positions, paths=possible_paths, 
    ymax=FTS_stage_throw, progressbar=True)
#+END_SRC

#+RESULTS:
: 100%|██████████| 400/400 [00:07<00:00, 56.14it/s]

# have to change ray to include a frequency, update the power sum computation

#+BEGIN_SRC jupyter-python :session py :kernel python3
def rays_to_matrix_frequency(rays, freqs):
    max_rays_num = max([len(y_rays) for y_rays in rays])
    # get max number and pad to that these fit nicely into a matrix
    total_rays = []
    for y_rays in rays:
        frequency_rays = []
        for frequency in freqs:
            # only keep polarization, intensity, distance
            # then add frequency
            power_vals_mask = [0, 1, 4]
            power_vals = np.array(np.array(y_rays, dtype='object')[
                :, power_vals_mask], dtype='float64')
            # add a frequency dimension to this
            frequency_vals = np.ones((len(power_vals), 1)) * frequency
            total_power_vals = np.concatenate((power_vals, frequency_vals), axis=1)
            # pad rows now
            total_vals = np.zeros((max_rays_num, total_power_vals.shape[1]))
            total_vals[:power_vals.shape[0]] = total_power_vals
            frequency_rays.extend(total_vals)
        total_rays.append(frequency_rays)

    return np.array(total_rays)

def get_interferogram_frequency(outrays, frequencies):
    for freq in frequencies:
        theta = outrays[:, :, 0]
        intensity = outrays[:, :, 1]
        distance = outrays[:, :, 2]
        wavelength = c / outrays[:, :, 3]

        phase = np.exp(1j * (distance * 2 * np.pi / wavelength))
        ex1 = np.sqrt(intensity) * np.cos(theta)
        ey1 = np.sqrt(intensity) * np.sin(theta)

        ex = ex1 * phase
        ey = ey1 * phase

        return np.square(np.abs((ex.sum(axis=1)))) + np.square(
            np.abs((ey.sum(axis=1))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_frequency_matrix = rays_to_matrix_frequency(final_rays, np.linspace(280, 300, 10000))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_frequency_matrix.shape
#+END_SRC

#+RESULTS:
: (400, 80000, 4)

# make sure that this returns the same thing if we just have one frequency

#+BEGIN_SRC jupyter-python :session py :kernel python3
ij_test = get_interferogram_frequency(ray_frequency_matrix)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, ij_test)
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/407b79d252f322286419bff1641f3280f9a711d6.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
import scipy.signal
fftfreq = np.fft.rfftfreq(len(ij_test), d=(4 * 2 * 40 / 800) / 1.018357) 
plt.plot(c * fftfreq, np.abs(np.fft.rfft(ij_test * np.hanning(
    len(ij_test)))))
plt.xlim(270, 320)
#plt.axvline(15, color='black', label='actual frequency')
plt.xlabel('frequency')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
: No handles with labels found to put in legend.
[[file:./.ob-jupyter/39c343b43cee6f2934444cd9db4b9cdc6d5c0fcd.png]]
:END:


#+BEGIN_SRC jupyter-python :session py :kernel python3
c * fit_sin(np.array(delay), ij_test)['freq'] * 1.0183
#+END_SRC

#+RESULTS:
: 2.4295446564669025

Wow, it only took insane resolution to actually get this spectrum to look
decent...  If I had more time I would probably try and speed up this
computation a ridiculous amount... it looks like the creation of the ray matrix
is the bottleneck so maybe we can do it in segments

yeah, that makes sense i'd say. seems like there will be a finite gain to it
though.  For fun let's try limiting the solid angle even more and see what
happens.

Or make the creation process simply better

Can also test this theory by summing an infinite number of sines at these
frequencies and see if it makes the sinc function lol

Try changing this so that different frequencies add incoherently

Ok I should change up the FTS Simulations to come from many different point
sources.

1. Test out the many ray interference to see that we get the sinc function we
   expect-- do this with a bandpass filter too!
   
** Part 1

#+BEGIN_SRC jupyter-python :session py :kernel python3
from tqdm import tqdm
def get_interferogram_frequency(outrays, frequencies, debug=True):
    theta = outrays[:, :, 0]
    intensity = outrays[:, :, 1]
    distance = outrays[:, :, 2]
    ex1 = np.sqrt(intensity) * np.cos(theta)
    ey1 = np.sqrt(intensity) * np.sin(theta)

    total_power = np.zeros(outrays.shape[0])
    for freq in tqdm(frequencies, disable=(not debug)):
        wavelength = c / freq
        phase = np.exp(1j * (distance * 2 * np.pi / wavelength))
        ex = ex1 * phase
        ey = ey1 * phase

        power = np.square(np.abs((ex.sum(axis=1)))) + np.square(
            np.abs((ey.sum(axis=1))))
        total_power += power
        
    return total_power
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
freqs = np.arange(120, 180 + .1, .1)
ray_mat = notebook_utils.rays_to_matrix(final_rays)
total_ij = get_interferogram_frequency(ray_mat, freqs)
#+END_SRC

#+RESULTS:

2. Change to point sources and 7mm aperture sizes for the detectors.
   hmmmmm does this change the frequency shift now?

   #+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, total_ij)
plt.show()
   #+END_SRC

   #+RESULTS:
   [[file:./.ob-jupyter/c67abe3c2a10d45f32313f1c5da7d87a2a66263b.png]]
   
#+BEGIN_SRC jupyter-python :session py :kernel python3
import scipy.signal
fftfreq = np.fft.rfftfreq(len(total_ij), d=(4 * 2 * 40 / 800) / 1.018357) 
fft_data = np.abs(np.fft.rfft(total_ij * np.hanning(len(total_ij))))
plt.plot(c * fftfreq[3:], fft_data[3:])
plt.xlim(100, 200)
plt.axvline(120, color='black', label='actual frequency')
plt.axvline(180, color='black', label='actual frequency')
plt.xlabel('frequency')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/f49cca222010e247f1f29f7c7089f655e51ea727.png]]


Ok the only difference between this and Mathematica is that this is discretely
sampled.

#+BEGIN_SRC jupyter-python :session py :kernel python3
fftfreq[3:][np.where(fft_data[3:] >= 250)[0][0]] * c
#+END_SRC

#+RESULTS:
: 120.293420625

#+BEGIN_SRC jupyter-python :session py :kernel python3
fftfreq[3:][np.where(fft_data[3:] >= 250)[0][-1]] * c
#+END_SRC

#+RESULTS:
: 181.39484062499997

** 2. Now see what the interference interferogram/spectrum looks like!

#+BEGIN_SRC jupyter-python :session py :kernel python3
c = 300.
n_linear = 20
FTS_stage_throw = 20.     # total throw extent in mm
FTS_stage_step_size = 0.1  # FTS step size in mm
# n_mirror_positions = (20 * 2 / .1)
n_mirror_positions = (2 * FTS_stage_throw / FTS_stage_step_size)
ymax = FTS_stage_throw

with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = rt.get_possible_paths()

start_rays = csims.get_final_rays_reversed([0, 0, 0], theta_bound=.25, 
                                           n_linear=n_linear)
transformed_start_rays = notebook_utils.transform_rays_to_fts_frame(start_rays)

delay, final_rays = rt.run_all_rays_through_sim_optimized(
    transformed_start_rays, config, n_mirror_positions, paths=possible_paths, 
    ymax=FTS_stage_throw, progressbar=True)
#+END_SRC

#+RESULTS:
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 
: 100%|██████████| 400/400 [33:17<00:00,  4.99s/it]

#+BEGIN_SRC jupyter-python :session py :kernel python3
freqs = np.arange(120, 180 + .1, .1)
ray_mat = notebook_utils.rays_to_matrix(final_rays)
total_ij = get_interferogram_frequency(ray_mat, freqs)
#+END_SRC

#+RESULTS:
: 100%|██████████| 601/601 [00:57<00:00, 10.42it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, total_ij)
plt.show()

fftfreq = np.fft.rfftfreq(len(total_ij), d=(4 * 2 * 40 / 800) / 1.018357) 
fft_data = np.abs(np.fft.rfft(total_ij * np.hanning(len(total_ij))))
plt.plot(c * fftfreq[3:], fft_data[3:])
plt.xlim(100, 200)
plt.axvline(120, color='black', label='actual frequency')
plt.axvline(180, color='black', label='actual frequency')
plt.xlabel('frequency')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/45aceb2e3108fec9759bbad72db12b785d18ce57.png]]
# [goto error]
: 
: NameErrorTraceback (most recent call last)
: <ipython-input-6-83803e944077> in <module>
:       3 
:       4 fftfreq = np.fft.rfftfreq(len(total_ij), d=(4 * 2 * 40 / 800) / 1.018357)
: ----> 5 fft_data = np.abs(np.fft.rfft(total_ij * scipy.signal.triang(len(total_ij))))
:       6 plt.plot(c * fftfreq[3:], fft_data[3:])
:       7 plt.xlim(100, 200)
: 
: NameError: name 'scipy' is not defined
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
freqs = np.arange(20, 300 + .1, .1)
ray_mat = notebook_utils.rays_to_matrix(final_rays)
total_ij = get_interferogram_frequency(ray_mat, freqs, debug=True)
#+END_SRC

#+RESULTS:
: 100%|██████████| 2801/2801 [48:51<00:00,  1.05s/it]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, total_ij)
plt.show()

fftfreq = np.fft.rfftfreq(len(total_ij), d=(4 * 2 * 40 / 800) / 1.018357) 
fft_data = np.abs(np.fft.rfft(total_ij * np.hanning(len(total_ij))))
fft_data /= fft_data[13]
plt.plot(c * fftfreq[3:], fft_data[3:])
plt.ylim(0, 1.1)
plt.axvline(15, linestyle='--', color='black', alpha=.6)
plt.axvline(300, linestyle='--', color='black', alpha=.6)
#plt.xlim(298, 305)
plt.xlabel('frequency')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/cd4a050ef6ec9e9c9ebb621532f42996b23bb822.png]]
: No handles with labels found to put in legend.
[[file:./.ob-jupyter/78b5442bb3139b05384040cb2fc264ee03977d58.png]]
:END:

Now see what a wonky one looks like-- actually I can just get data from this myself

#+BEGIN_SRC jupyter-python :session py :kernel python3
data, shifts = load_data('data/total_attrs_xz_2_1_25_30_57.p')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
get_shift_index(data, [np.max(shifts[:, 0]), 0, np.max(shifts[:, 2])])
#+END_SRC

#+RESULTS:
: 5

#+BEGIN_SRC jupyter-python :session py :kernel python3
get_shift_index(data, [np.max(shifts[:, 0]), 0, np.min(shifts[:, 2])])
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC jupyter-python :session py :kernel python3
shifts[0]
#+END_SRC

#+RESULTS:
: array([ 0.49212598,  0.        , -1.96850394])

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_mat = data[5][-1]
delay = data[5][1]

#+BEGIN_SRC jupyter-python :session py :kernel python3
total_ij_defocus = get_interferogram_frequency(ray_mat, freqs, debug=True)
#+END_SRC

#+RESULTS:
: 100%|██████████| 2801/2801 [02:14<00:00, 20.76it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, total_ij_defocus)
plt.show()

fftfreq = np.fft.rfftfreq(len(total_ij_defocus), d=(4 * 2 * 40 / 800) / 1.018357) 
fft_data = np.abs(np.fft.rfft(total_ij_defocus * np.hanning(len(total_ij))))
fft_data /= fft_data[13]
plt.plot(c * fftfreq[3:], fft_data[3:])
plt.ylim(1e-2, 1.1)
plt.axvline(15, linestyle='--', color='black', alpha=.6)
plt.axvline(300, linestyle='--', color='black', alpha=.6)
#plt.xlim(298, 305)
plt.xlabel('frequency')
plt.yscale('log')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/58d8641e0ea626195d848b3569f059cfdf3a8945.png]]
: No handles with labels found to put in legend.
[[file:./.ob-jupyter/fcfd41c6c9d9be2116030618b74aebbfd7a7ff7e.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
freqs = np.arange(120, 180 + .1, .1)
total_ij_defocus_band = get_interferogram_frequency(ray_mat, freqs)
#+END_SRC

#+RESULTS:
: 100%|██████████| 601/601 [00:30<00:00, 19.50it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, total_ij_defocus_band)
plt.show()

fftfreq = np.fft.rfftfreq(len(total_ij_defocus_band), d=(4 * 2 * 40 / 800) / 1.018357) 
fft_data = np.abs(np.fft.rfft(total_ij_defocus_band * np.hanning(
    len(total_ij_defocus_band))))
fft_data /= fft_data[120]
plt.plot(c * fftfreq[3:], fft_data[3:])
plt.xlim(110, 190)
#plt.ylim(1e-2, 1.1)
plt.axvline(15, linestyle='--', color='black', alpha=.6)
plt.axvline(300, linestyle='--', color='black', alpha=.6)
#plt.xlim(298, 305)
plt.xlabel('frequency')
#plt.yscale('log')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/338b5604da07e1cd62e6c3c22abbf057926e92bf.png]]
: No handles with labels found to put in legend.
[[file:./.ob-jupyter/b8b8b9a9162a498dcd874a4902b651749a01c974.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
ray_mat_other = data[0][-1]
delay_other = data[0][1]

,#+BEGIN_SRC jupyter-python :session py :kernel python3
total_ij_defocus_other = get_interferogram_frequency(
    ray_mat_other, freqs, debug=True)
#+END_SRC

#+RESULTS:
: 100%|██████████| 601/601 [00:28<00:00, 20.95it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay_other, total_ij_defocus_other)
plt.show()

fftfreq = np.fft.rfftfreq(len(total_ij_defocus_other), d=(4 * 2 * 40 / 800) / 1.018357) 
fft_data = np.abs(np.fft.rfft(total_ij_defocus_other * np.hanning(
    len(total_ij_defocus_other))))
fft_data /= fft_data[120]
plt.plot(c * fftfreq[3:], fft_data[3:])
plt.xlim(110, 190)
#plt.ylim(1e-2, 1.1)
plt.axvline(15, linestyle='--', color='black', alpha=.6)
plt.axvline(300, linestyle='--', color='black', alpha=.6)
#plt.xlim(298, 305)
plt.xlabel('frequency')
#plt.yscale('log')
plt.legend()
plt.ylabel('power')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
i[[file:./.ob-jupyter/0bec919bdbb471b17fab155720cfe150a9645b25.png]]i
: No handles with labels found to put in legend.
[[file:./.ob-jupyter/7675bfc808c80a4f718225297775b2c4ed892409.png]]
:END:
* Changing to a forward raytrace and summing interferograms

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays_uniform(
    config['detector']['center'], 50., config['detector']['normal_vec'], 
    2, 30, 1, config, theta_bound=.5, check_rays=True)

# starting_rays = create_source_rays(
#     config['detector']['center'], 0.0, config['detector']['normal_vec'], 
#     50, config, theta_bound=.07, check_rays=True)

# theta bound at the start is around 

with open("lab_fts_dims_act_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=True,
                                                  fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards.shape
#+END_SRC

#+RESULTS:
: (11, 0)

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays(config['detector']['center'], 0.0, 
                                   config['detector']['normal_vec'], 30, config, 
                                   theta_bound=np.pi / 2)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

fig = go.Figure()

# plot the initial ray steps
all_points = []
all_vectors = []
all_distances = []
for path in possible_paths:
    total_ray_points, total_vectors, total_distances = step_rays(
        starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
        path, final_dist=238, debug=False)

    all_points.append(total_ray_points)
    all_vectors.append(total_vectors)
    all_distances.append(total_distances)

plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=True,
                                                  fig=fig, color='red')
fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards
#+END_SRC

#+RESULTS:
#+begin_example
array([[ 3.85653127e-02, -1.76047172e-02,  3.94511150e-02,
         2.85262479e-02, -3.15737771e-02, -2.78735100e-03,
        -4.88214401e-02,  5.19007647e-02, -1.31530940e-01,
        -2.69684131e-02,  8.87369383e-03,  3.45796773e-02,
         7.83155236e-02, -6.84848891e-03,  1.84234419e-02,
         8.72835361e-03, -2.11054718e-02, -2.21982065e-02,
         5.58609096e-03,  2.71812281e-03],
       [ 1.33605931e+01,  1.33468574e+01,  1.33320762e+01,
         1.33454194e+01,  1.34506391e+01,  1.31843108e+01,
         1.33733629e+01,  1.31984954e+01,  1.34222065e+01,
         1.33135273e+01,  1.33435786e+01,  1.33623004e+01,
         1.33638634e+01,  1.33649814e+01,  1.34348616e+01,
         1.33998101e+01,  1.34259597e+01,  1.33079171e+01,
         1.33016662e+01,  1.34288279e+01],
       [-2.09000000e+01, -2.09000000e+01, -2.09000000e+01,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01,
        -2.09000000e+01, -2.09000000e+01],
       [ 3.45101515e+03,  3.45094213e+03,  3.45101262e+03,
         3.45097166e+03,  3.45131408e+03,  3.45157507e+03,
         3.45107052e+03,  3.45154539e+03,  3.45153679e+03,
         3.45101091e+03,  3.45092260e+03,  3.45100533e+03,
         3.45117030e+03,  3.45095299e+03,  3.45122445e+03,
         3.45106852e+03,  3.45118729e+03,  3.45101672e+03,
         3.45101791e+03,  3.45118836e+03],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00],
       [-1.07365879e-01,  8.31824088e-02, -1.11058471e-01,
        -1.01082811e-01,  4.68872010e-02,  3.25882409e-03,
         1.11889833e-01, -6.20323260e-02,  1.58248165e-01,
         7.65033378e-02, -6.27008756e-02, -1.00669361e-01,
        -1.43219709e-01,  2.84821982e-02, -3.08185461e-02,
        -2.01207663e-02,  3.74650522e-02,  6.13842395e-02,
        -1.53684723e-02, -4.81632046e-03],
       [-4.60246865e-02, -1.32285958e-02,  3.37171257e-02,
        -4.82669774e-03, -1.58233622e-01,  1.86714488e-01,
        -6.71464513e-02,  1.73927768e-01, -9.40009199e-02,
         8.65814226e-02,  3.38028455e-03, -5.30968929e-02,
        -3.62126399e-02, -8.69988306e-02, -1.51856898e-01,
        -1.28488717e-01, -1.45349789e-01,  9.99088711e-02,
         1.16593141e-01, -1.50168241e-01],
       [-9.93153712e-01, -9.96446532e-01, -9.93241749e-01,
        -9.94866307e-01, -9.86287844e-01, -9.82408815e-01,
        -9.91449454e-01, -9.82802687e-01, -9.82914719e-01,
        -9.93303024e-01, -9.98026640e-01, -9.93502088e-01,
        -9.89028189e-01, -9.95801169e-01, -9.87921910e-01,
        -9.91506835e-01, -9.88670728e-01, -9.93101300e-01,
        -9.93060849e-01, -9.88648726e-01],
       [ 1.25767626e-01, -9.64061860e-02,  1.30058153e-01,
         1.17771391e-01, -5.59479175e-02, -3.92181536e-03,
        -1.31729022e-01,  7.45920428e-02, -1.90241573e-01,
        -8.95749289e-02,  7.22652358e-02,  1.17797408e-01,
         1.69735301e-01, -3.30825318e-02,  3.66282412e-02,
         2.36846178e-02, -4.44429331e-02, -7.19169446e-02,
         1.80077472e-02,  5.71369004e-03],
       [ 5.39127748e-02,  1.53310108e-02, -3.94864046e-02,
         5.62294942e-03,  1.88813630e-01, -2.24705679e-01,
         7.90523132e-02, -2.09147716e-01,  1.13006549e-01,
        -1.01376514e-01, -3.89657409e-03,  6.21307206e-02,
         4.29168362e-02,  1.01050470e-01,  1.80485662e-01,
         1.51247905e-01,  1.72422791e-01, -1.17053568e-01,
        -1.36617898e-01,  1.78148987e-01],
       [-9.90593719e-01, -9.95223999e-01, -9.90719789e-01,
        -9.93024814e-01, -9.80417892e-01, -9.74418789e-01,
        -9.88128634e-01, -9.75035005e-01, -9.75211599e-01,
        -9.90807315e-01, -9.97377838e-01, -9.91092097e-01,
        -9.84554759e-01, -9.94331106e-01, -9.82895365e-01,
        -9.88212077e-01, -9.84019922e-01, -9.90518256e-01,
        -9.90460131e-01, -9.83986937e-01]])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.mean(out_forwards[3]), np.std(out_forwards[3])
#+END_SRC

#+RESULTS:
: (3451.1374396159617, 0.20127724916763187)

Also should move the source closer I bet.

Create a new function distributing the rays uniformly in theta, phi

#+BEGIN_SRC jupyter-python :session py :kernel python3
def create_source_rays_uniform_new(
        source_origin, source_range, source_normal_vec, n_linear_x, n_linear_y,
        n_linear_theta, n_linear_phi, config, check_rays=True, theta_bound=.2, 
        timeout=10):
    # first create rays distributed in the upwards cone
    # and then rotate them to center them around the normal
    # also create them around a variety of starting points
    # assume radially symmetric source
    rotation_matrix = get_rotation_matrix(source_normal_vec, [0, 0, 1])
    rays = []
    
    # now we really have n^4 computations... for n^2 for the circle, n^2 for the angle
    # really we should just create like 20 points distributed uniformly on the circle
    # and then for each of those get like 5 * 5 vectors worth
    # for 20 * 25 total points
    
    starting_time = time.time()
    for x in np.linspace(-1 * source_range, source_range, n_linear_x):
        for y in np.linspace(-1 * source_range, source_range, n_linear_y):
            for theta_val in np.linspace(0, theta_bound, n_linear_theta):
                for phi_val in np.linspace(0, 2 * np.pi, n_linear_phi):
                    if time.time() - starting_time > timeout:
                        print('timing out..')
                        return rays

                    point_origin = [x, y, 0]
                    
                    # Direction of ray away from the starting point
                    r_hat = [np.sin(theta_val) * np.cos(phi_val), 
                             np.sin(theta_val) * np.sin(phi_val), np.cos(theta_val)]

                    transformed_starting_vector = -1 * np.array(transform_points(
                        [r_hat[0]], [r_hat[1]], [r_hat[2]], [0, 0, 0], rotation_matrix)).flatten()

                    transformed_starting_point = np.array(transform_points([point_origin[0]], [point_origin[1]], [point_origin[2]], 
                                                                           source_origin, rotation_matrix)).flatten()

                    # strategically choose our starting rays such that they make it through the
                    # to the first ellipse that we hit
                    polarization_angle = .123
                    intensity = 1.0
                    ray = [polarization_angle, intensity, transformed_starting_point.tolist(), 
                        transformed_starting_vector.tolist(), 0]
                    # paths = ['OM2', 'A1', 'OM1', 'T4', 'E6']
                    if (check_rays):
                        paths = ['T4', 'E6']
                        final_ray = run_ray_through_sim(ray, config, None, paths)
                        if (final_ray is not None):
                            rays.append(ray)
                    else:
                        rays.append(ray)
        
    return rays
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)
    
starting_rays = create_source_rays_uniform_new(
    config['detector']['center'], 10., config['detector']['normal_vec'], 
    3, 3, 100, 100, config, theta_bound=np.pi / 2, check_rays=True, timeout=100)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

# fig = go.Figure()

# #plot the initial ray steps
# all_points = []
# all_vectors = []
# all_distances = []
# for path in possible_paths:
#     total_ray_points, total_vectors, total_distances = step_rays(
#         starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
#         path, final_dist=238, debug=False)

#     all_points.append(total_ray_points)
#     all_vectors.append(total_vectors)
#     all_distances.append(total_distances)

# plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=False,
                                                  fig=fig, color='red')
#fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards.shape
#+END_SRC

#+RESULTS:
: (11, 4403)

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(starting_rays)
#+END_SRC

#+RESULTS:
: 4422

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(out_forwards[3])
#+END_SRC

#+RESULTS:
: 0.21252543238725796

#+BEGIN_SRC jupyter-python :session py :kernel python3
for z in np.linspace(csims.FOCUS[2] + 10, csims.FOCUS[2] - 10, 11):
    out_removed = get_rays_at_z(out_forwards, z)
    #points = remove_outliers(get_rays_at_z(out, z), threshold=5)
    points = out_removed[[0, 1, 2]]
    plt.figure(figsize=(5, 5))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20, norm=mpl.colors.LogNorm())
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    # plt.xlim(-4, 4)
    # plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/f6f5c7c89b4ab48a629ca75ca6f6676a5d639db4.png]]
[[file:./.ob-jupyter/2d45dae5fefbe5c188a58ecc60d4183b95ea822c.png]]
[[file:./.ob-jupyter/e64dcf7cd7ac883bd07ef3b574336ec92c5f5d4e.png]]
[[file:./.ob-jupyter/19bbb448c2e276fccb01c1a380466c0923bce065.png]]
[[file:./.ob-jupyter/2cb5c0e6071d4b423f83a13e720cade3baeb7679.png]]
[[file:./.ob-jupyter/381fc01cc2ee0ccdf3137434f6a50b9dc52f9907.png]]
[[file:./.ob-jupyter/41995e5f7311640a712da123a0659742a05053ce.png]]
[[file:./.ob-jupyter/ed22303ff9514fb65733c5b11b5d76e0fd51276d.png]]
[[file:./.ob-jupyter/99b61c1079ef67b6c8f76627ad8e9557479fde7c.png]]
[[file:./.ob-jupyter/7c40681875ead9936c2f4781a7563515e316f068.png]]
[[file:./.ob-jupyter/99c632f56d730890194f3b5ba1e8f2d0951172fa.png]]
:END:

Wow this is really great now.

Now make a function which takes an input position at some radius away from our
source center,

#+BEGIN_SRC jupyter-python :session py :kernel python3
def create_source_rays_uniform_from_start_displacement(
        source_origin, source_normal_vec, horiz_displacement, 
        vert_displacement, n_linear_theta, n_linear_phi, config, 
        check_rays=True, theta_bound=np.pi / 2, timeout=10, 
        count_thetas=False):
    # first create rays distributed in the upwards cone
    # and then rotate them to center them around the normal
    # also create them around a variety of starting points
    # assume radially symmetric source
    rotation_matrix = get_rotation_matrix(source_normal_vec, [0, 0, 1])
    rays = []
    
    if (count_thetas):
        good_vals = []
    
    # n^2 computations here
    starting_time = time.time()
    for theta_val in np.linspace(0, theta_bound, n_linear_theta):
        for phi_val in np.linspace(0, 2 * np.pi, n_linear_phi):
            if time.time() - starting_time > timeout:
                print('timing out..')
                return rays

            point_origin = [horiz_displacement, vert_displacement, 0]

            # Direction of ray away from the starting point
            r_hat = [np.sin(theta_val) * np.cos(phi_val), 
                     np.sin(theta_val) * np.sin(phi_val), np.cos(theta_val)]

            transformed_starting_vector = -1 * np.array(transform_points(
                [r_hat[0]], [r_hat[1]], [r_hat[2]], [0, 0, 0], rotation_matrix)).flatten()

            transformed_starting_point = np.array(transform_points(
                [point_origin[0]], [point_origin[1]], [point_origin[2]], 
                source_origin, rotation_matrix)).flatten()

            # strategically choose our starting rays such that they make it through the
            # to the first ellipse that we hit
            polarization_angle = .123
            intensity = 1.0
            ray = [polarization_angle, intensity, transformed_starting_point.tolist(), 
                transformed_starting_vector.tolist(), 0]
            # paths = ['OM2', 'A1', 'OM1', 'T4', 'E6']
            if (check_rays):
                paths = ['T4', 'E6']
                final_ray = run_ray_through_sim(ray, config, None, paths)
                if (final_ray is not None):
                    rays.append(ray)
                    if (count_thetas):
                        good_vals.append([theta_val, phi_val])
            else:
                rays.append(ray)
    
    if (count_thetas):
        return rays, good_vals
    return rays
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
data = []
for x_disp in tqdm(np.linspace(-50, 50, 5)):
    for y_disp in np.linspace(-50, 50, 5):
        with open("lab_fts_dims_act.yml", "r") as stream:
            config = yaml.safe_load(stream)

        starting_rays = create_source_rays_uniform_from_start_displacement(
            config['detector']['center'], config['detector']['normal_vec'], x_disp, 
            y_disp, 100, 100, config, theta_bound=np.pi / 2, check_rays=True, 
            timeout=100)

        with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
            config = yaml.safe_load(stream)

        possible_paths = [path[::-1] for path in get_possible_paths()]
        # only do the 1st and 5th of these paths
        possible_paths = [possible_paths[1]]
        final_rays = run_rays_through_sim(
            starting_rays, config, np.array(config['origins']['mirror']), 
            paths=possible_paths)

        data.append([x_disp, y_disp, len(final_rays)])
#+END_SRC

#+RESULTS:
: 100%|██████████| 5/5 [00:53<00:00, 10.66s/it]

#+BEGIN_SRC jupyter-python :session py :kernel python3
data = np.array(data)
plt.scatter(data[:, 0], data[:, 1], c=data[:, 2] / np.max(data[:, 2]))
plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/de74eb07ea4cbf6643a0b9185438c0e597d0820d.png]]


Now we just have to make code which adds up all these interferograms!
and eventually we should check that they work out!

#+BEGIN_SRC jupyter-python :session py :kernel python3
in_to_mm = 25.4
det_size = 5 # in mm
def segment_detector(outrays, n_linear_det=5):
    points = outrays[[0, 1, 2]] * in_to_mm
    # get the max and min x and y dimensions
    # max_x_dim = np.max(np.abs(points[0]))
    # max_y_dim = np.max(np.abs(points[1] - csims.FOCUS[1] * in_to_mm))
    # max_dim = np.max([max_x_dim, max_y_dim])
    # max_loc = max_dim // det_size
    
    # divide these into segments of length 5mm
    #centers = np.arange(-1 * max_loc, max_loc + .1, 1) * det_size
    centers = np.linspace(-(n_linear_det // 2), (n_linear_det // 2), 
                          n_linear_det) * det_size
    out_data = []
    point_data = []
    for x_center in centers:
        for y_center in centers:
            center = (x_center, y_center + csims.FOCUS[1] * in_to_mm)
            # get all the rays that go into this detector
            distance_from_x = np.square(points[0] - center[0])
            distance_from_y = np.square(points[1] - center[1])
            dist_from_center = np.sqrt(distance_from_x + distance_from_y)
            segment_within = np.where(dist_from_center < (det_size / 2))[0]
            #points_within = points[:, segment_within]
            out_within = outrays[:, segment_within]
            #print(out_within.shape)
            out_data.append(out_within)
            point_data.append([x_center, y_center])
    return out_data, np.array(point_data)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
p = np.array(p)
plt.scatter(p[:, 0], p[:, 1], c=p[:, 2])
plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/62f371cae605bfeff90b96f558d983ab79d6eb91.png]]

I think we have everything we need now! Just multiply the rays by a factor of
9 or 10 so that we segment the detectors with enough rays.

Additionally I think we should just do a 5x5 detector grid around the center
and see what we come up with

Try doing this for a different input position to see what we get

#+BEGIN_SRC jupyter-python :session py :kernel python3
def total_forward_raytrace(x_disp, y_disp, n_linear_theta=100, n_linear_phi=100, 
                           mirror_position=0):
    with open("lab_fts_dims_act.yml", "r") as stream:
        config = yaml.safe_load(stream)

    starting_rays = create_source_rays_uniform_from_start_displacement(
        config['detector']['center'], config['detector']['normal_vec'], x_disp, 
        y_disp, n_linear_theta, n_linear_phi, config, theta_bound=np.pi / 2, 
        check_rays=True, timeout=100)

    with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
        config = yaml.safe_load(stream)

    #possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
    possible_paths = [path[::-1] for path in get_possible_paths()]
    # only do the 1st and 5th of these paths
    #possible_paths = [possible_paths[1], possible_paths[5]]
    final_rays = run_rays_through_sim(
        starting_rays, config, list(np.add(np.array(config['origins']['mirror']), 
            [0, mirror_position, 0])), paths=possible_paths)

    transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)
    out_forwards = csims.run_rays_forwards_input_rays(
        transformed_rays, z_ap=csims.FOCUS[2], plot=False, fig=fig, color='red')
    return out_forwards


def plot_out(out, z=csims.FOCUS[2], threshold=5):
    out_z = remove_outliers(get_rays_at_z(out, z), threshold=threshold)
    points = out_z[[0, 1, 2]]
    plt.figure(figsize=(5, 5))
    sns.kdeplot(x=points[0], y=points[1] - csims.FOCUS[1], fill=True, cbar=True, 
                cmap='viridis', thresh=0.01, levels=20, norm=mpl.colors.LogNorm())
    #sns.histplot(x=points[0], y=points[1] - csims.FOCUS[1], cbar=True)
    plt.scatter(0, 0, s=1, color='black')
    plt.axis('equal')
    # plt.xlim(-4, 4)
    # plt.ylim(-4, 4)
    plt.title('z = %.1f' %(z - csims.FOCUS[2]))
    plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
test_out = total_forward_raytrace(40, 0, mirror_position=-20, 
                                  n_linear_theta=100, n_linear_phi=100)
test_out.shape
#+END_SRC

#+RESULTS:
:RESULTS:
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 
: (9, 1524)
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plot_out(test_out, z=csims.FOCUS[2])
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/3011f02979927231cfa13d31f8a09df73fbce01d.png]]


#+begin_src jupyter-python :session py :kernel python3
out_data, point_data = segment_detector(test_out, n_linear_det=7) 
point_data = np.array(point_data)
nums = [o.shape[1] for o in out_data]
plt.scatter(point_data[:, 0], point_data[:, 1], c=nums)
plt.colorbar()
plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/4444d575b8a6fa261ab977a575b9b0317db3c5cf.png]]


** Doing this proper procedure for 1 input
- try to get 300 or so rays per detector at least-- get 5000 or so input rays
  per start position
- then segment these rays and sum each individual interferogram- we do 25 of these
- then we do this for 25 or so input positions and add individual
  interferograms to each other
  - although each position should only give around 9 interferograms worth of data!
- so the total number of computations is 25 * 9ish * (normal interferogram time)
  

#+BEGIN_SRC jupyter-python :session py :kernel python3

def trace_rays(start_displacement, n_mirror_positions, ymax, n_linear_theta=100, 
               n_linear_phi=100, debug=False):
    with open("lab_fts_dims_act.yml", "r") as stream:
        config = yaml.safe_load(stream)

    starting_rays = create_source_rays_uniform_from_start_displacement(
        config['detector']['center'], config['detector']['normal_vec'], 
        start_displacement[0], start_displacement[1], n_linear_theta, 
        n_linear_phi, config, theta_bound=np.pi / 2, check_rays=True, timeout=100)

    with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
        config = yaml.safe_load(stream)

    possible_paths = [path[::-1] for path in get_possible_paths()]
    delay, final_rays = run_all_rays_through_sim_optimized(
        starting_rays, config, n_mirror_positions, paths=possible_paths, 
        ymax=ymax, progressbar=(debug))
    
    total_outrays = []

    for rays in tqdm(final_rays, disable=(not debug)):
        transformed_rays = transform_rays_to_coupling_optics_frame(rays)
        out_forwards = csims.run_rays_forwards_input_rays(
            transformed_rays, z_ap=csims.FOCUS[2], plot=False, fig=fig, color='red')
        total_outrays.append(out_forwards)
        
    # now segment the rays
        
    return total_outrays
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out = trace_rays((0, 0), 400, 20, debug=True, 
                   n_linear_theta=50, n_linear_phi=50) 
#+END_SRC

#+RESULTS:
: 100%|██████████| 400/400 [02:04<00:00,  3.22it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
out[0].shape
#+END_SRC

#+RESULTS:
: (9, 160)

#+BEGIN_SRC jupyter-python :session py :kernel python3
out[0][8]
#+END_SRC

#+RESULTS:
#+begin_example
array([3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496,
       3411.70372193, 3411.70372193, 3411.70372193, 3490.25969496,
       3490.25969496, 3490.25969496, 3411.70372193, 3490.25969496])
#+end_example

Now can save this out for later loading in since this has all the info we need


#+BEGIN_SRC jupyter-python :session py :kernel python3
def segment_rays(total_out, n_linear_det=5):
    total_out_segments = []
    for out in total_out:
        out_segments, det_points = segment_detector(out, n_linear_det=n_linear_det)
        total_out_segments.append(out_segments)
        
    return total_out_segments, det_points

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
total_out_segments, det_points =  segment_rays(out)
#out_segments.shape
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out[0]
#+END_SRC

#+RESULTS:
#+begin_example
array([[-2.57179603e-16, -2.57179603e-16, -2.57179603e-16, ...,
        -3.14685393e-16, -2.57179603e-16, -3.14685393e-16],
       [ 1.34474442e+01,  1.34474442e+01,  1.34474442e+01, ...,
         1.32431645e+01,  1.34474442e+01,  1.32431645e+01],
       [-2.09000000e+01, -2.09000000e+01, -2.09000000e+01, ...,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01],
       ...,
       [ 2.35619433e+00,  7.85398000e-01,  2.35619433e+00, ...,
         2.35619433e+00,  7.85398000e-01,  2.35619433e+00],
       [ 1.38074050e-12,  8.39944506e-13,  9.45596696e-02, ...,
         1.38072585e-12,  1.55441657e-01,  9.45586660e-02],
       [ 3.41170372e+03,  3.41170372e+03,  3.41170372e+03, ...,
         3.49025969e+03,  3.41170372e+03,  3.49025969e+03]])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
total_out_segments[199][12]
#+END_SRC

#+RESULTS:
#+begin_example
array([[-3.68469301e-16, -3.68469301e-16, -3.68469301e-16, ...,
        -9.37501637e-16, -3.68469301e-16, -9.37501637e-16],
       [ 1.33443099e+01,  1.33443099e+01,  1.33443099e+01, ...,
         1.33438041e+01,  1.33443099e+01,  1.33438041e+01],
       [-2.09000000e+01, -2.09000000e+01, -2.09000000e+01, ...,
        -2.09000000e+01, -2.09000000e+01, -2.09000000e+01],
       ...,
       [ 2.35619433e+00,  7.85398000e-01,  2.35619433e+00, ...,
         2.35619433e+00,  7.85398000e-01,  2.35619433e+00],
       [ 1.38074050e-12,  8.39944506e-13,  9.45596696e-02, ...,
         1.38072585e-12,  1.55441657e-01,  9.45586660e-02],
       [ 3.45081350e+03,  3.45081350e+03,  3.45081350e+03, ...,
         3.45101039e+03,  3.45081350e+03,  3.45101039e+03]])
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
center_data = total_out_segments[199]
plt.scatter(det_points[:, 0], det_points[:, 1], c=list(
    map(lambda x: x.shape[1], center_data)))
plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ee99017d3089b88616ed54f769170cd39635ec7c.png]]


Now we just need to compute the interferogram for each and sum them at each
position


#+BEGIN_SRC jupyter-python :session py :kernel python3
len(total_out_segments[0])
#+END_SRC

#+RESULTS:
: 25

Now we need to turn total_out_segments into an array of size (25, 400, 9, len(rays))

#+BEGIN_SRC jupyter-python :session py :kernel python3
reorganized_segments = []
for j in range(len(det_points)):
    reorganized_segments.append([])
for i in range(len(total_out_segments)):
    for j in range(len(total_out_segments[i])):
        data = total_out_segments[i][j]
        # if data is empty, do nothing
        reorganized_segments[j].append(data)
        
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
# for each each det position:
#     sum at position = np.zeros
#     for each start position:
#         get rays within center and calculate interferogram
#         add interferogram to sum at det position

def data_to_matrix(center_data):
    max_rays_num = max([data.shape[1] for data in center_data])
    if max_rays_num == 0:
        return None
    total_rays = []
    for data in center_data:
        # only keep polarization, intensity, and phase
        # could also keep detector position and angle separately
        # if we're curious!
        power_vals_mask = [6, 7, 8]
        power_vals = data[power_vals_mask]
        power_vals = power_vals.T
        # pad rows now
        total_vals = np.zeros((max_rays_num, 3))
        total_vals[:power_vals.shape[0]] = power_vals
        total_rays.append(total_vals)

    return np.array(total_rays)
    

freqs = np.arange(120, 180, .5)
start_positions = [0, 0]
interferograms = []
for j, det_center in enumerate(det_points):
    interferogram_sum = np.zeros(len(delay))
    # get the max number of rays 
    data_matrix = data_to_matrix(reorganized_segments[j])
    if (data_matrix is None):
        interferogram = np.zeros(len(reorganized_segments[0]))
    else:
        interferogram = get_interferogram_frequency(data_matrix, freqs)
    interferograms.append(interferogram)
        
#+END_SRC

#+RESULTS:
: 100%|██████████| 120/120 [00:00<00:00, 876.45it/s]
: 100%|██████████| 120/120 [00:00<00:00, 298.94it/s]
: 100%|██████████| 120/120 [00:00<00:00, 881.19it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
for interferogram in interferograms:
    plt.plot(delay, interferogram)
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/449d5ba643f0935dddf3b0e7271c00a6c8505da5.png]]
[[file:./.ob-jupyter/b843ce7f00fec08bca50c46a8500871ddbfa9483.png]]
[[file:./.ob-jupyter/a78ded3a131cf5a93448ecfbce4f20e2b39141d8.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
[[file:./.ob-jupyter/26ef0c4f13dbf26ceedecac308dbf8067052fd2f.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_0 = trace_rays((0, 0), 400, 20, debug=True, 
                   n_linear_theta=50, n_linear_phi=50) 

# out_1 = trace_rays((10, 0), 400, 20, debug=True, 
#                    n_linear_theta=50, n_linear_phi=50) 

# out_2 = trace_rays((0, 10), 400, 20, debug=True, 
#                    n_linear_theta=50, n_linear_phi=50) 
#+END_SRC

#+RESULTS:
:RESULTS:
: 100%|██████████| 400/400 [14:01<00:00,  2.10s/it]
: 100%|██████████| 400/400 [42:29<00:00,  6.37s/it]
:END:

try running 225 of these.... saving the outs from each one

then for each z_ap we can combine each of these!!!

#+BEGIN_SRC jupyter-python :session py :kernel python3
plot_out(out_0[399], z=csims.FOCUS[2])
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/f53f2e2104797957309dddb0e018777d6e728f38.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
total_out_segments, det_points =  segment_rays(out_0)
center_data = total_out_segments[10]
plt.scatter(det_points[:, 0], det_points[:, 1], c=list(
    map(lambda x: x.shape[1], center_data)))
plt.colorbar()
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/16bea2469f22c6a8691f6149686bc33f6120e86c.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
reorganized_segments = []
for j in range(len(det_points)):
    reorganized_segments.append([])
for i in range(len(total_out_segments)):
    for j in range(len(total_out_segments[i])):
        data = total_out_segments[i][j]
        # if data is empty, do nothing
        reorganized_segments[j].append(data)

freqs = np.arange(120, 180, .5)
start_positions = [0, 0]
interferograms = []
for j, det_center in enumerate(det_points):
    interferogram_sum = np.zeros(len(delay))
    # get the max number of rays 
    data_matrix = data_to_matrix(reorganized_segments[j])
    if (data_matrix is None):
        interferogram = np.zeros(len(reorganized_segments[0]))
    else:
        interferogram = get_interferogram_frequency(data_matrix, freqs)
    interferograms.append(interferogram)
#+END_SRC

#+RESULTS:
: 100%|██████████| 120/120 [00:00<00:00, 1995.28it/s]
: 100%|██████████| 120/120 [00:00<00:00, 1007.12it/s]
: 100%|██████████| 120/120 [00:00<00:00, 176.92it/s]
: 100%|██████████| 120/120 [00:03<00:00, 34.09it/s]
: 100%|██████████| 120/120 [00:01<00:00, 87.90it/s]
: 100%|██████████| 120/120 [00:00<00:00, 1243.46it/s]
: 100%|██████████| 120/120 [00:00<00:00, 599.70it/s]

#+BEGIN_SRC jupyter-python :session py :kernel python3
for interferogram in interferograms:
    if np.any(interferogram) == False:
        continue
        
    plt.plot(delay, interferogram)
    plt.show()
    fftfreq = np.fft.rfftfreq(len(interferogram), d=(4 * 2 * 40 / 800) / 1.018357) 
    fft_data = np.abs(np.fft.rfft(interferogram * np.hanning(
        len(interferogram))))
    #fft_data /= fft_data[120]
    plt.plot(c * fftfreq[3:], fft_data[3:])
    plt.xlim(110, 190)
    #plt.ylim(1e-2, 1.1)
    #plt.xlim(298, 305)
    plt.xlabel('frequency')
    #plt.yscale('log')
    #plt.legend()
    plt.ylabel('power')
    plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b2f271d32a8777f85658ca667bf934afae96433a.png]]
[[file:./.ob-jupyter/c621cc39033e8520cffe191173ddf753ada750e7.png]]
[[file:./.ob-jupyter/bed7bd8feb7af64ffe47114867d81ca86fc1567a.png]]
[[file:./.ob-jupyter/91f8bd8649898225658ff33ff5aeaa919e41d7d8.png]]
[[file:./.ob-jupyter/5c049d3d05129b4ca27a149a78a47c45839da9b7.png]]
[[file:./.ob-jupyter/619e3b14f71ec64979bce6fb745deb25ee6ef584.png]]
[[file:./.ob-jupyter/e142defb66a495bc8e7c82ee3457f26b43ebd88a.png]]
[[file:./.ob-jupyter/afae3f2cc70a98529b0cd8ea10b970878e7bd7b0.png]]
[[file:./.ob-jupyter/1b6914531cc4d64f4b4cfaeed463f8333d87dc81.png]]
[[file:./.ob-jupyter/ad14c1e4fa27c1a6a6e284a446b51151a03bbf4a.png]]
[[file:./.ob-jupyter/918f663a9e1258313b75af2eff86a50014e33797.png]]
[[file:./.ob-jupyter/186422a2c7f1229e0d4d12c9f9fd39cacec2cec1.png]]
[[file:./.ob-jupyter/4ce03a874650fcf0672eacd9db5c4d668c119af4.png]]
[[file:./.ob-jupyter/cc0778a7748acd7779e618e4a9dc79d45a6b4ec6.png]]
:END:

* This look good... now run a bunch of these and see what happens
- try using 100, 100 rays for full spanning of space
- save the initial out data for each one
- then we can segment these together
  
#+BEGIN_SRC jupyter-python :session py :kernel python3
[list(o) for o in out])
#+END_SRC

#+RESULTS:
: 400

#+BEGIN_SRC jupyter-python :session py :kernel python3
test = [list(o) for o in out_0]
np.array(list(np.array(test, dtype='object')[0])).shape
#+END_SRC

#+RESULTS:
: (9, 1072)


#+BEGIN_SRC jupyter-python :session py :kernel python3
data = np.array(test, dtype='object')
np.save('data/test_data.npy', data)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
test2 = np.load('data/test_data.npy', allow_pickle=True)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
test_use = [np.array(list(o)) for o in test2]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.plot(delay, [np.array(list(test2[i])).shape[1] for i in range(len(test2))])
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/9e7fe6273245dd890c8f3054d5f9956a3ac31e35.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
total_out_segments, det_points =  segment_rays(test_use)
center_data = total_out_segments[10]
plt.scatter(det_points[:, 0], det_points[:, 1], c=list(
    map(lambda x: x.shape[1], center_data)))
plt.colorbar()
plt.show()

reorganized_segments = []
for j in range(len(det_points)):
    reorganized_segments.append([])
for i in range(len(total_out_segments)):
    for j in range(len(total_out_segments[i])):
        data = total_out_segments[i][j]
        # if data is empty, do nothing
        reorganized_segments[j].append(data)

freqs = np.arange(120, 180, .5)
start_positions = [0, 0]
interferograms = []
for j, det_center in enumerate(det_points):
    interferogram_sum = np.zeros(len(delay))
    # get the max number of rays 
    data_matrix = data_to_matrix(reorganized_segments[j])
    if (data_matrix is None):
        interferogram = np.zeros(len(reorganized_segments[0]))
    else:
        interferogram = get_interferogram_frequency(data_matrix, freqs)
    interferograms.append(interferogram)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/16bea2469f22c6a8691f6149686bc33f6120e86c.png]]
: 100%|██████████| 120/120 [00:00<00:00, 2090.15it/s]
: 100%|██████████| 120/120 [00:00<00:00, 650.33it/s]
: 100%|██████████| 120/120 [00:00<00:00, 168.30it/s]
: 100%|██████████| 120/120 [00:02<00:00, 41.76it/s]
: 100%|██████████| 120/120 [00:00<00:00, 137.95it/s]
: 100%|██████████| 120/120 [00:00<00:00, 1364.36it/s]
: 100%|██████████| 120/120 [00:00<00:00, 858.66it/s]
:END:

Now I just need to be able to combine two of these

#+BEGIN_SRC jupyter-python :session py :kernel python3
def get_interferograms(out_data, freqs):
    total_out_segments, det_points =  segment_rays(out_data)
    reorganized_segments = []
    for j in range(len(det_points)):
        reorganized_segments.append([])
    for i in range(len(total_out_segments)):
        for j in range(len(total_out_segments[i])):
            data = total_out_segments[i][j]
            # if data is empty, do nothing
            reorganized_segments[j].append(data)

    interferograms = []
    for j, det_center in enumerate(det_points):
        interferogram_sum = np.zeros(len(delay))
        # get the max number of rays 
        data_matrix = data_to_matrix(reorganized_segments[j])
        if (data_matrix is None):
            interferogram = np.zeros(len(reorganized_segments[0]))
        else:
            interferogram = get_interferogram_frequency(
                data_matrix, freqs, debug=True)
            #interferogram = rt.get_interferogram(data_matrix, (c / 150.))
        interferograms.append(interferogram)
    return interferograms
    

def get_and_combine_interferograms(all_data, freqs):
    total_interferograms = np.array(
        [get_interferograms(data, freqs) for data in all_data])
    print(total_interferograms.shape)
    return total_interferograms
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
total = get_and_combine_interferograms([out_0, out_0], np.arange(150, 151, 1))
#+END_SRC

#+RESULTS:
#+begin_example
100%|██████████| 1/1 [00:00<00:00, 619.54it/s]
100%|██████████| 1/1 [00:00<00:00, 407.85it/s]
100%|██████████| 1/1 [00:00<00:00, 125.47it/s]
100%|██████████| 1/1 [00:00<00:00, 35.26it/s]
100%|██████████| 1/1 [00:00<00:00, 128.37it/s]
100%|██████████| 1/1 [00:00<00:00, 261.49it/s]
100%|██████████| 1/1 [00:00<00:00, 352.34it/s]
100%|██████████| 1/1 [00:00<00:00, 525.73it/s]
100%|██████████| 1/1 [00:00<00:00, 399.38it/s]
100%|██████████| 1/1 [00:00<00:00, 118.88it/s]
100%|██████████| 1/1 [00:00<00:00, 33.91it/s]
100%|██████████| 1/1 [00:00<00:00, 126.10it/s]
100%|██████████| 1/1 [00:00<00:00, 441.27it/s]
100%|██████████| 1/1 [00:00<00:00, 372.56it/s](2, 25, 400)

#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.sum(total, axis=0).shape
#+END_SRC

#+RESULTS:
: (25, 400)

#+BEGIN_SRC jupyter-python :session py :kernel python3
def plot_interferograms(delay, interferograms, freq=150):
    for interferogram in interferograms:
        if np.any(interferogram) == False:
            continue

        plt.plot(delay, interferogram)
        plt.show()
        fftfreq = np.fft.rfftfreq(len(interferogram), d=(4 * 2 * 40 / 800) / 1.018357) 
        fft_data = np.abs(np.fft.rfft(interferogram * np.hanning(
            len(interferogram))))
        plt.axvline(150)
        #fft_data /= fft_data[120]
        plt.plot(c * fftfreq[3:], fft_data[3:])
        #plt.xlim(110, 190)
        #plt.ylim(1e-2, 1.1)
        plt.xlim(freq - 10, freq + 10)
        plt.axvline(freq)
        plt.xlabel('frequency')
        #plt.yscale('log')
        #plt.legend()
        plt.ylabel('power')
        plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plot_interferograms(delay, np.sum(total, axis=0))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/6cc2e5db4bcaef025e5d74ac3d443275123de6ac.png]]
[[file:./.ob-jupyter/9fad3939046b0162da6714f363602c868c6bf738.png]]
[[file:./.ob-jupyter/55d094c6e4871898864851335953068bf68c5bdf.png]]
[[file:./.ob-jupyter/23c18c60354d02fc8f19e16141e9cbd84f1b72d6.png]]
[[file:./.ob-jupyter/47f80bdbd88d38c3c60027b84fcbe9f42de92127.png]]
[[file:./.ob-jupyter/b590cfa79996b1865a3df5e5586f427a9ad1d3f2.png]]
[[file:./.ob-jupyter/9a9b311c6543ebab0d42f125561151ea20dadc4a.png]]
[[file:./.ob-jupyter/b802332e8baf19a1a5917ce1c108d8dc825ee667.png]]
[[file:./.ob-jupyter/f23a82a042d8bb618b08c072f42a08cf1ef6d9a1.png]]
[[file:./.ob-jupyter/231894ec63dfc998d733e1e5a660faf24e87b2d6.png]]
[[file:./.ob-jupyter/4db2b5785d924028afec152aec79d9dd122fd73e.png]]
[[file:./.ob-jupyter/e13dde96f634a458185fe71667b8ddc2b9e7c442.png]]
[[file:./.ob-jupyter/12a4ba8805a2b68292ee9f3180c6eff3e6b69556.png]]
[[file:./.ob-jupyter/9b62cffdfb53a88e68c5cda38237d4e5f367def7.png]]
:END:

** Now Add these to notebook utils

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.linspace(0, 0, 2)
#+END_SRC

#+RESULTS:
: array([0., 0.])

#+BEGIN_SRC jupyter-python :session py :kernel python3
data = pickle.load(open('data/total_outrays_0_test.p', 'rb'))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(data[1])
#+END_SRC

#+RESULTS:
: 400

#+BEGIN_SRC jupyter-python :session py :kernel python3
total = get_and_combine_interferograms([data[0], data[0]], np.arange(150, 151, 1))
plot_interferograms(delay, np.sum(total, axis=0))
#+END_SRC

#+RESULTS:
:RESULTS:
: 100%|██████████| 1/1 [00:00<00:00, 372.03it/s]
: 100%|██████████| 1/1 [00:00<00:00, 198.61it/s]
: 100%|██████████| 1/1 [00:00<00:00, 469.21it/s]
: 100%|██████████| 1/1 [00:00<00:00, 480.06it/s]
: 100%|██████████| 1/1 [00:00<00:00, 252.08it/s]
: 100%|██████████| 1/1 [00:00<00:00, 538.15it/s]
: (2, 25, 400)
[[file:./.ob-jupyter/bfb1f40d1922fc8d404da5434a85c1c2a3c87891.png]]
[[file:./.ob-jupyter/967772bd01ca4fddb1b821a2e73e29cc93c43db1.png]]
[[file:./.ob-jupyter/2b7d4b44f368df6a1d75d1cf390ad900bdc6a0db.png]]
[[file:./.ob-jupyter/9500ea1655c5f93d9d89efa0f9d0b52e60969e9b.png]]
[[file:./.ob-jupyter/5b66bde4b4372d122d2240a9930dd88d3ca02622.png]]
[[file:./.ob-jupyter/e571c6e96ae5e85abec1f33bb48aa1ec7573aa55.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
plot_out(data[0][0], z=csims.FOCUS[2], threshold=100)
#+END_SRC

#+RESULTS:
:RESULTS:
: /Users/tommyalford/opt/anaconda3/lib/python3.8/site-packages/seaborn/distributions.py:1077: UserWarning:
: 
: Dataset has 0 variance; skipping density estimate.
: 
[[file:./.ob-jupyter/2c45a605722110b0bfd6f0bda99d656bc905c69f.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
p = data[0][399][[0, 1, 2]]
plt.plot(p[0], p[1], '.')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/1d766482952e06cdc5abdaa2ce1d64a3b045236e.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
p = data[0][199][[0, 1, 2]]
len(p[0] - csims.FOCUS[0]) / 8
#+END_SRC

#+RESULTS:
: 20.0

** Check the path length difference of these

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.hist(out_0[0][8])
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/b23679430365b7d068427dd139861363871b626b.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
from sklearn.cluster import KMeans
km = KMeans(n_clusters=2)
km.fit(remove_outliers(out_0[0])[8].reshape(-1, 1))
1 / (np.diff(km.cluster_centers_[:, 0])[0] / delay[0])
#+END_SRC

#+RESULTS:
: -1.0177321783098947

#+BEGIN_SRC jupyter-python :session py :kernel python3
pos = 20
test_out = total_forward_raytrace(0, 0, mirror_position=pos, 
                                  n_linear_theta=50, n_linear_phi=50)
#+END_SRC

#+RESULTS:
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.hist(remove_outliers(test_out)[8])
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/770abe35172ec2dbd75a121259f410deaeb0dfc0.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
km = KMeans(n_clusters=2)
km.fit(remove_outliers(test_out)[8].reshape(-1, 1))
1 / (np.diff(km.cluster_centers_[:, 0])[0] / (4 * pos))
#+END_SRC

#+RESULTS:
: 1.0177321783098887

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.diff(km.cluster_centers_[:, 0])[0]
#+END_SRC

#+RESULTS:
: 79.1326745284573

** Try a partial forwards raytrace?

This transformation function may be messed up.... that's what I would
guess.. although my out data also looked the same so I have no idea

#+BEGIN_SRC jupyter-python :session py :kernel python3
pos = 200
km = KMeans(n_clusters=2)
km.fit(remove_outliers(data[0][pos])[8].reshape(-1, 1))
1 / (np.diff(km.cluster_centers_[:, 0])[0] / (delay[pos]))
#+END_SRC

#+RESULTS:
: -1.0183572623664972

#+BEGIN_SRC jupyter-python :session py :kernel python3
delay[199]
#+END_SRC

#+RESULTS:
: -0.20050125313284184

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(remove_outliers(data[0][399])[8])
#+END_SRC

#+RESULTS:
: 160

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(remove_outliers(out_0[399])[8])
#+END_SRC

#+RESULTS:
: 1072

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(data[0])
#+END_SRC

#+RESULTS:
: 400

Ok there seems to be a discrepancy with the output of 

#+BEGIN_SRC jupyter-python :session py :kernel python3
facs = []
pos = 20
for x_start in tqdm(np.linspace(-30, 30, 5)):
    for y_start in np.linspace(-30, 30, 5):
        test_out = total_forward_raytrace(x_start, y_start, mirror_position=pos, 
                                          n_linear_theta=100, n_linear_phi=20)

        km = KMeans(n_clusters=2)
        km.fit(remove_outliers(test_out)[8].reshape(-1, 1))
        fac = 1 / (np.diff(km.cluster_centers_[:, 0])[0] / (4 * pos))
        facs.append(fac)
#+END_SRC

#+RESULTS:
#+begin_example
  0%|          | 0/5 [00:00<?, ?it/s]/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

 20%|██        | 1/5 [00:17<01:11, 17.96s/it]/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
 40%|████      | 2/5 [00:45<01:02, 20.83s/it]/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
 60%|██████    | 3/5 [01:22<00:51, 25.82s/it]/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
 80%|████████  | 4/5 [01:52<00:26, 26.99s/it]/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt
100%|██████████| 5/5 [02:17<00:00, 27.43s/it]
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
import inspect
lines = inspect.getsource(transform_rays_to_coupling_optics_frame)
print(lines)
#+END_SRC

#+RESULTS:
#+begin_example
def transform_rays_to_coupling_optics_frame(rays):
    # we want the rays essentially directly after they hit the last polarizer
    # in the FTS and then we need to calculate the distance between this
    # polarizer and the first lens of the coupling optics
    
    # first we need to transform the rays' points and normal vectors to the
    # frame of the coupling optics
    
    # Here we really need to make sure we're properly rotating this ray really
    # the ray should stop at the plane which makes the same beam angle as the
    # coupling optics actually things should be fine I think, but just in case
    # do it this way I guess
    # don't stop at (0, 0, 0), stop at (0, -.426, 0) equivilently
    coupling_optics_origin = COUPLING_OPTICS_ORIGIN
    angle = -0.190161
    factor = csims.mm_to_in
    new_rays = []
    for ray in rays:
        new_ray = [ray[0], ray[1], None, None, ray[4]]
        # switch the x and z coordinate of these!
        new_vec = rotate(ray[3], [0, 0, angle])
        new_ray[2] = factor * np.flip(rotate(np.subtract(ray[2], coupling_optics_origin), 
                                             [0, 0, angle]) * [1, -1, 1])
        new_ray[3] = np.flip(csims.normalize(factor * new_vec * [1, -1, 1]))
        new_rays.append(new_ray)

    return new_rays
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
plt.hist(np.abs(facs))
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/8d77bf4e5d02f02bbc157daa9e2d44a22f2036ef.png]]

#+BEGIN_SRC jupyter-python :session py :kernel python3
total = get_and_combine_interferograms([out_0], np.arange(300, 301, 1))
plot_interferograms(delay, np.sum(total, axis=0), freq=300)
#+END_SRC

#+RESULTS:
:RESULTS:
: 100%|██████████| 1/1 [00:00<00:00, 159.01it/s]
: 100%|██████████| 1/1 [00:00<00:00, 64.76it/s]
: 100%|██████████| 1/1 [00:00<00:00, 69.80it/s]
: 100%|██████████| 1/1 [00:00<00:00, 17.67it/s]
: 100%|██████████| 1/1 [00:00<00:00, 118.26it/s]
: 100%|██████████| 1/1 [00:00<00:00, 338.30it/s]
: 100%|██████████| 1/1 [00:00<00:00, 308.56it/s]
: (1, 25, 400)
[[file:./.ob-jupyter/0ceda856e6cc31d8df27fc402c82173645683d18.png]]
[[file:./.ob-jupyter/8eca64c511d57191c308285c3fd4108f85e21132.png]]
[[file:./.ob-jupyter/e487286038db0fc9c00f5167b5918c896c494918.png]]
[[file:./.ob-jupyter/eda0e9a479ff455d61ab335e32f49673ee7cfb81.png]]
[[file:./.ob-jupyter/74767f0b470d5b304ef621aaf8ae7828ebd1459d.png]]
[[file:./.ob-jupyter/a4c1dadc1b42ec63a2a2e73248056658ab4e3b8d.png]]
[[file:./.ob-jupyter/67163ed38a8cccbed4ba30a5089b2b3e42ef6caf.png]]
[[file:./.ob-jupyter/c304c21152bacca833acba59d1b9f0ac38b0f910.png]]
[[file:./.ob-jupyter/5e381feee804332d99eb026fec452e9bf3eceb89.png]]
[[file:./.ob-jupyter/1844371d05ef2911c13fef12a44c40bb8cb77141.png]]
[[file:./.ob-jupyter/efba00604f226a7c224f978287ffccc2fff44511.png]]
[[file:./.ob-jupyter/0db6408887d512025a1ea0cfe572b84b08014438.png]]
[[file:./.ob-jupyter/800d98fcc4ed93c81301ba4b6c1f1ba887dcefb8.png]]
[[file:./.ob-jupyter/2c6e7d405ec4a0c78c3523b379e22f98b08a4dc9.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
total = get_and_combine_interferograms([out_0], np.arange(150, 151, 1))
plot_interferograms(delay, np.sum(total, axis=0), freq=150)
#+END_SRC

#+RESULTS:
:RESULTS:
: 100%|██████████| 1/1 [00:00<00:00, 392.47it/s]
: 100%|██████████| 1/1 [00:00<00:00, 424.61it/s]
: 100%|██████████| 1/1 [00:00<00:00, 104.22it/s]
: 100%|██████████| 1/1 [00:00<00:00, 21.82it/s]
: 100%|██████████| 1/1 [00:00<00:00, 119.60it/s]
: 100%|██████████| 1/1 [00:00<00:00, 534.78it/s]
: 100%|██████████| 1/1 [00:00<00:00, 342.36it/s]
: (1, 25, 400)
[[file:./.ob-jupyter/39d4c1397fd75dda6fe9970f89079c2e021401b9.png]]
[[file:./.ob-jupyter/facd6f372381a2c1bbeccc65886301a8b9137e6e.png]]
[[file:./.ob-jupyter/0043cf04b2657f2294e09947e85d358258e22c98.png]]
[[file:./.ob-jupyter/cd4e5f8274cd8a7723e6c9f28d47ffa28f8d4605.png]]
[[file:./.ob-jupyter/030af2c2c4df96b74c57fc477cbe6a2f3609e130.png]]
[[file:./.ob-jupyter/2ea5b2d3244734a0ef7e54be29aac05bafa0b10a.png]]
[[file:./.ob-jupyter/875bddfbb58a1341b0c2c0fc1beba3637ccca4f0.png]]
[[file:./.ob-jupyter/f8fa41712aac7fa2454503d41d4b1634ca2f58e8.png]]
[[file:./.ob-jupyter/718f8955b2ad56b4972094a9b51b9334f75824b0.png]]
[[file:./.ob-jupyter/b42f44f0edcb813c0d47165f9cad56efecdded69.png]]
[[file:./.ob-jupyter/c6e34adec84ffa445725b0d07aa283adb9be8fd9.png]]
[[file:./.ob-jupyter/09611ebb46c1f4cd0eb13aa8b18ea7af6c747534.png]]
[[file:./.ob-jupyter/e42f64f0f073784a0d59d214858bc30158485f1d.png]]
[[file:./.ob-jupyter/220589919fb26dc10b919902c0fefe8932dc7712.png]]
:END:

#+BEGIN_SRC jupyter-python :session py :kernel python3
test_out = total_forward_raytrace(10, 10, mirror_position=0, 
                                  n_linear_theta=150, n_linear_phi=20)
test_out.shape
#+END_SRC

#+RESULTS:
: (9, 1144)

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(utils.get_rays_at_z(test_out, csims.FOCUS[2] - 2)[8])
#+END_SRC

#+RESULTS:
: 0.5908935092883864

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(utils.get_rays_at_z(test_out, csims.FOCUS[2] + 2)[8])
#+END_SRC

#+RESULTS:
: 0.2102931915974487

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act_modified.yml", "r") as stream:
    config = yaml.safe_load(stream)

starting_rays = create_source_rays_uniform_from_start_displacement(
    config['detector']['center'], config['detector']['normal_vec'], 10, 
    0, 150, 30, config, theta_bound=np.pi / 2, check_rays=True, timeout=100)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
#possible_paths = [possible_paths[1], possible_paths[5]]
final_rays = run_rays_through_sim(
    starting_rays, config, list(np.add(np.array(config['origins']['mirror']), 
        [0, 0, 0])), paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)
out_forwards = csims.run_rays_forwards_input_rays(
    transformed_rays, z_ap=csims.FOCUS[2], plot=False, fig=fig, color='red')
#+END_SRC

#+RESULTS:
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 
: /Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:
: 
: invalid value encountered in sqrt
: 

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std(utils.get_rays_at_z(out_forwards, csims.FOCUS[2] - 2)[8])
#+END_SRC

#+RESULTS:
: 0.4381417771422557


#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std([ray[4] for ray in all_distances[0]])
#+END_SRC

#+RESULTS:
: 2.061003581182155

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.std([np.sum(dists[:5]) for dists in all_distances[0]])
#+END_SRC

#+RESULTS:
: 0.6084246128805245

#+BEGIN_SRC jupyter-python :session py :kernel python3
all_distances[0][1], all_distances[0][30]
#+END_SRC

#+RESULTS:
#+begin_example
([0,
  336.18299750262486,
  237.9631758280883,
  240.0859427329366,
  240.08319098275365,
  236.01196384809828,
  3.8492918370016014,
  236.01851109448194,
  236.30273802832812,
  236.29983597218552,
  237.96589588648135,
  263.8168927255898],
 [0,
  339.6221637320842,
  240.16999082865408,
  236.65386451519612,
  236.95842079201384,
  235.02190518063298,
  2.3551302510300047,
  234.70179149910427,
  238.97125560669042,
  239.27199691523697,
  240.47893541202689,
  261.0562281092942])
#+end_example

I should make sure that if I start a run at the focus of the first mirror that
the path lengths are similar. Think this works though.

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = get_possible_paths()
z_vals = []
for z in np.linspace(-2, 2, 11):    
    rays_test = csims.get_final_rays_reversed([0, 0, z], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
    distances_to_keep = []
    for distances in total_distances:
        if distances[-1] != 0:
            distances_to_keep.append(distances)

    mean = np.mean(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    stdev = np.std(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    z_vals.append([z, mean, stdev])

#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 304
total number of rays making past the first ellipse = 304
total number of rays making it all the way through = 240
initial number of rays = 304
total number of rays making past the first ellipse = 304
total number of rays making it all the way through = 280
initial number of rays = 332
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 280
initial number of rays = 340
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 280
initial number of rays = 356
total number of rays making past the first ellipse = 356
total number of rays making it all the way through = 320
initial number of rays = 380
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 320
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 330
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 360
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 366
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.array(z_vals)
plt.plot(z_vals[:, 0], z_vals[:, 2], '.')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/56c3a00f8febebf66967b1956e357dddadfc1847.png]]

Might have to 'shift' the focus to move down a couple inches in light of the
source being further away from the FTS to begin with. I bet with a closer
source this would go away.

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act_modified.yml", "r") as stream:
    config = yaml.safe_load(stream)

possible_paths = get_possible_paths()
z_vals = []
for z in np.linspace(-3, 3, 15):    
    rays_test = csims.get_final_rays_reversed([0, 0, z], 20, theta_bound=.25)
    transformed_test = transform_rays_to_fts_frame(rays_test)

    points, vectors, total_distances = step_rays(
        transformed_test, config, run_ray_through_sim, config, [0, 0, 0], 
        possible_paths[6], final_dist=0)
    distances_to_keep = []
    for distances in total_distances:
        if distances[-1] != 0:
            distances_to_keep.append(distances)

    mean = np.mean(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    stdev = np.std(list(map(lambda x: np.sum(x[0:]), distances_to_keep)))
    z_vals.append([z, mean, stdev])
#+END_SRC

#+RESULTS:
#+begin_example
/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:252: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:255: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:288: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:289: RuntimeWarning:

invalid value encountered in sqrt

/Users/tommyalford/FTS_simulation_results/fts_coupling_optics_geo.py:290: RuntimeWarning:

invalid value encountered in sqrt
initial number of rays = 272
total number of rays making past the first ellipse = 272
total number of rays making it all the way through = 240
initial number of rays = 292
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 240
initial number of rays = 296
total number of rays making past the first ellipse = 280
total number of rays making it all the way through = 240
initial number of rays = 304
total number of rays making past the first ellipse = 304
total number of rays making it all the way through = 240
initial number of rays = 332
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 280
initial number of rays = 340
total number of rays making past the first ellipse = 320
total number of rays making it all the way through = 280
initial number of rays = 352
total number of rays making past the first ellipse = 352
total number of rays making it all the way through = 308
initial number of rays = 380
total number of rays making past the first ellipse = 360
total number of rays making it all the way through = 320
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 332
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 360
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 374
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 400
initial number of rays = 400
total number of rays making past the first ellipse = 400
total number of rays making it all the way through = 320
#+end_example

#+BEGIN_SRC jupyter-python :session py :kernel python3
z_vals = np.array(z_vals)
plt.plot(z_vals[:, 0], z_vals[:, 2], '.')
plt.show()
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/d640b553ada84f7d2db79df1bf961fc647fa60b2.png]]

This makes sense now. So I guess I should move around the focus around more,
maybe go from (-1, 3) or something like that!

#+BEGIN_SRC jupyter-python :session py :kernel python3
with open("lab_fts_dims_act.yml", "r") as stream:
    config = yaml.safe_load(stream)
    
starting_rays, good_vals = create_source_rays_uniform_from_start_displacement(
    config['detector']['center'], config['detector']['normal_vec'], 
    0, 0, 300, 15, config, theta_bound=np.pi / 2, check_rays=True, timeout=100, 
    count_thetas=True)

with open("lab_fts_dims_mcmahon_backwards.yml", "r") as stream:
    config = yaml.safe_load(stream)

#possible_paths = [['OM2', 'A1', 'OM1'] + path[::-1] for path in get_possible_paths()]
possible_paths = [path[::-1] for path in get_possible_paths()]
# only do the 1st and 5th of these paths
possible_paths = [possible_paths[1]]
final_rays = run_rays_through_sim(
    starting_rays, config, np.array(config['origins']['mirror']), 
    paths=possible_paths)

transformed_rays = transform_rays_to_coupling_optics_frame(final_rays)

# fig = go.Figure()

# #plot the initial ray steps
# all_points = []
# all_vectors = []
# all_distances = []
# for path in possible_paths:
#     total_ray_points, total_vectors, total_distances = step_rays(
#         starting_rays, config, run_ray_through_sim, config, [0, 0, 0], 
#         path, final_dist=238, debug=False)

#     all_points.append(total_ray_points)
#     all_vectors.append(total_vectors)
#     all_distances.append(total_distances)

#plot_all_items(config, all_points, all_vectors, all_distances, [0, 0, 0], fig=fig)

out_forwards = csims.run_rays_forwards_input_rays(transformed_rays, z_ap=csims.FOCUS[2], plot=False,
                                                  fig=fig, color='red')
# fig.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards.shape
#+END_SRC

#+RESULTS:
: (9, 210)

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(np.unique(np.array(good_vals)[:, 0]))
#+END_SRC

#+RESULTS:
: 12

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(np.unique(np.array(good_vals)[:, 1]))
#+END_SRC

#+RESULTS:
: 25

#+BEGIN_SRC jupyter-python :session py :kernel python3
out_forwards.shape
#+END_SRC

#+RESULTS:
: (9, 467)

#+BEGIN_SRC jupyter-python :session py :kernel python3
np.unique(np.round(out_forwards[8], 3))
#+END_SRC

#+RESULTS:
: array([3450.912, 3450.913, 3450.915, 3450.918, 3450.922, 3450.93 ,
:        3450.941, 3450.957, 3450.979, 3451.008, 3451.009, 3451.047,
:        3451.048, 3451.098, 3451.162, 3451.243, 3451.343, 3451.344,
:        3451.467, 3451.468, 3451.619, 3451.62 ])

#+BEGIN_SRC jupyter-python :session py :kernel python3
t = []
with open('test.p', 'rb') as pf:
    try:
        while True:
            a = pickle.load(pf)
            t.append(a)
            #print(a)
    except EOFError:
        pass
    
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session py :kernel python3
len(t)
#+END_SRC

#+RESULTS:
: 10

This behavior is symmetry in x but not in y...
